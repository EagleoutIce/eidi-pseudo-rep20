\input{configuration.tex}

\title{EidI-Repetitorium SoSe20}
\subtitle{Naja, das inoffizielle}
\author{Florian Sihler}
\date{07.02.2020}
\institute{Verteilte Systeme \(\circ\) Universität Ulm}
\outro{Ulm, den \today}

\SetEmblem[university Ulm]{Praktische Informatik}{\faCode}

\titleimage{%
    \begin{tikzpicture}[every node/.style={transform shape},t/.style={}]
    \node at(0,0) [rounded corners=6pt,rectangle,draw,fill=fillA] (0) {\footnotesize ~~Anweisung~~~};
    \foreach \l [count=\xi] in {Wert\-zu\-wei\-sun\-gen,An\-weis\-ungs\-block,Operatoren,Leer,Be\-ding\-te An\-weis\-ung,Mehr\-fach\-ver\-zwei\-gung,Wdh. \-an\-weis\-ung\-en} {
        \node at(2.2*\xi-8*1.1,-2) [rounded corners = 6pt,rectangle, draw, text width=1.8cm,align=center,font=\scriptsize\sffamily] (\xi) {\l};
        \draw[-Kite] (0) to[out=270- 3*7 +\xi*5,in=90] (\xi);
    }

    \foreach \l/\t [count=\xi] in {\<A\>=\<B\>/t,\{Anwe.\ldots\}/t,Präzedenz/{},;/t,if(\<a\>)\{\ldots\}/t,switch-case/{},Schleifen/{}} {
        \node at(2.2*\xi-8*1.1,-3.5) [below,rounded corners = 6pt,rectangle, draw, minimum width=1.8cm, minimum height=0.75cm,\t,align=center] (a\xi) {\scriptsize\T{\l}};
        \draw [-Kite] (\xi) -- (a\xi);
    }
    \end{tikzpicture}%
}

\begin{document}

\pdfbookmark[2]{Themenübersicht}{eidi@toc@mainview}
\begin{frame}{Themenübersicht, I}
    \begin{center}
        \twosplit[c]{\tableofcontents[sections={1-2}]}{\tableofcontents[sections={3-4}]}
    \end{center}
\end{frame}

\begin{frame}{Themenübersicht, II}
    \begin{center}
        \twosplit[c]{\tableofcontents[sections={5-6}]}{\tableofcontents[sections={7-8}]}
    \end{center}
\end{frame}


\begin{frame}{}
    \usebeamercolor{title}%
    \vskip1em
    {\centering\usebeamerfont{title}\MakeUppercase{Disclaimer}\par}
    \vfill
    \begin{center}
        \footnotesize\begin{minipage}{0.95\linewidth}
Der folgende Dokumentsatz hat keinen Anspruch auf vollständige Richtigkeit.
Er wurde auf Basis der zugrundeliegenden Vorlesungsmaterialien erstellt und ist eher als unverbindliche Hilfe im Kontext seiner Natur als Zusammenfassung zu verstehen.
Hinzu kommt, dass die kapitelbasierte Einteilung der Vorlesungsvorlage dort durchbrochen wurde, wo eine andere Gruppierung angenehmer oder passender erschien, weiter wird ein Verständnis über die Themen vorrausgesetzt, so versuche ich es zwar zu vermeiden, Vorgriffe zu tätigen, scheue aber dennoch nicht vor ihnen zurück -- sofern vonnöten. \begin{center}
    Bei Anregungen oder Verbesserungsvorschlägen einfach melden!\\
\end{center}
Alle Grafiken wurden von mir, Florian Sihler, mithilfe von \LaTeX{} und Ti\textit{k}Z erstellt, ebenso wie das hier gezeigte Beamer-Layout. Für das Syntax-Highlighting wird das Paket \emph{sopra-listings} meiner \emph{sopra-collection} (\url{https://github.com/EagleoutIce/sopra-collection}) verwendet.\hfill {\tiny Florian Sihler, \href{mailto:florian.sihler@uni-ulm.de}{florian.sihler@uni-ulm.de}}\relax
\begin{center}
    \say{Viel Spaß beim Lernen!}
\end{center}
        \end{minipage}
    \end{center}
    \vfill\hbox{}
\end{frame}

\section{Theoretische Grundlagen}
\subsection{Der Algorithmusbegriff}
\begin{frame}{Was ist ein Algorithmus?}
    \pause{}
    \begin{definition}[Algorithmus]
        \pause{}Ein \emph{Algorithmus} ist eine \emph{eindeutige Handlungsvorschrift} zur Lösung eines Problems.
    \end{definition}
    \begin{itemize}[<+(1)->]
        \widei
        \item Es existieren verschiedene Darstellungsformen: \begin{itemize}
            \item Textuell \pause(1. Tue dies, 2. Tue das, 3. Falls \(X\)\ldots)
            \item Grafisch \pause(Instruktionsabläufe, Graphen, Grafiken, \ldots)
            \item Pseudocode
        \end{itemize}
        \item Klassische Alltagsbeispiele:\pause{} (Koch-)Rezepte,\pause{} Gebrauchsanleitungen,\pause{} \ldots
    \end{itemize}
\end{frame}

\subsection{Algorithmen analysieren}
\begin{frame}{Algorithmuseigenschaften}
    \begin{itemize}[<+(1)->]
        \widei
        \item Zu Beginn gilt es einige Begriffe zu klären: \begin{description}[Elementaroperation]
            \item[Prozess] Die Ausführung der Schritte eines Algorithmus
            \item[Prozessor] Der Ausführende (Mensch, Computer, \ldots)
            \item[Elementaroperation] Eine einzelne, eindeutige Handlung.
        \end{description}
        \item Ein Algorithmus besitzt einige Eigenschaften: \begin{description}[Ausführbarkeit]
            \item[Ausführbarkeit] Die Anleitung muss ausführ- und reproduzierbar sein.
            \item[Endlichkeit] Der gesamte Algorithmus muss mit endlich viel Text beschrieben werden können.
            \item[Termination] Der Algorithmus muss nach endlich vielen Schritten zum Ende kommen.
            \item[Verarbeitung] Ein Algorithmus erhält Eingabeobjekte \(E\),\pause{} hält lokale Daten \(D\)\pause{} und erzeugt Ausgabedaten \(A\).
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}[c]{Eigenschaften für die Analyse}
    \twosplit{%
    \begin{block}<2->{Korrektheit}
        \onslide<3->{Ein Algorithmus ist korrekt, wenn er für jede (definierte) Eingabe, die korrekte Ausgabe erzeugt.}
    \end{block}\bigskip
    \begin{block}<6->{Partielle Korrektheit}
        \onslide<7->{Wenn der Algorithmus terminiert, ist er korrekt.}
    \end{block}
    }{%
    \begin{block}<4->{Robust}
        \onslide<5->{Ein Algorithmus ist (maximal) robust, wenn er falsche Eingabe erkennen und abfangen kann.}
    \end{block}\bigskip
    \begin{block}<8->{Totale Korrektheit}
        \onslide<9->{Der Algorithmus ist partiell korrekt und terminiert.}
    \end{block}
    }
\end{frame}

\begin{frame}{Eigenschaften für die Analyse}
    \twosplit{%
    \begin{block}<2->{Determinismus}
        \onslide<3->{Der Ablauf des Algorithmus ist \emph{eindeutig}. Für jede Anweisung folgt bei gleichen Vorraussetzungen dieselbe.}
    \end{block}
    }{%
    \begin{block}<4->{Determiniertheit}
        \onslide<5->{Die selben Eingabedaten erzeugen immer die selben Ausgabedaten.}
    \end{block}
    }\bigskip
    \begin{itemize}
        \item<6-> Die Begriffe sind zu unterscheiden!
        \item<7-> So können bei einem Algorithmus verschiedene Wege zum selben Ziel führen.
        \item<8-> (Sinnfreies) Beispiel: \onslide<9->{Der Algorithmus kann jedes Element eines Arrays quadrieren. \onslide<10->{Die Reihenfolge wählt er zufällig aus!}}
        \item<11-> Dieser Algorithmus \emph{determiniert}, \onslide<12->{ist aber \emph{nicht-deterministisch}!}
    \end{itemize}
\end{frame}


\begin{frame}{Schema eines Algorithmus}
    \onslide<2->{
    \begin{figure}
        \begin{tikzpicture}
            \node[block] (A) at(0,0) {Algorithmus};
            \node (V) at(-5,0) {Vorbedingung};
            \node (N) at(5,0) {Nachbedingung};
            \draw[link] (V) edge (A) (A) edge (N);
        \end{tikzpicture}
    \end{figure}}
    \begin{itemize}[<+(1)->]
        \widei
        \item Ein Algorithmus benötigt (formal) eine: \begin{description}[iV]
            \item[V] Vorbedingung (wie \say{positive ganze Zahl})
            \item[N] Nachbedingung (wie \say{negative Fließkommazahl})
        \end{description}
        \item Algorithmen fundieren auf einem \emph{Problem} der realen Welt und werden durch Abstraktion formuliert.
        \item (Java-)Programme sind eine Darstellung von Algorithmen,\pause{} die von Maschinen interpretiert und realisiert werden.
     \end{itemize}
\end{frame}

\begin{frame}{Schema eines Algorithmus}
    \onslide<2->{
    \begin{figure}
\begin{tikzpicture}[
    every node/.style={transform shape},block/.append style={minimum width={3.5cm}},
    scale=0.75]
    \node[block] at(0,0) (PM)  {Problem};
    \node[block] at(0,-3) (AL)  {Algorithmus};
    \node[block] at(0,-5) (PR)  {Programm};
    \node[block] at(0,-7) (MA)  {Maschine};
    \draw[link] (PM) -- (AL);
    \draw[link] (AL) -- (PR);
    \draw[link] (PR) -- (MA);
    \node[left=0.5cm] at (0,-1.5) {Abstraktion};
    \node[left=0.5cm] at (0,-4) {Implementierung};
    \node[left=0.5cm] at (0,-6) {Realisierung};

    \node[right,align=left,text width=5cm] at (0.5,-1.45) {\begin{itemize}
        \item Problemanalyse
        \item Funktionale\\ Spezifikation
        \item Algorithmenentwurf
    \end{itemize}
    };

    \node[right,align=left,text width=5cm] at (0.5,-3.85) {\begin{itemize}
             \item Darstellung in\\Programmiersprache
         \end{itemize}
    };

    \node[right,align=left,text width=5cm] at (0.5,-5.85) {\begin{itemize}
            \item Umsetzung in\\ Maschinenbefehle
        \end{itemize}
    };
    % \node[right,align=left] at (0,-4) {\begin{itemize}
    %         \item Darstellung in\\Programmiersprache
    %     \end{itemize}
    %     };
    % \node[right,align=left] at (0,-6) {\begin{itemize}
    %         \item Umsetzung in\\ Maschinenbefehle
    %     \end{itemize}
    %     };
\end{tikzpicture}
    \end{figure}}
\end{frame}

\subsection{Konzeptionalisierung}

\begin{frame}{Wie ein Programm entsteht}
    \begin{itemize}[<+(1)->]
        \widei
        \item Ein Programm selbst fällt nicht einfach aus dem Wolken (leider).
        \item Grundlegend gliedert man (im Softwareengineering) die Konstruktion in sechs Phasen.
        \item Die sechste Phase (Dokumentation) unterscheidet sich in sofern,\pause{} als dass sie Parallel zu den anderen stets aktiv ist.
        \item Die Dokumentation bezeichnet nicht nur die exakte Beschreibung aller für die Umsetzung notwendiger Komponenten,\pause{} sondern schließt auch Beschreibungen zum Code, zu verschiedenen Lösungsansätzen,\pause{} sowie dem Ablauf selbst mit ein!
    \end{itemize}
\end{frame}

\begin{frame}[c]{Wie ein Programm entsteht}
    \begin{center}
        \resizebox{0.95\linewidth}{!}{
        \begin{tikzpicture}
            \onslide<2->{\node[iblock,minimum width=3cm] (init) at (-5.5,0) {Problem};}
            \foreach[count=\i,remember=\i as \li (initially init)] \l in {Analyse, Entwurf, Implementierung, Test \& Revision} {
                \pgfmathsetmacro\ovlskip{int(\i+2)};
                \onslide<\ovlskip->{
                \node[block,minimum width=5cm] (\i) at(0,-1.6*\i+1.6) {\l};
                \draw[link] (\li) -- (\i);}
            }
            \onslide<3->{
                \node[above right=0.75cm,yshift=-0.5cm,align=left,font=\scriptsize,text width=4.25cm] (d1) at (1.north east) {Untersuche Problem, in der Regel in Zusammenarbeit mit Nicht-Informatikern.};
                \draw[densely dashed] (d1.west) -- (1.east);
            }
            \onslide<4->{
                \node[above right=0.75cm,yshift=-1cm,align=left,font=\scriptsize,text width=4.25cm] (d2) at (2.north east) {Entwickle Algorithmus, kreativer Prozess (beantwortet auch Fragen wie: \say{gibt es das schon?})};
                \draw[densely dashed] (d2.west) -- (2.east);
            }
            \onslide<5->{
                \node[right=0.75cm,align=left,font=\scriptsize,text width=4.25cm] (d3) at (3.north east) {Übersetze Algorithmus in Programmiersprache};
                \draw[densely dashed] (d3.west) -- (3.east);
            }
            \onslide<6->{
                \node[left=0.75cm,yshift=0.25cm,align=right,font=\scriptsize,text width=4.25cm] (d4) at (4.north west) {Prüft das Programm auf (logische und technische) Fehler.\\[0.25em] Diese Phase kann im Allgemeinen nur die Anwesenheit und nicht die Abwesenheit von Fehlern aufzeigen.};
                \draw[densely dashed] (d4.east) -- (4.west);
            }
            \onslide<7->{
                \node[iblock,minimum width=3cm] (exit) at (5.5,-3*1.6) {Programm};
            \draw[link] (4) -- (exit);
            }\onslide<1->{}
        \end{tikzpicture}}
    \end{center}
\end{frame}

\subsection{Übungsaufgaben}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Algorithmus beschreiben}
    \begin{exercise}<2->[Algorithmus beschreiben \Time{2}]
        Beschreibe einen Algorithmus, der das maximale Element einer Datenmenge bestimmt.\pause{}
        \textit{Hinweis: Auf den Elementen muss keine numerische Ordnung definiert sein.}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Algorithmus beschreiben]
        \pause{}Wir betrachten den textuellen Ansatz: \begin{enumerate}[<+(1)->]
            \item Keine Eingabedaten?\pause{} Fertig.
            \item Setze Maximum auf erstes Element der Eingabedaten.
            \item Tue für jedes weitere Element der Eingabedaten: \begin{enumerate}
                \item Ist das zu betrachtende Element \say{größer} als das bisherige Maximum? \begin{description}
                    \item[Ja] ersetze Maximum durch dieses Element
                    \item[Nein] tue nichts
                \end{description}
            \end{enumerate}
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Charakteristika eines Algorithmus}
    \begin{exercise}<2->[Charakteristika \Time{2}]
        Ist der folgende Algorithmus (total) korrekt?\pause{}
        \begin{plainjava}
public static int simpleMod(int a, int b){
    while(a >= b)
        a -= b;
    return a;
}
        \end{plainjava}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Charakteristika]
       \pause{}Der Algorithmus ist nicht total korrekt.\pause{} So liefert er für ein negatives \T{b} kein korrektes Ergebnis,\pause{} da hier \T{a -= b} zu einem Überlauf führt.\pause{}\par{}
       Ferner ist er auch nicht partiell korrekt.\pause{} So liefert er für ein negatives \T{a} bei einem positiven \T{b} einfach nur \T{a} zurück.
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Determinismus und Determiniertheit}
    \begin{exercise}<2->[Deterministische Determiniertheit \Time{2}]
        \pause{}Nenne je ein Beispiel für einen Algorithmus der:
        \begin{enumerate}[<+(1)->]
            \item[i)] nicht-deterministisch ist und determiniert.
            \item[ii)] sowohl deterministisch ist, als auch determiniert.
        \end{enumerate}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Deterministische Determiniertheit]
        \pause{}\begin{enumerate}[<+(1)->]
            \item[i)] Suche, ob ein Element in den Eingabedaten vorkommt.\pause{} Die Elemente werden in einer zufälligen Reihenfolge verglichen.
            \item[ii)] Ein Algorithmus der eine Zahl verdoppelt, in dem er sie mit \(2\) multipliziert.
        \end{enumerate}
    \end{solve}
\end{frame}

% TODO: Kapitel zu (Korrektheits-)beweisen und Aufwandsanalysen - noch aus dem ersten Foliensatz.

\section{Java-Basics}
\subsection{Wie ein Java-Programm entsteht}
\begin{frame}[c]{Vom Text zum Programm}
    \begin{center}
        \onslide<2->{
        \begin{tikzpicture}[scale=1.1, every node/.style={transform shape}, rec/.style={block,minimum width=3.25cm},irec/.style={iblock,minimum width=3.25cm}]
            \draw (0,0) node[right,irec] (prg) {Programmtext};
            \draw (2,-1) node[right,rec] (bib) {Bibliotheken};
            \draw (2,-2) node[right,rec] (adMac) {Maschinencode};
            \draw (6,-1.5) node[right,rec] (link) {Linker};
            \begin{scope}[every path/.style={link}]
                \draw (prg) -- ++(2,0) node[right,rec] (comp) {Compiler};
                \draw (comp) -- ++(2,0) node[right, rec] (mac) {Maschinencode};
                \draw (bib) -| ++ (2,-0.4) -- ([yshift=0.1cm]link.west);
                \draw (adMac) -| ++ (2,0.4) -- ([yshift=-0.1cm]link.west);
                \draw (link) -- ++(2,0) node[right, irec] (prog) {Program};
                \draw (mac) -- ++ (0,-0.62) -| (link.north);
                \draw (prg)++(0,0.75) node[above] {\tiny Das machen wir} -- (prg);
                \draw (prog)++(0,-0.75) node[below] {\tiny Das wollen wir} -- (prog);
                \draw (comp)++(-1,1) node[above] {\tiny Semantik-Analyse} -- (comp);
                \draw (comp)++(0,0.75) node[above] {\tiny Syntax-Analyse} -- (comp);
                \draw[btcd@color@alerted] (comp)--++(1,0.75) node[right] {\tiny Compile-Fehler};
                \draw[btcd@color@alerted] (prog)--++(0,0.75) node[above] {\tiny Laufzeit-Fehler};
                \draw (link)++(0,-0.75) node[below] {\parbox{12ex}{\tiny statisch/dynamisch\index{Java!Konvertierung!statisches/dynmaisches Linken}\\\hphantom{statisch/dy}(Java)}} -- (link);

            \end{scope}
        \end{tikzpicture}
        }
    \end{center}
\end{frame}

\begin{frame}{Vom Text zum Programm}
    \begin{itemize}[<+(1)->]
        \widei
        \item Mit \bbash{javac :lan:Name:ran:.java} übersetzt Java die Datei in \emph{Java-Bytecode}\pause{} (\bbash{:lan:Name:ran:.class})
        \item Dieser Code kann vom Interpreter \bbash{java} ausgeführt werden:\pause{} \bbash{java :lan:Name:ran:}
        \item Ein paar wichtige Punkte: \begin{itemize}
            \item Bei den \T{.class}-Dateien handelt es sich um \emph{keine} \T{.zip}-Dateien!
            \item Die \T{.jar}-Dateien von Java sind \T{.zip}-Archive.
            \item Der Interpreter (\bbash{java}) ist sowohl im Java-Runtime-Environment (JRE) als auch im Java-Development-Kit (JDK) enthalten.
            \item Der Compiler wird nur mit der JDK ausgeliefert.
        \end{itemize}
    \end{itemize}
\end{frame}

\subsection{Bezeichner \& Variablen}

\begin{frame}{Gültige Java-Bezeichner}
    \begin{itemize}[<+(1)->]
        \widei
        \item Java stellt folgende Regeln an Bezeichner für Variablen, Klassen, \ldots \begin{itemize}
            \item Diese dürfen nur aus Buchstaben, Ziffern, dem Unterstrich (\_) und dem Dollarzeichen (\$) bestehen.
            \item Ein Bezeichner darf \emph{nicht} mit einer Ziffer angeführt werden.
            \item Schlüsselbegriffe (wie \bjava{int}, \bjava{double}, \ldots) dürfen nicht als Bezeichner verwendet werden.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Variablen und Wertzuweisungen}
    \pause{}
    \begin{center}
        \parbox{7cm}{\!\bjava{int zahl = -42, super_zahl = 4;}\\\bjava{zahl = 42;}
        }
    \end{center}
    \begin{itemize}[<+(1)->]
        \widei
        \item Java ist eine \emph{streng typisierte} Sprache.\pause{} Jede Variable kann nur Daten \emph{eines (bestimmten) Typs speichern}.
        \item Wir unterscheiden zwischen \emph{primitiven} und \emph{komplexen} Datentypen. \begin{description}[Primitive]
            \item[Primitive] \bjava{byte}, \bjava{short}, \bjava{int}, \bjava{long}, \bjava{float}, \bjava{double}, \bjava{char}, \bjava{boolean} (Hinweis: \emph{call-by-value})
            \item[Komplexe] \bjava{String}, \bjava{Random}, \ldots (Hinweis: \emph{call-by-reference})
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Konvertierung primitiver Datentypen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Java kann manche Datentypen ineinander Umwandeln.\pause{} Es gilt:\pause{}
        \begin{center}
            \bjava{byte} \mprec{} \bjava{short} \mprec{} \bjava{int} \mprec{} \bjava{long} \mprec{} \bjava{float} \mprec{} \bjava{double}
        \end{center}
        \pause{}Sowie:\pause{}
        \begin{center}
            \bjava{char} \mprec{} \bjava{int}
        \end{center}
        \item So kann Java einen \bjava{char} implizit in einen \bjava{int} umwandeln\pause{} (da der Wertebereich größer ist).\pause{} Umgekehrt allerdings nicht.
        \item \imp{Floats und Doubles unterliegen einem Rundungsproblem.}
        \item Unter der Einschränkung des Wertebereichs kann durch \bjava{(:lan:Datentyp:ran:):lan:Variable:ran:} eine explizite Konvertierung erfolgen.
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Konstanten und Hinweise}
    \begin{itemize}[<+(1)->]
        \widei
        \item Konstanten werden in Java mit dem Schlüsselbegriff \bjava{final} gekennzeichnet: \begin{plainjava}
final int SUPER_ZAHL = 42;
        \end{plainjava}
        \item Schreiben wir eine Fließkommazahl wie \bjava{3.1415}\pause{} interpretiert sie Java erstmal als \bjava{double}.\pause{} Damit es sie als \bjava{float} interpretiert müssen wir ein \bjava{f} anstellen.\pause{} Also: \bjava{3.1415f}.
        \item Zeichen (\bjava{char}) werden in Java im UTF-16 Format gespeichert.\pause{} Für die unteren \(7\)-Bit ist es identisch zur ASCII-Kodierung.
        \item Der \say{Datentyp} \bjava{void} gibt bei Methoden an,\pause{} dass diese nichts zurück geben!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Präzedenzregeln}
    \begin{itemize}[<+(1)->]
        \widei
        \item Operationen werden in Java in einer gewissen Reihenfolge ausgeführt.\pause{} Diese wird durch die Präzedenzregeln bestimmt:\onslide<1->
        \begin{alignat*}{3}
            \onslide<4->{\Big[a\text{++},a\text{-\!\! -}\Big]}&\onslide<5->{\to~\Big[!a, -a, \text{++}a,\text{-\!\! -}a\Big]}&&\onslide<6->{\pause\to~\Big[*,/,\%\Big]} &&\onslide<7->{\to~\Big[a+b,a-b\Big]}\\
            &\onslide<8->{\to~\Big[==,>=,<,\ldots\Big]} &&\onslide<9->{\to~\Big[\&\&\Big]}&&\onslide<10->{\to~\Big[||\Big]}\onslide<1->
        \end{alignat*}
        \vspace*{-0.5cm}\onslide<1->
    \end{itemize}
    \Task{Code zur Präzedenz}
    \begin{exercise}<11->[Was liefert dieser Code? \Time{3}]
        \begin{plainjava}[columns={[c]fullflexible}]
int x = 40, m = 3;
System.out.println(-x++ - --m);
System.out.println(x > 41 || m > 1 && 2 != 3);
        \end{plainjava}
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Präzedenzregeln -- Lösung}
    \begin{solve}<2->[Was liefert dieser Code?]
        \pause{}\begin{plainjava}[columns={[c]fullflexible}]
System.out.println(-x++ - --m); // :yields: -42
        \end{plainjava}
        \pause{}Aufgrund der Postfix-Notation \bjava{x++} wird \bjava{x} \emph{nach} dem Ausdruck um \(1\) erhöht!\pause{} Wegen des Präfix-Dekrements von \bjava{m} wird \bjava{m} um eins verringert.\pause{} Nun werden \bjava{-x} (\(=-40\)) mit \bjava{m} (\(= 2\)) subtrahiert (\bjava{= -42}).\pause{} \bjava{x} ist nun \bjava{41}.
        \begin{plainjava}[columns={[c]fullflexible}]
System.out.println(x > 41 || m > 1 && 2 != 3); // :yields: true
        \end{plainjava}
        Da \bjava{||} am schwächsten bindet,\pause{} werden zuerst \bjava{x > 41} (\bjava{41 > 41} \(\to\) \bjava{false}) und \bjava{m > 1:ws:&& 2:ws:!= 3} betrachtet.\pause{} Nun wird also \bjava{m > 1} (\bjava{2 > 1} \(\to\) \bjava{true}) und \bjava{2 != 3} (\bjava{true}) ausgewertet.\pause{} Damit evaluiert das \bjava{true:ws:&& true} zu \bjava{true} und somit auch das \bjava{false:ws:|| true} zu \bjava{true}.
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Präzedenzregeln, II}
\Task{Code zur Präzedenz, II}
\begin{exercise}<2->[Was liefert dieser Code?, II \Time{2}]
    \begin{plainjava}[columns={[c]fullflexible}]
int x = 5;
System.out.println(x);
System.out.println(x++ + ++x + x++ + ++x);
System.out.println(x);
    \end{plainjava}
    \pause{}\textit{Hinweis: Dies ist lediglich eine Bonusübung, um den Unterschied zwischen der Präfix- und der Postfixnotation klar zu machen.}
\end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Präzedenzregeln, II -- Lösung}
    \begin{solve}<2->[Was liefert dieser Code?, II]
        \pause{}\begin{plainjava}[columns={[c]fullflexible}]
System.out.println(x); // :yields: 5
        \end{plainjava}
        \pause{}Zu Beginn hält \bjava{x} den Wert \(5\), so weit nichts besonderes.
        \begin{plainjava}[columns={[c]fullflexible}]
System.out.println(x++ + ++x + x++ + ++x); // :yields: 28
        \end{plainjava}
        \pause{}Dies ist wohl die schwierigste Zeile.\pause{} Aufgeschlüsselt wird hier addiert: \(5 + 7 + 7 + 9 = 28\).\pause{} Die erste \(5\), da \bjava{x} erst nachträglich erhöht wird.\pause{} Dann wird \bjava{x}, welches jetzt \(6\) ist, direkt um eins erhöht.\pause{} \bjava{x} ist jetzt \(7\), das Spiel wiederholt sich für das Hintere \bjava{++x}.\pause{}
        \begin{plainjava}[columns={[c]fullflexible}]
System.out.println(x); // :yields: 9
        \end{plainjava}
        \pause{}Durch die \(4\) Inkremente ist \bjava{x} nun \(9\).\pause{} (\textit{Das ist \emph{kein} guter Code!})
    \end{solve}
\end{frame}

\begin{frame}{Präzedenzregeln - Kommentar}
    \begin{itemize}[<+(1)->]
        \widei
        \item Java wendet die mathematischen Rechenregeln wie bekannt an.
        \item Auch das Klammern funktioniert wie gewohnt.
        \item Boolesche Operatoren funktionieren wie in der Aussagenlogik.
    \end{itemize}
\end{frame}

\subsection{Komplexe Datentypen}

\begin{frame}[fragile]{Komplexe Datentypen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Java erlaubt es mit Klassen komplexe Datentypen zu konstruieren.
        \item Der wichtigste ist \bjava{String},\pause{} welcher von Java eine Sonderbehandlung erfährt.
        \item Bei der Deklaration eines komplexen Datentyps:\pause{}
\begin{plainjava}
Random rnd = new Random();
\end{plainjava}
        \pause{}speichert Java für \bjava{rnd} die Adresse,\pause{} an der sich die eigentlichen Daten des Objekts befinden.
        \item Deswegen sollen Strings mittels \bjava{.equals()} verglichen werden.\pause{} \bjava{==} vergleicht die Speicheradressen\pause{} und damit ob die Zeichenketten identisch sind.
    \end{itemize}
\end{frame}

\begin{frame}{Strings}
    \begin{itemize}[<+(1)->]
        \widei
        \item Jede Variable/jedes Objekt kann in Java mittels \bjava{toString()} in einen \bjava{String} konvertiert werden.
        \item Wir können auf einem String-Objekt diverse Operationen aufrufen: \begin{description}[\T{s1.substring(a,b)}]
            \item[\T{s1.equals(s2)}] prüft ob die Zeichenketten gleich sind.
            \item[\T{s1.length()}] liefert die Länge einer Zeichenkette.
            \item[\T{s1.charAt(k)}] liefert das \T{k}-te Zeichen.
            \item[\T{s1.substring(a,b)}] liefert einen Ausschnitt der Zeichenkette vom \(a\)-ten bis zum \(b-1\)-ten Zeichen.
            \item[\T{s1.toUpperCase()}] liefert die Zeichenkette in Großbuchstaben.
        \end{description}
    \end{itemize}
\end{frame}

\subsection{Subroutinen}
\begin{frame}[fragile]{Funktionen}
    \begin{itemize}[<+(1)->]
        \item Analog zur \bjava{main}-Funktion, lassen sich in Java Routinen implementieren.
        \item Die allgemeine Syntax lautet:\pause{}
{\footnotesize
\begin{plainjava}
:lan:Zugriffsmodifikatoren:ran: :lan:Rückgabetyp:ran: :lan:Name:ran:(:lan:Parameterliste:ran:) {
    :lan:Körper:ran:
}
\end{plainjava}
}
        \item Beispiel: \pause{}
{\footnotesize
\begin{plainjava}
private static String generateWelcomeMessage(String name, int age,
        boolean married) {
    return "Welcome, " + name /* ... */ ;
}
\end{plainjava}
}
        \item Hinweis:\pause{} Bevor wir zu Klassen an sich kommen,\pause{} machen wir alle Funktionen \bjava{static},\pause{} um sie auch von der \bjava{main}-Methode aus aufrufen zu können.
    \end{itemize}
\end{frame}

\begin{frame}{Signatur \& Überladung}
    \begin{itemize}[<+(1)->]
        \item Die Signatur einer Methode/Funktion besteht aus dem Namen sowie den Datentypen der Parameter.\pause{} Der Rückgabetyp ist \emph{kein} Teil der Signatur.
        \item Beispiel: \bjava{generateWelcomeMessage(String, int, boolean)}.
        \item Java erlaubt keine zwei Funktionen mit gleicher Signatur im selben Gültigkeitsbereich.
        \item Man kann allerdings Funktionen mit gleichem Namen,\par{} aber verschiedener Parameterliste erstellen.\pause{} Dieses Prinzip wird \emph{Überladen} (Overloading) genannt.
        \item Existieren mehrere Überladungen mit gleicher Parameteranzahl\pause{} (wie \bjava{m(int,double)}, \bjava{m(char,float)}, \ldots).\pause{} Entscheidet Java welche Methode aufgerufen werden soll\pause{} (es nimmt die,\pause{} die am \say{nächsten} dran ist).
    \end{itemize}
\end{frame}


\subsection{Zugriffsmodifikatoren}

\begin{frame}{private und public}
    \begin{itemize}[<+(1)->]
        \item Java erlaubt vier verschiedene Zugriffsmodifikatoren: \begin{description}[protected]
            \item[private] Zugriff ist nur innerhalb der Klasse erlaubt.
            \item[\say{default}] gibt man nichts an, so kann die Variable von Überall im Paket erreicht werden.
            \item[protected] ist sichtbar im gesamten Paket sowie in allen Kindklassen (\hyperlink{mrk:Vererbung}{Vererbung}).
            \item[public] ist überall sichtbar (auch über Pakete hinweg).
        \end{description}
        \item Hinweis (Vorgriff):\pause{} Objekte einer Klasse können auch auf private Elemente anderer Objekte der gleichen Klasse zugreifen.
    \end{itemize}
\end{frame}

\begin{frame}[c]{Es gilt festzuhalten\ldots}
    \begin{definition}[Subroutinen]
        Eine Subroutine/Funktion ist ein \emph{Unterprogramm},\pause{} das von anderen Programm(teilen) aufgerufen und so wiederverwendet werden kann.\pause{}\medskip\newline Sie wird durch ihre \emph{Signatur} eindeutig identifiziert,\pause{} die in Java aus einem Bezeichner sowie einer Liste an Datentypen der Parameter besteht. Ein Unterprogramm ist in der Lage Daten an den aufrufenden Teil zurückzuliefern.
    \end{definition}
\end{frame}

\subsection{Übungsaufgaben}


\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Suche syntaktischer Fehler, I}
    \begin{exercise}<2->[Fehler finden, I \Time{3}]
        \pause{}Finde und korrigiere alle (syntaktischen) Fehler:\pause{}
        \begin{plainvoid}
public void main(String[] hihi) {
    private final int X = 12;
    System.out.printLn("Huhu " + (byte) X)
}
        \end{plainvoid}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Fehler finden, I]
        \pause{}\begin{plainjava}
public static void main(String[] hihi) {
    final int X = 12;
    System.out.println("Huhu " + (byte) X);
}
        \end{plainjava}
    \begin{enumerate}[<+(1)->]
        \item Die \bjava{main}-Methode muss \bjava{static} sein!
        \item Zugriffsmodifikatoren wie \bjava{private} dürfen nicht in einer Funktion auftreten.
        \item Die Funktion \bjava{printLn} heißt \bjava{println}.
        \item In der Ausgabezeile fehlt ein Semikolon!
    \end{enumerate}
    \pause{}\textit{Hinweis: das \say{hihi} ist kein Fehler!}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Suche syntaktischer Fehler, II}
    \begin{exercise}<2->[Fehler finden, II \Time{3}]
        \pause{}Finde und korrigiere alle (syntaktischen) Fehler:\pause{}
        \begin{plainvoid}
public int double(int x) { return (2*)x; }

public static void main() {
    System.in.print(double(21));
}
        \end{plainvoid}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Fehler finden, II]
        \pause{}\begin{plainjava}
public static int doDouble(int x) { return (2*x); }
public static void main(String[] args) {
    System.out.print(doDouble(21));
}
        \end{plainjava}
    \begin{enumerate}[<+(1)->]
        \item Der Bezeichner \bjava{double} ist für eine Funktion nicht erlaubt.
        \item Der Ausdruck in der Funktion ist ungültig geklammert.
        \item Die Funktion muss \bjava{static} sein um aufgerufen werden zu können.
        \item Die \bjava{main}-Methode benötigt die Signatur \bjava{main(String[])}!
        \item \bjava{System.in} hat die Funktion \bjava{print(String)} nicht.
    \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Methodensignaturen}
    \begin{exercise}<2->[Signaturen \Time{2}]
        \pause{}Gibt die Signaturen folgender Funktionen an.\pause{} Sollte eine Signatur ungültig sein, begründe wieso:\pause{}
        \begin{plainvoid}
String a(int a1, double a2) { /* ... */ }
int b(String[] b1, int b2, double[] b3) { /* ... */ }
double c(String... c1, char c2) { /* ... */ }
double d(int d1, double... d2) { /* ... */ }
        \end{plainvoid}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Signaturen]
        \begin{enumerate}[<+(1)->]
            \item \bjava{String a(int a1, double a2)} hat die Signatur \bjava{a(int,double)}
            \item \bjava{int b(String[] b1, int b2, double[] b3)} hat die Signatur \bjava{b(String[], int, double[])}
            \item \bjava{double c(String... c1, char c2)} ist nicht möglich,\pause{} da nach \emph{varargs} keine verpflichtenden Argumente mehr kommen dürfen.
            \item \bjava{double d(int d1, double... d2)} hat die Signatur \bjava{d(int,double...)}
        \end{enumerate}
    \end{solve}
\end{frame}



\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Konkatenation}
    \begin{exercise}<2->[Konkatenation \Time{2}]
        \pause{}Was geben die folgenden Zeilen aus? (wenn \bjava{println} einfach nur ein \bjava{System.out.println} ist):\pause{}
        \begin{plainjava}
println("2 + 3 = " + 2 + 3);
println(-'=' + 2 * 3 + '=' + " 2*3");
println(2 - 12 + " * 2 = " + -1!*\solGet{numbers}{\_}*!0 * 2 + ("_" + 'b' + 10));
println("c - a - 1 = " + ('c' - 1 - 'a'));
        \end{plainjava}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Konkatenation]
\pause{}
\begin{plainjava}
println("2 + 3 = " + 2 + 3); // :yields: '2 + 3 = 23'
\end{plainjava}
    \pause{}Da der linke Operand von \bjava{+} ein \bjava{String} ist,\pause{} wird erst die \bjava{2} als String konkateniert,\pause{} und dann die \bjava{3} ebenfalls als Zeichen.\pause{}
\begin{plainjava}
println(-'=' + 2 * 3 + '=' + " 2*3"); // :yields: '6 2*3'
\end{plainjava}
    \pause{}Da die \bjava{char}s einfach in ihren Integerwert konvertiert werden,\pause{} findet erst beim letzten Plus eine Konkatenation statt.
    \end{solve}
\end{frame}
\begin{frame}[c,fragile]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<1->[Konkatenation\hfill(Fortsetzung)]
\pause{}
\begin{plainjava}
println(2 - 12 + " * 2 = " + -1!*\solGet{numbers}{\_}*!0 * 2 + ("_" + 'b' + 10));
    // :yields: '-10 * 2 = -20_b10'
\end{plainjava}
    \pause{}Die erste arithmetische Operation liefert \bjava{-10},\pause{} welches dann zum String konkateniert wird.\pause{} Anschließend greift die Präzedenzregel \say{Punkt vor Strich}\pause{} wobei das Ergebnis anschließend als String konkateniert wird.\pause{} Dann wird in der Klammer durch erneute Konkatenation \bjava{_b10} erzeugt.\pause{}\\
    \textit{Hinweis: Der Unterstich bei \bjava{-10} ist in Java (zwischen Zahlen) komplett valide\pause{} und wird in der Regel zum trennen von \(1000\)er Blöcken verwendet.}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<1->[Konkatenation\hfill(Fortsetzung)]
\pause{}
\begin{plainjava}
println("c - a - 1 = " + ('c' - 1 - 'a'));
    // :yields: 'c - a - 1 = 1'
\end{plainjava}
    \pause{}Java berechnet zuerst die Operationen in der Klammer und wandelt die Zeichen in ihre ASCII-Werte um.\pause{} Diese muss man hierfür nicht kennen,\pause{} da es genügt zu Wissen, dass zwischen \T{a} und \T{c} ein Abstand von \(2\) vorliegt der um eins verringert wird.\pause{}
    Wir berechnen also in der Klammer den wert \(1\).\pause{} Dieser wir nun normal zum String konkateniert, was die Ausgabe erzeugt.
    \end{solve}
\end{frame}

\section{Kontrollstrukturen und Arrays}
\subsection{Fallunterscheidungen}

\begin{frame}[fragile]{Fallunterscheidung mit if}
    \begin{itemize}[<+(1)->]
        \item Java erlaubt Fallunterscheidungen mit \bjava{if}:\pause{}
\begin{plainjava}
if(:lan:Bedingung |plain|1|plain|:ran:){
    // Bedingung 1 ist wahr
} else if (:lan:Bedingung |plain|2|plain|:ran:) {
    // Bedingung 1 ist falsch, Bedingung 2 ist wahr
} else {
    // Beide Bedingungen sind falsch
}
\end{plainjava}
    \item Folgt der \bjava{if}-Instruktion nur eine Anweisung,\pause{} so können die geschwungenen Klammern weggelassen werden.
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Kompakte if-Notation}
    \begin{itemize}[<+(1)->]
        \item Eine (einfache) Fallunterscheidung können wir verkürzen:\pause{}
\begin{plainjava}
:lan:Bedingung:ran: ? :lan:Bedingung-wahr:ran: : :lan:Bedingung-falsch:ran:;
\end{plainjava}
        \pause{}der \emph{wahr}-Teil wird ausgeführt, wenn die Bedingung zutrifft,\pause{} sonst der andere.
        \item Ein Beispiel:\pause{}
\begin{plainjava}
int n = 14;
return (n >= 18) ? "Volljährig" : "Nicht volljährig";
\end{plainjava}
        \item Diese Anweisung kann (beliebig tief) verschachtelt werden.
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Fallunterscheidung mit switch-case}
    \begin{itemize}[<+(1)->]
        \item Java erlaubt Fallunterscheidungen mit \bjava{switch-case}:\pause{}
\begin{plainjava}
!*\onslide<3->*!switch(:lan:Ausdruck:ran:){
!*\onslide<4->*!    case :lan:Fall |plain|1|plain|:ran:: // Code für Fall 1
!*\onslide<5->*!    case :lan:Fall |plain|2|plain|:ran::
!*\onslide<6->*!        // Code für Fall 1 & 2
!*\onslide<6->*!        break; // Verlässt Anweisung
!*\onslide<7->*!    case :lan:Fall |plain|3|plain|:ran::
!*\onslide<8->*!        // Code für Fall 3
!*\onslide<8->*!        break;
!*\onslide<9->*!    default: // Code, wenn keiner der Fälle greift.
!*\onslide<3->*!}
\end{plainjava}
    \item<10-> Dies funktioniert für: \onslide<11->{Zahlen (also auch \bjava{char}, das konvertiert werden kann), \onslide<12->{\bjava{enum}-Konstanten \onslide<13->{und (seit Java Version-7) auch \bjava{String}.}}}
    \end{itemize}
\end{frame}

\subsection{Schleifen}

\begin{frame}[fragile]{while}
    \begin{itemize}[<+(1)->]
        \item Schleifen erlauben es in Java bestimmte Programmanweisungen mehrfach auszuführen:\pause{}
        \begin{plainjava}
while (:lan:Bedingung:ran:) {
    :lan:Anweisung(en):ran:
}
        \end{plainjava}
        \pause{} die Schleife wird so lange ausgeführt, wie die \bjava{Bedingung} \emph{wahr} ist.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{while und do-while}
    \begin{itemize}[<+(1)->]
        \item Im Gegensatz zur \bjava{while}-Schleife gibt es die \bjava{do-while}-Schleife,\pause{} die die Prüfung am Ende des Durchlaufs durchführt.\pause{} Sie wird also auch mindestens einmal durchgeführt,\pause{} auch wenn die Bedingung von Anfang an \emph{falsch} ist:
        \begin{plainjava}
do {
    :lan:Anweisung(en):ran:
} while (:lan:Bedingung:ran:); // <-
        \end{plainjava}
        \item Wichtig und in der Regel vergessen wird das Semikolon am Ende der \bjava{do-while}-Anweisung.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Zählschleifen mit for}
    \begin{itemize}[<+(1)->]
        \widei
        \item Die \bjava{for}-Schleife in Java besteht aus drei optionalen Komponenten,\pause{} die auch alle weggelassen werden können.
        \begin{plainjava}
for(:lan:Start:ran:; :lan:Schleifenbedingung:ran:; :lan:Nach:ran:) {
    :lan:Anweisung(en):ran:
}
        \end{plainjava}
        \item Betrachten wir ein Beispiel:\pause{}
\begin{plainjava}
for(int i = 0, k = 1; i < 20; i++, k *= 2)
    System.out.println(i + ": " + k);
\end{plainjava}
    \pause{}diese Schleife liefert im \T{i}-ten Durchlauf \(k = 2^i\),\pause{} bis zu \(i = 19\).
        \item Hinweis: \bjava{for(;;) \{ /* ... */:ws:\}} ist eine Endlosschleife.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{break und continue}
    \begin{itemize}[<+(1)->]
        \widei
        \item Das Schlüsselwort \bjava{break} bricht die \say{innerste} Schleife ab.
        \item Mit \bjava{continue} wird nur der aktuelle Durchlauf abgebrochen und,\pause{} zum Beispiel in einer \bjava{for}-Schleife,\pause{} das Inkrement durchgeführt:\pause{}
\begin{plainjava}
for(int i = 0, k = 1; i < 20; i++, k *= 2) {
    if(i % 2 == 0) continue;
    System.out.println(i + ": " + k);
}
\end{plainjava}
        \pause{}alle geraden \T{i}-Werte werden übersprungen, die Ausgabe erfolgt nicht.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Iterieren mit foreach}
    \begin{itemize}[<+(1)->]
        \widei
        \item Mit Java Version 5 gibt es eine weitere Variante der \bjava{for}-Schleife:\pause{}
\begin{plainjava}
for(:lan:Variable-Deklaration:ran: : :lan:Iterierbare Variable:ran:) {
    // Etwas mit der Variable machen.
}
\end{plainjava}
        \pause{}\textit{Hinweis: Ohne Wissen über Interfaces ist es schwer zu \say{erfassen}, welche Datentypen erlaubt sind.\pause{} So: Arrays, Enumerationen (mittels \bjava{.values()}).}
        \item Ein Beispiel:\pause{}
\begin{plainjava}
int[] dinge = new int[] {42, 21, 12, -4};
for(int ding : dinge){
    System.out.println(ding);
}
\end{plainjava}
    \end{itemize}
\end{frame}

\subsection{Arrays}
\begin{frame}[fragile]{Arrays, Grundlagen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Arrays sind eine komplexe Datenstruktur,\pause{} die aus mehreren Elementen des gleichen Typos aufgebaut ist.
        \item Der Index eines Arrays beginnt bei \(0\).
        \item Die Länge eines Arrays ist \emph{fest}\pause{} und kann auf mehrere Arten definiert werden:\pause{}
\begin{plainjava}
double[] a = new double[42]; // 42 Elemente, alle: 0.0d
int[] b = {2, 4, 6, 8, 10}; // 5 Elemente
char[] c = new char[] {'a', 'z', '9'}; // 3 Elemente
\end{plainjava}
        \item Die Länge erhalten wir durch \bjava{:lan:array:ran:.length}.\pause{} Dies ist hier \emph{keine} Methode (im Gegensatz zu \bjava{:lan:string:ran:.length()})!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Arrays, Technischer Hintergrund}
    \begin{itemize}[<+(1)->]
        \widei
        \item Arrays werden in Java als ein Block gespeichert.\pause{} Das bedeutet, ein Array aus \(12\) \bjava{int}-Elementen nimmt einen Speicherblock von \(12 \cdot 32\,\text{bit}\) ein.
        \item Greift man auf einen nicht erlaubten Index zu,\pause{} so wird eine \bjava{ArrayIndexOutOfBoundsException} geworfen.
        \item Da Arrays eine komplexe Datenstruktur sind, wird bei der Erstellung in der Variable selbst nur die Speicheradressen abgelegt.\pause{} In:\pause{}
\begin{plainjava}
int[] a = {2, 4, 6, 8, 10}, b = a;
\end{plainjava}
        \pause{}verweisen beide Variablen auf den selben Datensatz:\pause{}
\begin{plainjava}
a[4] = 42; b[2] = 7;
for(int i = 0; i < a.length; i++)
    System.out.print(a[i] + " "); // :yields: 2 4 7 8 42
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Über Arrays iterieren}
    \begin{itemize}[<+(1)->]
        \widei
        \item Wir können,\pause{} wie eben gezeigt,\pause{} mit einer for-Schleife über ein Array iterieren:\pause{}
\begin{plainjava}
for(int i = 0; i < a.length; i++) {
    System.out.print(a[i] + " "); // :yields: 2 4 7 8 42
}
\end{plainjava}
        \item Oder mit \say{\bjava{for}-each}:\pause{}
\begin{plainjava}
for(int i : a) {
    System.out.print(i + " "); // :yields: 2 4 7 8 42
}
\end{plainjava}
    \end{itemize}
\end{frame}

\subsection{Mehrdimensionale Konzepte}%Array und Schleifenkonzepte}

\begin{frame}[fragile]{Mehrdimensionale Arrays}
    \begin{itemize}[<+(1)->]
        \widei
        \item Wir sind in der Lage Mehrdimensionale Arrays zu erstellen:\pause{}
\begin{plainjava}
double[][][] a = new double[2][4][6];
int[][] b = {{1,2}, {2,3}, {1,2,4,5}};
\end{plainjava}
        \item Wir erstellen also ein Array von Arrays von Arrays von \ldots
        \item Der Zugriff auf ein spezifisches Element erfolgt über die Angaben mehrerer Indizes:
\begin{plainjava}
int x = b[2][3]; // x :yields: 5
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Verschachtelte for-Schleifen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Über ein solches Array können wir auch iterieren:\pause{}
\begin{plainjava}
!*\onslide<3->*!public static void printMatrix(int[][] m){
!*\onslide<4->*!    for(int row = 0; row < m.length; row++) {
!*\onslide<5->*!        for(int col = 0; col < m[row].length; col++) {
!*\onslide<6->*!            System.out.print(m[row][col] + " ");
!*\onslide<5->*!        }
!*\onslide<7->*!        System.out.println();
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \end{itemize}
    \Task{Zählschleife in Iterationsschleife umwandeln}
    \begin{exercise}<8->[Iteration mit for-each \Time{4}]
        Schreibe diese Methode so um, dass sie den \bjava{for}-each Mechanismus verwendet.
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Verschachtelte for-Schleifen -- Lösung}
    \begin{solve}<2->[Iteration mit for-each]
\begin{plainjava}
!*\onslide<3->*!public static void printMatrix(int[][] m){
!*\onslide<4->*!    for(int[] row : m) {
!*\onslide<5->*!        for(int col : row) {
!*\onslide<6->*!            System.out.print(col + " ");
!*\onslide<5->*!        }
!*\onslide<7->*!        System.out.println();
!*\onslide<4->*!    }
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}

\subsection{Übungsaufgaben}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Suche Kompilier- und Laufzeitfehler, III}
    \begin{exercise}<2->[Fehler finden, III \Time{4}]
        \pause{}Finde und korrigiere alle Kompilier- und Laufzeitfehler:\pause{}
        \begin{plainvoid}
int[][][] x = {{}, {{1,2},{2},{5}}, {{3}}};
foreach (int[][] 'ex' : x) {
    int[] eex = ex[0];
    for(int i = 0; i < ex.length; i++)
        System.out.print(eex[i] + " ");
}
        \end{plainvoid}
        \pause{}Wie lautet die Ausgabe des korrigierten Codes?
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Fehler finden, III]
        \pause{}\begin{plainjava}
for (int[][] ex : x) {
    if(ex.length == 0) continue;
    int[] eex = ex[0];
    for(int i = 0; i < eex.length; i++)
        System.out.print(eex[i] + " ");
}
        \end{plainjava}
    \begin{enumerate}[<+(1)->]
        \item \bjava{foreach} ist kein gültiger Schlüsselbegriff, weiter darf ein Variablen\-be\-zei\-chner keine Anführungszeichen enthalten.
        \item Die folgende Zuweisung scheitert, wenn \bjava{ex} kein nulltes Element besitzt.
    \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<1->[Fehler finden, III\hfill(Fortsetzung)]
        \begin{plainjava}
for (int[][] ex : x) {
    if(ex.length == 0) continue;
    int[] eex = ex[0];
    for(int i = 0; i < eex.length; i++)
        System.out.print(eex[i] + " ");
}
        \end{plainjava}
    \begin{enumerate}[<+(1)->]
        \item[3.] Die innere \bjava{for}-Schleife prüft weiterhin auf die Länge eines anderen Arrays als das es zugreift.
    \end{enumerate}
    \pause{}Die Ausgabe lautet:\pause{} \bjava{\"1 2 3 \"} (Anführungszeichen nur zur Übersicht).
    \end{solve}
\end{frame}

% int[][][][][] x = new inr[8][4][][][]

\begin{frame}[c]{Übungsaufgabe}
    \Task{Begriffserklärungen}
    \begin{exercise}<2->[Begriffserklärungen \Time{4}]
        \pause{}Erkläre jeweils in ein bis zwei Sätzen: \begin{enumerate}[<+(1)->]
            \item[i)] Was ist ein Deadlock (und wann tritt er auf)?
            \item[ii)] Was veranschaulicht ein Histogramm?
            \item[iii)] Was versteht man unter einem deterministischen Algorithmus?
        \end{enumerate}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Begriffserklärungen]
        \begin{enumerate}[<+(1)->]
            \item[i)] Ein Deadlock (Verklemmung) ist ein gemeinsamer Zustand parallel laufender Programme,\pause{} bei der diese sich gegenseitig blockieren.\pause{} Beispiel:\pause{} Prozess \(A\) benötigt die Ressource \(R_1\) um \(R_2\) fertigzustellen,\pause{} Prozess \(B\) hingegen hält \(R_1\) und benötigt \(R_2\) um sie fertigzustellen.
            \item[ii)] Ein Histogramm bezeichnet die grafische Veranschaulichung von Häufigkeiten.
            \item[iii)] Ein Algorithmus ist deterministisch, sofern sein nächster Schritt zu jeder Zeit eindeutig ist.
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Programmieren eines Häufigkeitszähler}
    \begin{exercise}<2->[Programmieren eines Häufigkeitszähler \Time{5}]
        \pause{}Schreibe eine Routine \bjava{countChars(String)}, welche ein Array \bjava{int[26]} zurückliefert,\pause{} das von \(0 \;\widehat{=}\; \T{a}\)\pause{} bis \(25 \;\widehat{=}\; z\) die Häufigkeit der Buchstaben angibt.\pause{} Groß-, Kleinschreibung sowie andere Zeichen sollen ignoriert werden.
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Programmieren eines Häufigkeitszähler -- Lösung]
        \begin{plainjava}
!*\onslide<3->*!public static int[] countChars(String text){
!*\onslide<4->*!    int[] counts = new int[26];
!*\onslide<5->*!    for(char c : text.toLowerCase().toCharArray()){
!*\onslide<6->*!        if(c >= 'a' && c <= 'z')
!*\onslide<7->*!            counts[c - 'a'] += 1;
!*\onslide<5->*!    }
!*\onslide<8->*!    return counts;
!*\onslide<3->*!}
        \end{plainjava}
    \end{solve}
\end{frame}


\begin{frame}[c]{Übungsaufgabe}
    \Task{Programmieren: Turtlewalk}
    \begin{exercise}<2->[Programmieren: Turtlewalk \Time{6}]
        \pause{}Das Array \bjava{static boolean[][] field} repräsentiere ein rechteckiges Gitter (welches mindestens \(1\) Feld umfasst).\pause{} Für jedes Feld \bjava{field[i][j]} gibt der Wert an, ob es passierbar (\bjava{true}) oder blockiert (\bjava{false}) ist.\pause{} Die Variablen \bjava{static int turtle_x, turtle_y;}\pause{} repräsentieren eine Schildkröte an Position \bjava{field[turtle_y][turtle_x]}.
        \pause{}Schreibe eine Funktion \bjava{moveTurtle(int,int)} die versucht die Schildkröte relativ um \(x\) und \(y\) zu bewegen.\pause{} Eine Bewegung gelingt nur, wenn das Zielfeld frei ist.\pause{} In diesem Fall gilt es \bjava{turtle_x} und \bjava{turtle_y} zu modifizieren und \bjava{true} zurück zu liefern.\pause{} Andernfalls sollen die Koordinaten unverändert bleiben, sowie ein \bjava{false} zurückgegeben werden.
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Programmieren: Turtlewalk]
        \begin{plainjava}
!*\onslide<3->*!public static boolean moveTurtle(int tx, int ty){
!*\onslide<4->*!    int nx = turtle_x + tx, ny = turtle_y + ty;
!*\onslide<5->*!    if(nx >= field[0].length || nx < 0 // x-Richtung
!*\onslide<6->*!       || ny >= field.length || ny < 0 // y-Richtung
!*\onslide<7->*!       || !field[ny][nx]) // blockiert
!*\onslide<8->*!            return false;
!*\onslide<9->*!    turtle_x = nx;
!*\onslide<9->*!    turtle_y = ny;
!*\onslide<10->*!    return true;
!*\onslide<3->*!}
        \end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Programmieren: Turtlewalk, II}
    \begin{exercise}<2->[Programmieren: Turtlewalk, II \Time{6}]
        \pause{}Im Kontext der vorherigen Aufgabe existiere die Methode \bjava{moveTurtle(int tx, int ty)}.\pause{} Weiter seien nun diese Konstanten gegeben:\pause{}
\begin{plainjava}
static final int UP = 0, LEFT = 1, DOWN = 2, RIGHT = 3;
\end{plainjava}
    \pause{}Schreibe eine Methode \bjava{moveTurtle(int)} die die relative Bewegung um \emph{so viele Felder wie möglich} vornimmt.\pause{} Die Methode soll die Anzahl der gegangenen zurückgeben.\pause{} Hinweis: Oben definieren wir als eine Erhöhung der \(y\)-Koordinate.
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Programmieren: Turtlewalk, II]
        \begin{plainjava}
public static int moveTurtle(int dir){
    int tx = 0, ty = 0;
    switch (dir) {
        case UP:    ty=1; break; case DOWN: ty=-1; break;
        case RIGHT: tx=1; break; case LEFT: tx=-1; break;
        default: return -1; // Unterscheiden von kein Feld
    }
    int total = 0;
    while(moveTurtle(tx,ty)) { total++; }
    return total;
}
        \end{plainjava}
    \end{solve}
\end{frame}

% Aufgabe: for in while Schleife umschreiben


\section{OO-Konzepte}

\subsection{Das Paradigma}
\begin{frame}{Paradigma: Objektorientierung}
    \begin{itemize}[<+(1)->]
        \item Klassen erlauben es uns Objekte der realen Welt abzubilden.
        \item Eine Klasse wie zum Beispiel \solGet{keywordC}{Person} besteht aus zwei Komponenten: \begin{description}[Funktionen]
            \item[Daten] diese, wie der Name, das Alter oder die Größe der Person,\pause{} werden als Variablen an die Klasse gebunden. Sie sind die \imp{Attribute} der Klasse und definieren den Zustand.
            \item[Funktionen] diese definieren, was eine \solGet{keywordC}{Person} kann.\pause{} Also \bjava{gehen()}, \bjava{tanzen()}, \bjava{reden()}, \ldots.\pause{} Dies sind die \imp{Methoden} der Klasse, sie definieren das Verhalten.
        \end{description}
        \item Information:\pause{} Wir nennen eine Funktion (in Java) \emph{Methode}, wenn sie an eine Objekt gebunden ist.
        \item Klassen bieten uns die Möglichkeit komplexe Probleme zu abstrahieren und Funktionalität zu kapseln.
    \end{itemize}
\end{frame}

\begin{frame}{Paradigma: Objektorientierung}
    \begin{definition}<2->[Objekt]
        Ein Objekt bezeichnet eine spezifische Ausprägung (eine sogenannte \emph{Instanz}) einer Klasse. \begin{description}[Objekt-Verhalten]
            \item[Objektzustand] wird durch die ihm zugehörigen Attribute definiert.
            \item[Objektverhalten] bezeichnet die Reaktion des Objekts auf das Aufrufen von Methoden.
            \item[Objektidentität] ermöglicht eindeutige Identifikation (in Java: Speicheradresse).
        \end{description}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Hinweis:\pause{} Legt man die Objektorientierung streng aus,\pause{} so darf ein Objekt keinen direkten Zugriff auf seinen Zustand gestatten.\pause{} (\(\Rightarrow\) Getter \& Setter).
    \end{itemize}
\end{frame}

\begin{frame}{Programmkontext}
    \begin{itemize}[<+(1)->]
        \item Das Verhalten von Klassen wird oft auch als ein Botschaft- beziehungsweise Nachrichtsystem betrachtet.
        \item Hier bezeichnet das senden einer Botschaft\pause{} mit Inhalt das Aufrufen der Methode mit entsprechendem Inhalt.
        \item Aus Sicht der Objektorientierung ist ein \emph{Programm}\pause{} nicht mehr als das (wechselseitige) Aufrufen eben dieser Methoden.
    \end{itemize}
\end{frame}


\begin{frame}[c]{Eine Aufgabe zwischendurch}
    \Task{Vorteile der OOP}
    \begin{exercise}<2->[Vorteile der OOP \Time{2}]
        Nenne drei Vorteile der Objektorientierten Programmierung,\pause{} neben der Möglichkeit die Realität zu abstrahieren.
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Vorteile der OOP]
        Hier angegeben werden exemplarisch vier, jeweils mit kurzer Erklärung:\begin{description}
            \item[Modularität] Eine Klasse kann unabhängig von anderen geschrieben und gehalten werden.
            \item[Informationsverdeckung] Die Implementierungsdetails des Objekts werden verborgen.
            \item[Wiederverwendbarkeit] Eine Klasse kann so geschrieben werden, dass sie auch in anderen Projekten wiederverwendet werden kann\pause{} (ein Datentyp wie ein Ringbuffer zum Beispiel).
            \item[Komposition/Polymorphie] Eine Klasse definiert eine Schnittstelle, die sie von der Implementation abstrahiert,\pause{} so dass diese sich problemlos austauschen lässt.
        \end{description}
    \end{solve}
\end{frame}

\subsection{Klassen}
\begin{frame}[c]{Vom Klassenkonzept zum Javacode}
    \begin{minipage}{0.65\linewidth}
        \begin{itemize}[<+(1)->]
            \item Es gelte eine Klasse \solGet{keywordC}{Punkt2D} zu kreieren.
            \item Ein solcher Punkt \((x,y)\) benötigt zwei Attribute: \begin{description}[y-Koordinate]
                \item[x-Koordinate] die x-Komponente (Fließ\-kom\-ma\-zahl).
                \item[y-Koordinate] die y-Komponente (Fließ\-kom\-ma\-zahl).
            \end{description}
            \item Wir möchten ein paar Dinge mit dem Punkt anstellen können: \begin{itemize}
                \item Den Punkt (relativ) verschieben.
                \item Den Abstand zu einem anderen Punkt berechnen.
                \item Den Punkt auf einen anderen Punkt setzen.
            \end{itemize}
        \end{itemize}
    \end{minipage}~\quad~\begin{minipage}{0.35\linewidth}
        \centering\resizebox{0.95\linewidth}{!}{\begin{tikzpicture}
                \umlclass[x=0,y=0]{Point2D}{
                    \bjava{private} x : \bjava{double} \\
                    \bjava{private} y : \bjava{double} \\
                }{
                    \bjava{public} distance(\solGet{keywordC}{Point2D}) : \bjava{double} \\
                    \bjava{public} shift(\bjava{double},\bjava{double}) : \bjava{void} \\
                    \bjava{public} copy(\solGet{keywordC}{Point2D}) : \bjava{void}
                }
            \end{tikzpicture}}
    \end{minipage}
\end{frame}

\begin{frame}{Implementation in Java}
    \begin{itemize}[<+(1)->]
        \item Die Implementation einer Klasse erfolgt mit der Schlüsselwort \bjava{class}.
        \item Diesem folgt der Name der Klasse,\pause{} der dem Dateinamen entsprechen \emph{muss}.\pause{} Es wird auf groß-Kleinschreibung geachtet.
        \item Innerhalb einer Klasse referenziert \bjava{this} auf das jeweilige Objekt.
        \item Bei der Implementation müssen wir den Konstruktor beachten:
    \end{itemize}
    \begin{definition}<8->[Konstruktor]
        \pause{}Ein Konstruktor verhält sich nur bedingt wie eine Methode\pause{} (er ist \emph{keine},\pause{} er gehört zum Klassenkonstrukt und kann nur mit \bjava{new} aufgerufen werden.\pause{} Allerdings kann man ihn überladen) und hat keinen Rückgabetyp.\medskip\newline
        Ein Konstruktor trägt stets den selben Namen wie die Klasse selbst und kann den Aufruf an andere Überladungen des Konstrukturs mittels \bjava{this} durchreichen.
    \end{definition}
\end{frame}

\lstset{add to literate={Point2D}{{\solGet{keywordC}{Point2D}}}7}

\begin{frame}[fragile]{Implementation: Konstruktor}
\begin{plainjava}
!*\onslide<2->*!public class Point2D {
!*\onslide<2->*!
!*\onslide<3->*!    private double x, y;
!*\onslide<2->*!
!*\onslide<4->*!    // Leerer Konstruktor
!*\onslide<4->*!    public Point2D() { this(0.0,0.0); }
!*\onslide<2->*!
!*\onslide<5->*!    // Initialisiere mit Punkt

!*\onslide<5->*!    public Point2D(double _x, double _y) {
!*\onslide<6->*!        this.x = _x; // geht
!*\onslide<6->*!        this.y = _y; // genauso
!*\onslide<5->*!    }
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\begin{frame}[fragile]{Implementation: Methoden}
\begin{itemize}[<+(1)->]
    \item Die Implementation der Methoden läuft wie bekannt!
    \item Exemplarisch das relative Verschieben:\pause{}
\begin{plainjava}
!*\onslide<4->*!public class Point2D {
!*\onslide<5->*!    //...
!*\onslide<4->*!
!*\onslide<6->*!    public void shift(double sx, double sy) {
!*\onslide<7->*!        this.x += sx;
!*\onslide<7->*!        this.y += sy;
!*\onslide<6->*!    }
!*\onslide<4->*!}
\end{plainjava}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Besondere Methoden}
\begin{itemize}[<+(1)->]
    \item Eine Klasse in Java übernimmt Methoden der \bjava{Object}-Klasse.
    \item Auf diese Weise gibt es einige wichtige Methoden,\pause{} die im Kontext von Java eine besondere Bedeutung haben\pause{} (aber dafür natürlich, wie \bjava{equals} überschrieben werden müssen).
    \item Hier sind die wichtigsten: \begin{description}[toString]
        \item[equals] die Methode \bjava{equals(Object)} prüft das Objekt mit dem Übergebenen auf \say{Gleichheit}.\pause{} So können die hierfür relevanten Attribute genau festgelegt werden.
        \item[toString] wird aufgerufen, um eine Repräsentation als Zeichenkette zu erhalten.
    \end{description}
\end{itemize}
\end{frame}


\begin{frame}[c]{Eine Aufgabe zwischendurch}
    \Task{Eine .equals()-Methode}
    % TODO: attribute des Punktes wiederholen
    \begin{exercise}<2->[Eine .equals()-Methode \Time{6}]
        Schreibe eine \bjava{equals(Object)}-Methode für \bjava{Point2D}.\pause{} Hinweis: Denke an \bjava{instanceof} beziehungsweise \bjava{getClass()}.
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Eine .equals()-Methode]
\begin{plainjava}
!*\onslide<3->*!public boolean equals(Object obj) {
!*\onslide<4->*!    if (this == obj) return true; // Sind identisch
!*\onslide<5->*!    if (obj == null) return false; // Wir sind nicht null
!*\onslide<6->*!    // ist es von der selben Klasse?
!*\onslide<7->*!    // Oder: 'if (obj instanceof Point:c:2D)'
!*\onslide<7->*!    if (this.getClass() != obj.getClass())
!*\onslide<7->*!        return false;
!*\onslide<8->*!    Point2D p1 = (Point2D) obj; // Es ist ein Point2D
!*\onslide<9->*!    return this.x == p1.x && this.y == p1.y;
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[fragile]{Statische Methoden/Attribute}
\begin{itemize}[<+(1)->]
    \item<1-> Eine ausführliche Erklärung liegt hier: \attachPdfTextDesc{data/static.pdf}{static.pdf}{PDF-Dokument welches den Umgang mit statischen Funktionen und Methoden (in Java) genauer erklärt.}.
    \item Alle Methoden die wir so definieren sind an ein Objekt gebunden.
    \item Manche Methoden sind aber nur logisch an eine Klasse gebunden\pause{} und nicht von den Ausprägungen eines Objekts.
    \item So zum Beispiel die Mathe-Funktionen wie \bjava{Math.random()}, \bjava{Math.floor(double)}.
    \item Diese Methoden deklarieren wir mit \bjava{static},\pause{} sie sind nun auch ohne ein Objekt aufrufbar.\pause{} So kann man zum Beispiel auch eine \bjava{distance(Point2D, Point2D)} für zwei Punkte machen.
    \item Auch Variablen die für alle Objekte einer Klasse identisch sind,\pause{} können wir mit \bjava{static} deklarieren.\pause{} So zum Beispiel die Gesamtzahl der erstellten \solGet{keywordC}{Car}-Objekte.
\end{itemize}
\end{frame}

\begin{frame}{Der Lebenszyklus eines Objekts}
    \begin{itemize}[<+(1)->]
        \item Mit dem Erstellen eines Objekts,\pause{} haben wir eine Variable, die auf es zeigt.
        \item Durch weitere Zuweisungen\pause{} oder Methodenaufrufe können wir weitere Zeiger darauf erstellen.
        \item Überschreiben wir diese Variablen, oder verlassen ihren Gültigkeitsbereich,\pause{} verlieren wir einen Zeiger.
        \item Wenn keine Variable mehr auf das Objekt zeigt,\pause{} gibt es (zumindest an sich) keine Möglichkeit mehr auf das Objekt zuzugreifen.
        \item In diesem Fall wird es (irgendwann) vom Garbage-Collector aufgeräumt
    \end{itemize}
    \Task{Garbage Collector}
    \begin{exercise}<8->[Garbage Collector]
        \pause{}Kann der Java Garbage Collector direkt beeinflusst werden? Was sind die Möglichkeiten?
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Garbage Collector]
        Wir können den Collector nicht direkt beeinflussen!\pause{} Allerdings können wir nicht mehr benötigte Objekte auf \bjava{null} setzen\pause{} und mittels \bjava{System.gc()} den Prozess anstoßen.\pause{}\medskip\newline
        Information: Der GC räumt nicht nur Speicher auf sondern füllt auch Speicherlücken.\pause{} Es gibt verschiedene Varianten für einen GC (Referencecount,\pause{} Mark \& Sweep,\pause{} Stop \& Copy).\pause{} Wird ein Objekt aufgeräumt,\pause{} ruft Java die Methode \bjava{finalize()} auf.
    \end{solve}
\end{frame}

\subsection{Enumerationen}
\begin{frame}[fragile]{Enumerationen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Mit Java-5 gibt es die Möglichkeit durch \imp{Enumerationen} eigene Datentypen zu definieren.
        \item Sie können überall dort definiert werden,\pause{} wo man auch eine Klasse definieren kann.\pause{} \textit{Technisch betrachtet sind Enumerationen spezielle Java-Klassen.}
        \item Die einfachste Möglichkeit eine Enumeration zu definieren,\pause{} funktioniert über das \bjava{enum}-Schlüsselwort:\pause{}
\begin{plainjava}
enum :lan:Name der Enumeration:ran: {
    :lan:Komma separierte Liste an Werten:ran:
}
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Enumerationen definieren}
    \begin{itemize}[<+(1)->]
        \widei
        \item Der Konvention nach, werden alle Werte einer Enumeration in Großbuchstaben\pause{} und mit Unterstrichen geschrieben.
        \item Betrachten wir ein Beispiel:\pause{}
\begin{plainjava}
enum Richtung {
    HOCH, RUNTER, LINKS, RECHTS
}
\end{plainjava}
        \item Wir können diese Typen als Parametertypen in Methoden verwenden,\pause{} und über die Punkt-Syntax auf Elemente zugreifen.
        \item Hinweis:\pause{} Anders als in Sprachen wie C++,\pause{} wird den Konstanten kein (Integer)-Wert zugeordnet.\pause{} (dafür gibt es \bjava{ordinal()})
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Enumerationen verwenden}
    \begin{itemize}[<+(1)->]
        \widei
        \item Betrachten wir ein Beispiel mit \bjava{Richtung} und \bjava{switch-case}:\pause{}
\begin{plainjava}
!*\onslide<3->*!public static String wohinGehtEs(Richtung ziel){
!*\onslide<4->*!    switch(ziel) {
!*\onslide<5->*!        case HOCH:   return "Es geht nach oben!";
!*\onslide<6->*!        case RUNTER: return "Es geht nach unten!";
!*\onslide<7->*!        case LINKS:  return "Es geht nach links!";
!*\onslide<8->*!        case RECHTS: return "Es geht nach rechts!";
!*\onslide<4->*!    }
!*\onslide<9->*!    return "Fehler! Richtung unbekannt";
!*\onslide<3->*!}
\end{plainjava}
    \item<10-> Beispielhafte Verwendung:\onslide<11->
\begin{plainjava}
System.out.println(wohinGehtEs(Richtung.RECHTS));
\end{plainjava}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Was Enumerationen liefern}
    \begin{itemize}[<+(1)->]
        \widei
        \item Mittels \bjava{:lan:Enum Name:ran:.values()} erhalten wir ein Array aller Werte.
        \item \bjava{:lan:Enum Name:ran:.valueOf(String)} liefert die Enumkonstante mit übergebenem Namen,\pause{} sofern vorhanden.
        \item Enumerationen besitzen ein wie zu erwarten funktionierendes \bjava{equals(Object)}.
        \item Analog funktioniert \bjava{toString()} wie zu erwarten.
        \item Da es sich auch um Klassen handelt, können wir den Konstanten Datentypen zuordnen!
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Alternative Richtungs-Enum}
\begin{plainjava}
!*\onslide<2->*!enum Richtung {
!*\onslide<6->*!    HOCH("Es geht nach oben!"),
!*\onslide<7->*!    RUNTER("Es geht nach unten!"),
!*\onslide<8->*!    LINKS("Es geht nach links!"),
!*\onslide<9->*!    RECHTS("Es geht nach rechts!");
!*\onslide<2->*!
!*\onslide<3->*!    private String text;
!*\onslide<4->*!    public String getText() { return this.text; }
!*\onslide<2->*!
!*\onslide<5->*!    Richtung(String text) {
!*\onslide<5->*!        this.text = text;
!*\onslide<5->*!    }
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\begin{frame}[fragile]{Abschluss zu Enumerationen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Die Methode \bjava{wohinGehtEs} lässt sich nun kompakter fassen:\pause{}
\begin{plainjava}
public static String wohinGehtEs(Richtung ziel){
    return ziel.getText();
}
\end{plainjava}
        \item Das Kompilieren einer Datei mit Enumeration erzeugt eine weitere \T{.class}-Datei,\pause{} deren Namen dem Schema \bvoid{:lan:Klassennamen:ran:\$:lan:Enumname:ran:.class} folgt.
    \end{itemize}
\end{frame}


% Füge Gültigkeitsbereiche hinzu
\subsection{call-by-value/reference}
\begin{frame}[fragile]{Klassen als Parameter: call-by-reference}
    \begin{itemize}[<+(1)->]
        \widei
        \item Wenn wir komplexe Datentypen als Parameter übergeben oder zuweisen,\pause{} wird \emph{keine} Kopie des Objekts erstellt,\pause{} sondern eine Referenz auf das Objekt übergeben.
        \item Dieser (Parameter-)Übergabemechanismus wird \emph{call-by-reference} genannt.
        \item Für eine genauere Betrachtung hilft der Foliensatz \(8\) zu Übungsblatt \(7\).
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Eine leichte Aufgabe als Einstieg}
    \Task{Übung zu call-by-reference}
    \begin{exercise}<2->[Was liefert dieser Code? \Time{1}]
        \begin{plainjava}
!*\onslide<3->*!public static void multBy2(int[] x){
!*\onslide<3->*!    x[0] = x[0]*2;
!*\onslide<3->*!}
!*\onslide<3->*!
!*\onslide<4->*!public static void main(String[] args) {
!*\onslide<5->*!    int[] arr = { 21 };
!*\onslide<5->*!    System.out.println(arr[0]);
!*\onslide<5->*!    multBy2(arr);
!*\onslide<5->*!    System.out.println(arr[0]);
!*\onslide<4->*!}
        \end{plainjava}
    \end{exercise}\onslide<1->
\end{frame}


\long\def\PresentHS<#1>#2#3{%
\onslide<#1>{\resizebox{4.865cm}{!}{\begin{tikzpicture}
\begin{heap-n-stack}{#2}
#3
\end{heap-n-stack}
\end{tikzpicture}}}%
}
\begin{frame}[fragile,c]{Eine leichte Aufgabe als Einstieg -- Lösung}
    \begin{solve}<2->[Was liefert dieser Code?]
        \pause{}Der Code liefert \(21\) und \(42\). Ersterer Wert, da wir das Array ja so zuweisen,\pause{} den zweiten, weil durch die Übergabe des Arrays mittels \emph{call-by-reference} auch das Ursprungsarray verändert wird.
        \begin{center}
\PresentHS<4->{1}{%
\istack{main}
\stack{arr:}
\renderstack

\iheap{Globales}
\heap{\T{\{ 21 \}}}
\renderheap
\draw[lhns] (stack-1) -- (stack-1-|heap-1-box.west);
}\qquad\PresentHS<5->{2}{%
\istack{main}
\stack{arr:}
\istack{multBy2}
\stack{x:\phantom{rr}}
\renderstack

\iheap{Globales}
\heap{\T{\{ 21 \}}}
\renderheap
\draw[lhns] (stack-1) -- (stack-1-|heap-1-box.west) coordinate (r1);
\draw[lhns] (stack-3) -- ++(0.75,0) -- ([xshift=-0.75cm]r1) -- (r1);
}
        \end{center}
    \end{solve}
\end{frame}


\begin{frame}[fragile,c]{Eine leichte Aufgabe als Einstieg -- Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<1->[Was liefert dieser Code?\hfill{}(Fortsetzung)]
        \pause{}\begin{center}
\PresentHS<2->{3}{%
\istack{main}
\stack{arr:}
\istack{multBy2}
\stack{x:\phantom{rr}}
\renderstack

\iheap{Globales}
\heap{\T{\{ 42 \}}}
\renderheap
\draw[lhns] (stack-1) -- (stack-1-|heap-1-box.west) coordinate (r1);
\draw[lhns] (stack-3) -- ++(0.75,0) -- ([xshift=-0.75cm]r1) -- (r1);
}\qquad\PresentHS<3->{4}{%
\istack{main}
\stack{arr:}
\renderstack

\iheap{Globales}
\heap{\T{\{ 42 \}}}
\renderheap
\draw[lhns] (stack-1) -- (stack-1-|heap-1-box.west) coordinate (r1);
}
        \end{center}
        \onslide<4->{\textit{Hinweis: eine derartige Grafik wird nicht gefordert werden, sie kann aber durchaus beim Verständnis der Thematik hilfreich sein.}}
    \end{solve}
\end{frame}

\begin{frame}[fragile]{Der nette Bruder: call-by-value}
    \begin{itemize}[<+(1)->]
        \widei
        \item Bei Klassen und Arrays wird nun also nicht das Element selbst,\pause{} sondern nur die Referenz übergeben.
        \item Bei primitiven Datentypen hingegen wird der Wert \emph{kopiert},\pause{} wan übergibt also den eigentlichen Wert der Variable.
        \item Man sagt auch, dass Methoden mit \emph{call-by-value} \say{keine} (nach bisheriger Betrachtung) Seiteneffekte hervorrufen,\pause{} da sie die übergebenen Daten nicht modifizieren.
        \item Wenn man auch komplexe Datentypen kopieren möchte,\pause{} so erstellt man sie in der Regel neu (\bjava{clone()}) und greift auf die \emph{call-by-value}-Charakteristik der primitiven Datentypen zurück.
    \end{itemize}
\end{frame}

\subsection{Übungsaufgaben}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Suche syntaktischer Fehler, IV}
    \begin{exercise}<2->[Fehler finden, IV \Time{3}]
        \pause{}Finde und korrigiere alle (syntaktischen) Fehler:\pause{}
        \begin{plainvoid}
class Laenge {
    final double METER KILOMETER = 1_000;
    static final float meter2kilometer(final int meter){
        return meter/METER KILOMETER;
    }
    static int kilometer2meter(double kilometer){
        return kilometer * METER KILOMETER;
    }
}
        \end{plainvoid}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Fehler finden, IV]
        \pause{}\begin{plainjava}
class Laenge {
    static final double METER_KILOMETER = 1!*\solGet{numbers}{\_}*!000;
    static final float meter2kilometer(final int meter){
        return (float) (meter/METER_KILOMETER);
    }
    static int kilometer2meter(double kilometer){
        return (int) (kilometer * METER_KILOMETER);
    }
}
        \end{plainjava}
    \end{solve}
\end{frame}


\begin{frame}[c,fragile]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<1->[Fehler finden, IV\hfill{}(Fortsetzung)]
    \begin{enumerate}[<+(1)->]
        \item  Die Konstante \bjava{METER KILOMETER} darf kein Leerfeld enthalten und muss \bjava{static} sein.
        \item In \bjava{meter2kilometer} und \bjava{kilometer2meter} muss eine explizite Konvertierung erfolgen.
    \end{enumerate}
    \pause{}\textit{Hinweis: das \bjava{final} in den Parametern und der Unterstrich in \bjava{1000} sind keine Fehler!}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Eine Kreisklasse}
    \begin{exercise}<2->[Kreisklasse\Time{4}]
        \pause{}Schreibe eine Klasse \bjava{Circle} die einen Kreis repräsentiert. Ein Kreis besitzt eine \(x\) und eine \(y\) Koordinate im Fließkommabereich, sowie einen Radius.\pause{}
        Es soll möglich sein Umfang sowie Fläche des Kreises berechnen zu lassen.\pause{}
        Auf Datenkapselung muss hierbei keine Rücksicht genommen werden,\pause{} allerdings muss es möglich sein den Kreis unter der Angabe aller Attribute zu konstruieren.\pause{} (\(U = 2\cdot r\cdot\pi \), \(A = r^2\cdot\pi\))
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Kreisklasse]
        \pause{}\begin{plainjava}
!*\onslide<3->*!class Circle {
!*\onslide<4->*!    public double x, y, r;
!*\onslide<5->*!    public Circle(double _x, double _y, double _r) {
!*\onslide<5->*!        x = _x; y = _y; r = _r;
!*\onslide<5->*!    }
!*\onslide<6->*!    public double getCircumference(){
!*\onslide<6->*!        return 2 * r * Math.PI;
!*\onslide<6->*!    }
!*\onslide<3->*!
!*\onslide<7->*!    public double getArea() { return r * r * Math.PI; }
!*\onslide<3->*!}
        \end{plainjava}
    \end{solve}
\end{frame}


\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Ein Schienennetz}
    \begin{exercise}<2->[Schienennetz\Time{4}]
        \onslide<3->{Ein Feld in einem gitterartigen Schienennetz kann entweder \onslide<4->{frei (\(\widehat{=}\) keine Schiene), von einer Schiene besetzt, von einem Waggon oder einer Lokomotive belegt sein.\par{}}}
        \onslide<5->{Schreibe eine Enumeration die einen Feldzustand darstellt,\onslide<6->{ jede Konstante soll gleich mitspeichern ob das Feld von einer Lok befahrbar ist, \onslide<7->{wobei dies nur für \say{Schienenfelder} der Fall ist.}}}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Schienennetz]
        \begin{plainjava}
!*\onslide<3->*!enum Schiene {
!*\onslide<4->*!    FREI(false),
!*\onslide<5->*!    SCHIENE(true),
!*\onslide<6->*!    WAGGON(false),
!*\onslide<7->*!    LOKOMOTIVE(false);
!*\onslide<3->*!
!*\onslide<8->*!    boolean befahrbar;
!*\onslide<9->*!    Schiene(boolean befahrbar) {
!*\onslide<9->*!        this.befahrbar = befahrbar;
!*\onslide<9->*!    }
!*\onslide<3->*!}
        \end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Ein Kamera-Singleton erstellen.}
    \begin{exercise}<2->[Kamera\Time{5}]
        \onslide<3->{Schreibe eine \bjava{Camera} Klasse, \onslide<4->{mit drei Fließkommazahlen für die aktuelle Position (\(x,y,z\)) \onslide<5->{und zwei für den jeweiligen Drehwinkel \(r_x, r_z\). \onslide<6->{Von der Klasse soll es nicht möglich sein mehr als eine Instanz zu erzeugen. \onslide<7->{Weitere \say{Anfragen} sollen dasselbe Objekt zurückliefern.}}}}}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Kamera (Singleton)]
        \begin{plainjava}
!*\onslide<3->*!public class Camera {
!*\onslide<4->*!    double x, y, z, rx, rz;
!*\onslide<6->*!    private static Camera instance;
!*\onslide<5->*!    private Camera() {
!*\onslide<5->*!        x = y = z = rx = rz = 0.0;
!*\onslide<5->*!    }
!*\onslide<7->*!    public static Camera getInstance() {
!*\onslide<8->*!        if(instance == null) instance = new Camera();
!*\onslide<9->*!        return instance;
!*\onslide<7->*!    }!*\onslide<10->*! // ...
!*\onslide<3->*!}
        \end{plainjava}
    \end{solve}
\end{frame}

\section{Programmiertheorie}

\subsection{Rekursion}
\begin{frame}[fragile]{Rekursive und iterative Programmierung}
    \begin{definition}<2->[Rekursive Methode]
        \pause{}Eine Methode oder Funktion bezeichnen wir als \emph{rekursiv}, wenn sie sich:\pause{} \begin{description}[indirekt]
            \item[direkt] selbst aufruft, sich also selbst referenziert.\pause{}
            \item[indirekt] selbst aufruft, also eine andere Methode aufruft, die (über irgendwelche Umwege) wieder die Methode referenziert.
        \end{description}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \widei
        \item Eine rekursive Methode lässt sich in zwei Komponenten gliedern, der: \begin{description}[Abbruchbedingung]
            \item[Abbruchbedingung] Berechnet den Wert zum beenden der Rekursion.\pause{} Hier wird die Methode nicht weiter referenziert.
            \item[Rekursiver Zweig] Enthält die rekursiv auszuführende Prozedur.\pause{} In der Regel eine naive Implementation einer rekursiv definierten Funktion.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Arten von Rekursion}
    \begin{itemize}[<+(1)->]
        \widei
        \item Es gibt zwei Positionen, an denen ein rekursiver Aufruf erfolgen kann.\begin{description}
            \item[Head] Hier erfolgt der rekursive Aufruf zu Beginn der Rekursion (also vor der Datenverarbeitung).
            \item[Tail] Hier erfolgt der rekursive Aufruf zu Ende der Rekursion.\pause{} Ein solcher Abstieg lässt sich (und wird) in der Regel einfach in eine Iteration transformieren.
        \end{description}
    \end{itemize}
\begin{center}\scriptsize%
\begin{minipage}{0.45\linewidth}
\begin{plainjava}
!*\onslide<11->*!// :yields: 1 2 3 4 5 6 :ldots:
!*\onslide<6->*!public void headDecrement(int i){
!*\onslide<7->*!    // Abbruchbedingung
!*\onslide<7->*!    if(i == 0) return;
!*\onslide<8->*!    // Rekursion
!*\onslide<8->*!    else headDecrement(i-1);
!*\onslide<10->*!    // Verarbeitung
!*\onslide<10->*!    System.out.println(i);
!*\onslide<6->*!}
\end{plainjava}
\end{minipage}\qquad\begin{minipage}{0.45\linewidth}
\begin{plainjava}
!*\onslide<12->*!// :yields: 10 9 8 7 6 :ldots:
!*\onslide<6->*!public void tailDecrement(int i){
!*\onslide<7->*!    // Abbruchbedingung
!*\onslide<7->*!    if(i == 0) return;
!*\onslide<9->*!    // Verarbeitung
!*\onslide<9->*!    else System.out.println(i);
!*\onslide<10->*!    // Rekursion
!*\onslide<10->*!    tailDecrement(i-1);
!*\onslide<6->*!}
\end{plainjava}
\end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]{Baumartige Rekursion}
    \begin{itemize}[<+(1)->]
        \widei
        \item Eine Methode kann sich auch mehrfach (auch indirekt) selbst referenzieren.
        \item In diesem Fall entsteht kein \say{linearer} Abstieg,\pause{} sondern vielmehr eine Baum-/Kaskadenartige Verzweigung.
        \item Beliebte Beispiele: Fibonacci, Binomialkoeffizient.
    \end{itemize}
    \onslide<6->{
        \vfill\hbox{}
        \hfill\scalebox{0.75}{\begin{forest}
            [f(12)
                [f(11)
                    [f(10)
                        [\ldots]
                        [\ldots]
                    ]
                    [f(9)
                        [\ldots]
                        [\ldots]
                    ]
                ]
                [f(10)
                    [\ldots]
                    [\ldots]
                ]
            ]
        \end{forest}
    }}\vfill\hbox{}
\end{frame}


\begin{frame}[fragile]{Verschränkte und geschachtelte Rekursion}
    \begin{itemize}[<+(1)->]
        \widei
        \item Es existieren weitere Varianten der Rekursion: \begin{description}[geschachtelt]
            \item[geschachtelt] hier ist (mindestens) ein Parameter im rekursiven Aufruf selbst ein rekursiver Aufruf.\pause{} (Beispiele: Modulo, Ackermann)
            \item[verschränkt] hier rufen sich mehrere Funktionen rekursiv gegenseitig auf.\pause{} Diese Variante lässt sich schwer bis gar nicht (direkt) in eine Schleife übersetzten.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Das Paradigma: Divide and Conquer}
    \begin{itemize}[<+(1)->]
        \widei
        \item Manche Probleme, die kompliziert sind,\pause{} lassen sich durch Rekursion in immer kleinere Probleme aufspalten, die dann beherrschbarer sind.
        \item Dieses Problem wird uns bei den Sortieralgorithmen \hyperlink{mrk:sort-Mergesort}{Merge-} und \linksort{Quicksort} wieder begegnen.
    \end{itemize}
\end{frame}

\subsection{Laufzeitkomplexität}
\begin{frame}{Komplexitätsbetrachtung}
    \begin{itemize}[<+(1)->]
        \widei
        \item Da die Länge, die ein Programm (in Sekunden) benötigt,\pause{} von vielen Parametern\pause{} (Taktrate des Prozessors, andere laufende Programme, \ldots) abhängig ist,\pause{} betrachten wir die Skalierung eines Algorithmus für umfangreiche Eingaben.
    \end{itemize}
    \begin{definition}<6->[Effizienz]
        \pause{}Die Effizienz eines Programms wird durch seinen \emph{Speicheraufwand} sowie seiner \emph{Laufzeit} bestimmt.
    \end{definition}
    \begin{itemize}[<+(1)->]
        \widei
        \item<8-> Letztere werden wir genauer betrachten. \onslide<9->{Genauer, in welcher Komplexitätsklasse liegt der Algorithmus?}
    \end{itemize}
\end{frame}

\begin{frame}{Komplexitätsbetrachtung}
    \begin{itemize}[<+(1)->]
        \widei
        \item Diese Laufzeitkomplexität betrachten wir für drei Fälle: \begin{description}[average-case]
            \item[worst-case] die Laufzeitkomplexität im schlechtesten Fall für den (spezifischen) Algorithmus.
            \item[best-case] die Laufzeitkomplexität im günstigsten Fall für den (spezifischen) Algorithmus.
            \item[average-case] die Laufzeitkomplexität im durchschnittlichen Fall für den (spezifischen) Algorithmus.\pause{} Dies ist in der Regel das Verhalten bei einer gleichverteilten Eingabe.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Erfassen der Komplexität}
    \begin{itemize}[<+(1)->]
        \widei
        \item Die Erfassung der Laufzeitkomplexität erfolgt durch die Auflistung der notwendigen (Rechen-)Schritte:\pause{}
\begin{plainjava}[language=xJava]
static int methode(int n) {
    !**!|zws|int count = 2;|zws|
        for(|zws|int i = 1;|zws| |vgl|i <= n;|vgl| |inc|i++|inc|) {
            for(|zws|int j = n;|zws| |vgl|j > i;|vgl| |dec|j--|dec|)
                !**!|inc|count++;|inc|
        }
    return count;
}
    \end{plainjava}
    \end{itemize}
    \begin{multicols}{2}
        \begin{itemize}[<+(1)->]
            \item \bjava[language=xJava]{|zws|Zuweisungen|zws|}\,: \(2+n\)
            \item \bjava[language=xJava]{|vgl|Vergleiche|vgl|}\,: \(n+1+\frac{n(n+1)}{2}\)
            \item \bjava[language=xJava]{|inc|Inkrementierungen|inc|}\,: \(n+\frac{n(n-1)}{2}\)
            \item \bjava[language=xJava]{|dec|Dekrementierungen|dec|}\,: \(\frac{n(n-1)}{2}\)
        \end{itemize}
    \end{multicols}
\end{frame}

\begin{frame}{Erfassen der Komplexität}
    \begin{itemize}[<+(1)->]
        \item Insgesamt ergibt sich damit ein Aufwand von \(\frac{3n^2}{2} + \frac{5n}{2} + 3\).
        \item Eine genauere Betrachtung findet sich in den Folien des \(10\) Tutoriums, zu Übungsblatt \(9\).
        \item Da für große Datenmengen Konstanten und Faktoren irrelevant werden,\pause{} interessiert wie die Funktion skaliert/wächst.
    \end{itemize}
    \begin{definition}<6->[\O-Notation]
        \pause{}Es gilt \(T(n) \in \O(f(n))\), wenn \(f(n)\) eine obere Schranke von \(T(n)\) ist, also:\pause{} \[T(n) \in \O(f(n))\pause{}\iff\pause{} \exists n_0 \in \mathbb{N}\:\pause{} c \in \mathbb{R}^+\:\pause{} \forall n \geq n_0:\pause{} T(n) \leq c \cdot f(n).\vspace*{-\topskip}\]
    \end{definition}
\end{frame}

\begin{frame}[fragile]{Erfassen der Komplexität}
    \begin{itemize}[<+(1)->]
        \item Bei der Berechnung helfen die gängigen mathematischen Gesetze\pause{} (Logarithmus, \ldots)
        \item Die wichtigste Rechenregel:\pause{} \(\O(f(n) + g(n)) = \O(\max\{f(n), g(n)\})\)
        \item Neben der \(\O\) Notation, existieren noch weitere Notationen,\pause{} wie \(\Omega(n)\), welches analog die untere Grenze darstellt.
        \item In der Regel reichen die folgenden wichtigsten Komplexitätsklassen:\vskip2em\pause{}
\begin{center}%
\resizebox{0.975\linewidth}{!}{%
\setlength{\aboverulesep}{0pt}%
\setlength{\belowrulesep}{0pt}%
\setlength{\extrarowheight}{.45ex}%
\begin{tabular}{c*{8}{c}}
    \toprule
    & \onslide<9->{\cellcolor{btcd@color@primary!100!btcd@color@alerted!21} \(\O(1)\)} & \onslide<10->{\cellcolor{btcd@color@primary!85!btcd@color@alerted!21}\(\O(\log n)\)} & \onslide<11->{\cellcolor{btcd@color@primary!69!btcd@color@alerted!21} \(\O(n)\)} & \onslide<12->{\cellcolor{btcd@color@primary!53!btcd@color@alerted!21} \(\O(n\log n)\)} & \onslide<13->{\cellcolor{btcd@color@primary!36!btcd@color@alerted!21} \(\O(n^2)\)} & \onslide<14->{\cellcolor{btcd@color@primary!19!btcd@color@alerted!21} \(\O(n^3)\)} & \onslide<15->{\cellcolor{btcd@color@primary!14!btcd@color@alerted!21} \(\O(2^n)\)} & \onslide<16->{\cellcolor{btcd@color@primary!0!btcd@color@alerted!21} \(\O(n!)\)} \\[0.45ex]\midrule
    Bsp: & \onslide<9->{\(42\)} & \onslide<10->{\(4 \log (3n)\)} & \onslide<11->{\(4n-3\)} & \onslide<12->{\(4n\log(2n)\)} & \onslide<13->{\(n^2 + 2n - 1\)} & \onslide<14->{\(n^3 - 42n^2\)} & \onslide<15->{\(14\cdot2^n\)}& \onslide<16->{\(n! \cdot 10^{-42}\)}\\
    Bez: &\onslide<9->{\footnotesize konst.} & \onslide<10->{\footnotesize logarithm.} & \onslide<11->{\footnotesize linear} &\onslide<12->{\footnotesize linear log.} & \onslide<13->{\footnotesize quadratisch} & \onslide<14->{\footnotesize kubisch} & \onslide<15->{\footnotesize exponentiell} & \onslide<16->{\footnotesize faktoriell} \\
\bottomrule
\end{tabular}}
        \end{center}
    \end{itemize}
\end{frame}

\subsection{Modellierung durch UML}

\begin{frame}{UML, Grundlagen}
    \begin{itemize}[<+(1)->]
        \item Die Unified Modeling Language (UML) ist eine Kollektion an UML-Diagrammarten,\pause{} die es erlaubt ein Problem/Programm/Projekt aus verschiedenen Blickwinkeln zu betrachten.
        \item Im Kontext der Vorlesung gilt es drei Typen kurz zu skizzieren: \begin{description}[Sequenzdiagramme]
            \item[Klassendiagramme] modellieren die Beziehungen und Eigenschaften der beteiligten Klassen.
            \item[Objektdiagramme] modellieren die Beziehungen und Ausprägungen (spezifischer) Objekte.
            \item[Sequenzdiagramme] modellieren den Nachrichtenaustausch in einem Programm.\pause{} Ist ereignisbasiert.
        \end{description}
        \item UML wird hier (wie in der Vorlesung auch) nur oberflächlich betrachtet.
    \end{itemize}
\end{frame}

\begin{frame}[c]{UML, Ein Überblick}
\begin{center}
    \resizebox{0.95\linewidth}{!}{
\begin{tikzpicture}[every node/.append style={text width=4.5cm, align=center, execute at begin node={\strut},block,font=\small\sffamily}]
    \onslide<2->{\node[iblock,text width=] (a) at (0,0) {UML};}
    \onslide<3->{\node[] (b1) at(-5,-1) {Strukturdiagramme};}
    \onslide<4->{\node[] (b2) at (0,-1) {Verhaltensdiagramme};}
    \onslide<5->{\node (b3) at (5,-1) {Weitere Diagramme};}
    \begin{scope}[every node/.append style={text width=3.25cm,font=\scriptsize\sffamily}]
        \onslide<6->{\node[iblock,font=\scriptsize\sffamily] (c2) at (-4,-2) {Klassendiagramm};}
        \onslide<7->{\node[iblock,font=\scriptsize\sffamily] (c3) at (1,-2) {Sequenzdiagramm};}
        \onslide<8->{\node (c4) at (6,-2) {Kommunikations\-struktur-Diagr.};}

        \onslide<6->{\node[iblock,font=\scriptsize\sffamily] (left1) at (-4,-3) {Objektdiagramm};
        \node[] (left2) at (-4,-4) {Paketdiagramm};}

        \onslide<7->{\node[] (middle1) at (1,-3) {Anwendungsfalldiagr.};
        \node[] (middle2) at (1,-4) {Kommunikationsdiagr.};
        \node[] (middle3) at (1,-5) {Aktivitätsdiagmm};
        \node[] (middle4) at (1,-6) {Zustandsdiagr.};
        \node (middle5) at (1,-7) {\ldots};}

        \onslide<8->{\node (right1) at (6,-3) {Komponentendiagr.};
        \node (right2) at (6,-4) {Verteilungsdiagr.};}
    \end{scope}


    \onslide<5->{ \draw (a) -| (b1) (a) -- (b2) (a) -| (b3);}
    % \draw (b1.195) -- ++(0,-0.33) (b1.345) -- ++(0,-0.33);
    \onslide<9->{\draw (b2.195) |- (c3) (b3.195) |- (c4);
    \draw (b1.195) |- (c2);
    \foreach \i in {1,2} {\draw (b1.195) |- (left\i);\draw (b3.195) |- (right\i);}
    \foreach \i in {1,...,5} {\draw (b2.195) |- (middle\i);}}

\end{tikzpicture}
    }
\end{center}
\end{frame}

\begin{frame}[c]{UML, Klassendiagramme}
    \begin{center}
        \onslide<2->{
        \begin{tikzpicture}[scale=0.65, every node/.style={transform shape}]
            \tikzumlset{fill class=white, fill note=white!20} % , font=\small\LILLYxlstTypeWriter
            \umlclass[x=0,y=0,name=stud]{Student}{
                {\umlstatic{+ studierendenzahl : int}}\\
                {- name : String}\\
                {- matrikelnummer : int}\\
                {+ besuchtVorlesungen : String[5]}}{
                    {+ Student (name : String, nummer : int)}\\
                    {+ getName() : String}\\
                    {+ getNummer() : int}\\
                    {+ addVorlesung(String name) : void}\\
                    {+ getVorlesungen() : String[5]}\\
                    {+ removeVorlesung(String name) : void }}
            \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt,mirror},yshift=0pt] (-4,2) -- ++(0,-1.92) node [black,midway, above,rotate=90,yshift=0.75cm] {Attribute};
            \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt,mirror},yshift=0pt] (-4,2-1.92) -- ++(0,-2.78) node [black,midway, above,rotate=90,yshift=0.75cm] {Methoden};
            \node at(0,3.25) [above] (kln) {Klassenname};
            \draw[-latex] (kln) -- ++(0,-0.799);
            {\node [right] at (4.5,1.82-1.54/2+0.9) {\parbox{9cm}{
                {(\textbf{--}) steht für ein \bjava{private} Attribut}\\
                {(\textbf{+}) für ein \bjava{public} Attribut}\\
                {(\textbf{\#}) für ein \bjava{protected} Attribut}\\
                {\bjava{static}-Komponenten werden unterstrichen.}}};
            }
            \onslide<3->{\draw [latex-] (4.15,1.85-1.3) -- ++(3,0) node[right] {\small bis zu 5 Vorlesungen};}
            \onslide<4->{\umlclass[x=11,y=-2,name=gang]{Studiengang}{- name : String\\- prof : String}{ + Studiengang(name : String, prof : String)\\ + getName() : String\\ + getProfessor() : String};}
            \only<5->{\umlassoc[mult1=0..3,pos1=0.965, mult2=*, pos2=0.2]{Student}{Studiengang};}
            \onslide<6->{\draw [decorate,decoration={brace,amplitude=7pt,raise=4pt,mirror},yshift=0pt] (4.125,-3.75) -- ++(2.15,0) node [black,midway, below,yshift=-0.75cm] {\begin{minipage}{8cm}
                \centering\scriptsize Ein Student kann bis zu 3 Studiengänge gleichzeitig besuchen, ein Studiengang kann von unendlich vielen Studenten besucht werden.
            \end{minipage}};]}
        \end{tikzpicture}}
    \end{center}
\end{frame}

\begin{frame}{UML, Klassendiagramme}
    \begin{itemize}[<+(1)->]
        \item Es gibt noch weitere Assoziationen.
        \item So kann diese gerichtet sein (Pfeil am Ende) um eine Leserichtung vorzuschreiben,\pause{} oderein gefülltes (Komposition) oder leeres (Aggregation) Rechteck haben um Teile eines Ganzen zu modellieren.
        \item Gestrichelte Assoziationen markieren Abhängigkeiten.
        \item Vererbungen werden durch einen nicht augefüllten Pfeil gekennzeichnet.
        \item Pakete werden durch einen extra Kasten gekennzeichnet.
        \item \textit{Wichtig:} Attribute deren Typ eine andere Klasse ist werden durch eine Assoziation gekennzeichnet,\pause{} dies gilt auch, wenn eine Klasse sich selbst referenziert\pause{} (LinkedList, \ldots).
        \item Für weiterführende informationen siehe Folien des neunten Tutoriums.
    \end{itemize}
\end{frame}

\begin{frame}{UML, Objektdiagramme}
    \begin{itemize}[<+(1)->]
        \item Objektdiagramme ähneln Klassendiagrammen.
        \item Allerdings handelt es sich immer um explizite Ausprägungen einer Klasse\pause{} (\(\Rightarrow\) keine Methoden).
        \item Sie werden eher selten verwendet.
    \end{itemize}
    \vfill\pause{}
    \begin{center}
        \begin{tikzpicture}[scale=0.75]
            \node[rectangle split, rectangle split parts = 2,align=center,draw,inner sep=7pt] at(0,0) {%
                \bfseries \underline{objektname : Klassenname}\nodepart{two}
                    attributA = <(aktueller) Wert> \\
                    attributB = <(aktueller) Wert> \\
                    \(\vdots\)
            };
        \end{tikzpicture}
    \end{center}\vfill\hbox{}
\end{frame}

\begin{frame}{UML, Sequenzdiagramme}
    \begin{itemize}[<+(1)->]
        \item Bilden den Nachrichtenaustausch ab.\pause{} Das Senden und Empfangen wird auf Basis von Ereignissen ausgelöst,\pause{} diese rufen wiederrum Reaktionen hervor.
        \item Die Nachrichten können jeweils synchron (durchgezogene Linie) oder asynchron (gestrichelte Linie) ausgetauscht werden.
        \item Nachrichten selbst können Methodenaufrufe,\pause{} Rückgabewerte\pause{} oder externe Ereignisse sein (wie Zeitereignisse).
        \item Der Zeitliche Ablauf wird hierbei durch \say{Lebenslinien} gekennzeichnet.
    \end{itemize}
\end{frame}

\begin{frame}[c]{UML, Sequenzdiagramme - ein Beispiel}
    \begin{center}
        \resizebox{0.6\linewidth}{!}{\begin{tikzpicture}
            \begin{umlseqdiag}
              \umlactor[class=Player]{playerA}
              \umlcontrol[class=Server,x=6]{mainServer}
              \begin{umlcall}[op={\bjava{createLobby("test")}}]{playerA}{mainServer}
                \begin{umlcallself}[op={erstelle Lobby\ldots},op-style={right}]{mainServer}
                \end{umlcallself}
                \begin{umlfragment}[type=alt, inner xsep=5]
                  \begin{umlcall}[op={\bjava{true /*:ws:success */}},type=return]{mainServer}{playerA}
                  \end{umlcall}
                  \umlfpart[error]
                  \begin{umlcall}[op={\bjava{false /*:ws:failure */}},type=return]{mainServer}{playerA}
                  \end{umlcall}
                \end{umlfragment}
              \end{umlcall}
            \end{umlseqdiag}
        \end{tikzpicture}}
    \end{center}
\end{frame}

\subsection{Zahlensysteme}

\begin{frame}{Darstellung ganzer Zahlen}
    \begin{itemize}[<+(1)->]
        \item Um Zahlen darzustellen verwenden wir ein \emph{Stellenwertsystem}.
        \item Das bedeutet der Wert einer Ziffer ergibt sich nicht nur über die Basis\pause{} sondern auch über die Stelle.
    \end{itemize}
    \vfill
    \begin{definition}<5->[Stellenwertsystem]
        \pause{}Bei einer Basis \(b\) und einer Zahl \(z\) aus den Ziffern = \(z = z_{n} z_{n-1}\ldots z_0\)\pause{} ergibt sich ihr Wert im uns bekannten Dezimalsystem (\(b = 10\)) durch:\pause{} \[b_{10} = \sum_{i = 0}^{n} z_i \cdot b^i\]
    \end{definition}
    \vfill\hbox{}
\end{frame}

\begin{frame}{Darstellung ganzer Zahlen}
\begin{itemize}[<+(1)->]
    \item Die wichtigsten Basen für uns sind:\pause{} \(b = 2\) (dual/binär),\pause{} \(b = 8\) (Oktal)\pause{} und \(b = 16\) (Hexadezimal)
    \item Im Hexadezimalsystem werden die Ziffern \(\geq 10\) durch die Buchstaben \(A\,\widehat{=}\,10\) bis \(F\,\widehat{=}\,15\) dargestellt.
    \item Wir können eine Zahl aus dem Dezimalsystem in jedes andere konvertieren,\pause{} indem wir sukzessiv die Ziffern durch \say{\(\mod b\)} generieren\pause{} und die Zahl dann (ohne Rest) durch \(b\) dividieren.
    \item Beispiel: \(z = 10\) soll ins Dualsystem konvertiert werden:\pause{} \begin{alignat*}{3}
        \onslide<+->{10 & \div 2 = 5 \qquad&10 \mod 2 &= 0 \;(\leftarrow LSB) \\}
        \onslide<+->{5 & \div 2 = 2 \qquad&5 \mod 2 &= 1 \\}
        \onslide<+->{2 & \div 2 = 1 \qquad&2 \mod 2 &= 0 \\}
        \onslide<+->{1 & \div 2 = 0 \qquad&1 \mod 2 &= 1 \;(\leftarrow MSB)\\}
    \end{alignat*}
\end{itemize}
\end{frame}


\begin{frame}{Darstellung ganzer Zahlen}
\begin{itemize}[<+(1)->]
    \item Dies ergibt: \(1010_{(2)}\).
    \item Hinweis: es existieren weitere (schnelle) Konvertierungsverfahren,\pause{} die es zum Beispiel das Hexadezimalsystem direkt ins Dualsystem zu konvertieren.\pause{} Da hier jede Ziffer im Hexadezimalsystem \(4\) Bits einnimmt, geht die Konvertierung schneller:\pause{} \[
        AFFE_{(16)} = \overbrace{1010}^{A}\;\overbrace{1111}^{F}\;\overbrace{1111}^{F}\;\overbrace{1110}^{E}\;{}_{(2)}\vspace*{-0.4cm}
    \]
\end{itemize}
\Task{Zahlen konvertieren}%
\begin{exercise}<+->[Zahlen konvertieren\Time{3}]
    \onslide<+->{Konvertiere \(42_{(8)}\) zur Basis \(b = 16\), \(b = 3\) und ins Binärsystem.}
\end{exercise}
\end{frame}

\begin{frame}[c]{Übungsaufgabe -- Lösung}
\begin{solve}<2->[Zahlen konvertieren]
    \pause{}Konvertieren wir die Zahl zuerst ins Binärsystem (schnelle Konvertierung mit je \(3\) Bits),\pause{} dann von dort aus ins Hexadezimalsystem,\pause{} nun ins Dezimalsystem (nicht gefordert) und dann in \(b = 3\):\pause{} \begin{description}[b = 16]
        \item[b = 2] \(42_{(8)} = \overbrace{100}^{4}\overbrace{010}^{2}\;{}_{(2)}\)
        \item[b = 16] \(100010_{(2)} = \overbrace{2}^{10}\overbrace{2}^{0010}\;{}_{(16)}\) (wir füllen also links mit Nullen auf, wenn die Bits kein Vielfaches von vier sind)
        \item[b = 10] \(4 \cdot 8^1 + 2 \cdot 8^0 = 32 + 2 = 34_{(10)}\)
    \end{description}
\end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe -- Lösung}
\addtocounter{solve}{-1}
\begin{solve}<1->[Zahlen konvertieren\hfill{}(Fortsetzung)]
    \begin{description}[b = 16]
        \item[b = 3] Wir verwenden sukzessive Division um von \(34_{(10)}\) auf \(b = 3\) zu kommen:\pause{} \begin{alignat*}{3}
            \onslide<+->{34 & \div 3 = 11 \qquad&34 \mod 3 &= 1 \;(\leftarrow LSB) \\}
            \onslide<+->{11 & \div 3 = 3 \qquad&11 \mod 3 &= 2 \\}
            \onslide<+->{3 & \div 3 = 1 \qquad&3 \mod 3 &= 0 \\}
            \onslide<+->{1 & \div 3 = 0 \qquad&1 \mod 3 &= 1 \;(\leftarrow MSB)\\}
        \end{alignat*}
        Damit ergibt sich:\pause{} \(42_{(8)} = 100010_{(2)} = 22_{(16)} = 34_{(10)} = 1021_{(3)}\)
    \end{description}
\end{solve}
\end{frame}

\subsection{Übungsaufgaben}

\begin{frame}[fragile,c]{Funktion zu Rekursion}
    \Task{Schleife zu Rekursion}
    \begin{exercise}<2->[Schleife zu Rekursion\Time{4}]
        Wandle folgenden Code in einen rekursiven Algorithmus um:\pause{}
        \begin{plainjava}
!*\onslide<3->*!public int ggT(int a, int b){
!*\onslide<4->*!    while(b != 0){
!*\onslide<5->*!        int tmp = b;
!*\onslide<5->*!        b = a % b;
!*\onslide<5->*!        a = tmp;
!*\onslide<4->*!    }
!*\onslide<6->*!    return a;
!*\onslide<3->*!}
        \end{plainjava}
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Funktion zu Rekursion -- Lösung}
    \begin{solve}<2->[Schleife zu Rekursion]
\begin{plainjava}
public int ggT(int a, int b){
    if(b == 0) return a;
    else return ggt(b, a % b);
}
\end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Rekursiver Konverter}
    \Task{Rekursion zur Konvertierung}
    \begin{exercise}<2->[Rekursion zur Konvertierung\Time{4}]
        \pause{}Schreibe einen rekursiven Algorithmus, der einen positiven Integer in seine Binärdarstellung (als \bjava{String}) verwandelt.\pause{}
        Beispiel:\pause{}
\begin{plainjava}
|plain|int2bin|plain|(42) // :yields: 101010
\end{plainjava}
    \pause{}Hinweis: um eine Zahl in einen String zu konvertieren kann Konkatenation,\pause{} sowie \bjava{String.valueOf(int)} verwendet werden.
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Funktion zu Rekursion -- Lösung}
    \begin{solve}<2->[Schleife zu Rekursion]
\begin{plainjava}
!*\onslide<3->*!public String |plain|int2bin|plain|(int num){
!*\onslide<4->*!    if(num < 2) return String.valueOf(num);
!*\onslide<5->*!    return |plain|int2bin|plain|(num / 2) + String.valueOf(num % 2);
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}


\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{Rechenaufwand berechnen}
    \begin{exercise}<2->[Rechenaufwand berechnen\Time{6}]
        \pause{}Wie viele Rechenschritte benötigt das folgende Verfahren einmal im \emph{worst-} und im \emph{best-case}? Gib jeweils auch die \O-Notation an: \pause{}
\begin{plainjava}
int getDistance(String a, String b){
    if(a == null || b == null) return -1;
    if(a.length() != b.length()) return -1;
    int dist = |num||cmt|0x|cmt|0|num|;
    for(int i = |num||cmt|0b|cmt|0|num|; i < a.length(); i++)
        if(a.charAt(i) != b.charAt(i))
            dist++;
    return dist;
}
\end{plainjava}
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[c]{Übungsaufgabe -- Lösung}
    \begin{solve}<2->[Rechenaufwand berechnen]
    \pause{}Handeln wir zuerst den \emph{best-case} ab.\pause{} Hier ist der String \bjava{a} \bjava{null} und die erste \bjava{if}-Bedingung terminiert mit \bjava{-1}.\pause{} Wir haben also im \emph{best-case} mit einem Aufwand von einem Vergleich und damit: \(\O(1)\).\pause{} (Auch wenn dieser \emph{best-case} relativ sinnfrei ist.\pause{} Was wäre denn der \emph{best-case} bei einer \say{gültigen} Eingabe\pause{} (also zwei gleichlangen Strings, die nicht \bjava{null} sind)?)\pause{} Kommen wir nun zum \emph{worst-case}:
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Übungsaufgabe -- Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<1->[Rechenaufwand berechnen\hfill{}(Fortsetzung)]
\begin{plainjava}[language=xJava]
int getDistance(String a, String b){
    if(|vgl|a == null|vgl| || |vgl|b == null|vgl|) return -1;
    if(|vgl|a.length() != b.length()|vgl|) return -1;
    !**!|zws|int dist = |num||cmt|0x|cmt|0|num|;|zws|
    for(|zws|int i = |num||cmt|0b|cmt|0|num|;|zws| |vgl|i < a.length();|vgl| |inc|i++|inc|)
        if(|vgl|a.charAt(i) != b.charAt(i)|vgl|)
            !**!|inc|dist++|inc|;
    return dist;
}
\end{plainjava}
    \end{solve}
\end{frame}


\begin{frame}[c]{Übungsaufgabe -- Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<1->[Rechenaufwand berechnen\hfill{}(Fortsetzung)]
        \pause{}Sei die Länge von \bjava{a} durch \(n\) notiert (\bjava{a.length()}\(\widehat{=} n\))
\begin{multicols}{2}
    \begin{enumerate}[<+(1)->]
        \item \bjava[language=xJava]{|zws|Zuweisungen|zws|}\,: \(2\)
        \item \bjava[language=xJava]{|vgl|Vergleiche|vgl|}\,: \(3 + n + n + 1\)
        \item \bjava[language=xJava]{|inc|Inkrementierungen|inc|}\,: \(n+n\)
        \item \bjava[language=xJava]{|dec|Dekrementierungen|dec|}\,: \(0\)
    \end{enumerate}
\end{multicols}
    \pause{}Insgesamt ergibt sich damit: \((2) + (4 + 2n) + (2n) + (0) = 6 + 4n\).\pause{} Dieser Rechenaufwand liegt in \(6 + 4n \in \O(n)\).\smallskip\newline\pause{}Hinweis:\pause{} Der Vergleich im Kopf einer \bjava{for}-Schleife wird einmal öfters ausgeführt,\pause{} als die \bjava{for}-Schleife selbst.
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{Komplexitätsklassen ordnen}
    \begin{exercise}<2->[Komplexitätsklassen ordnen\Time{4}]
        \pause{}Ordne die folgenden Komplexitätsklassen ohne Beweis, von der am geringsten skalierenden zur am stärksten skalierenden.\pause{}
        \begin{multicols}{3}
            \begin{enumerate}[<+(1)->]\widei
                \item \(\O(n \cdot \log(n^2))\)
                \item \(\O(\frac{n}{12}) + \O(n^3)\)
                \item \(\O(4^n)-\O(2^n)\)
                \item \(\O(\frac{n!}{n})\)
                \item \(\O(14n+12)\)
            \end{enumerate}
        \end{multicols}
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Übungsaufgabe -- Lösung}
    \begin{solve}<2->[Komplexitätsklassen ordnen]
        \pause{}Es ergibt sich: \begin{enumerate}[<+(1)->]
            \item \(\O(14n+12) = \O(n)\)
            \item \(\O(n \cdot \log(n^2)) = \O(n \cdot 2 \cdot \log(n)) = \O(n \log n)\)
            \item \(\O(\frac{n}{12}) + \O(n^3) = \O(n^3)\)
            \item \(\O(4^n) - \O(2^n) = \O(4^n - 2^n) = \O(4^n)\)
            \item \(\O(\frac{n!}{n}) = \O((n-1)!) = \O(n!)\)
        \end{enumerate}
        \pause{}Eine derartige Kategorisierung kann auch genauer präzisiert werden.
    \end{solve}
\end{frame}

\section{Weiterführende Konzepte}

\subsection{Suchverfahren}

\begin{frame}{Suchverfahren formal}
    \begin{itemize}[<+(1)->]
        \item Ein Suchverfahren hat die Aufgabe in einer Folge an Elementen,\pause{} die zu finden, die einem Muster oder gewissen Eigenschaften entsprechen.
        \item Es gibt zwei Varianten: \begin{description}[Heuristisch]
            \item[Einfach] Durchlaufen Suchraum auf Basis einer Datenstruktur.
            \item[Heuristisch] Besitzen zusätzliches Wissen (Sortierung,\ldots) über die Daten die sie zur Beschleunigung der Suche verwenden.
        \end{description}
        \item Die \emph{Eigenschaften} nach denen gesucht werden soll, kann man auch als \emph{Merkmale} bezeichnen.
    \end{itemize}
\end{frame}

\begin{frame}{Klassische Suchverfahren}
    \begin{itemize}[<+(1)->]
        \widei
        \item Uns sind zwei Verfahren bekannt Elemente zu suchen: \begin{description}[Linear]
            \item[Linear] Die lineare/naive/sequentielle Suche beginnt am Anfang der Folge und prüft Element für Element ob es sich um das gesuchte handelt.\pause{} Die Komplexität beträgt \(\O(n)\).
        \end{description}
        \vfill
        \begin{center}
            \onslide<5->{\begin{tikzpicture}
                \foreach[remember=\i as \li(initially 0)] \i in {1,...,10}{
                    \ifnum\i=6
                        \node[inner sep=4.35pt,iball,double,outer sep=2pt] (\i) at(\i,0) {};
                    \else
                        \node[inner sep=4pt,ball,outer sep=2pt] (\i) at(\i,0) {};
                    \fi
                    \ifnum\i>1
                        \draw (\li.east) -- (\i.west);
                    \fi
                }
                \onslide<+->{
                    \foreach[remember=\i as \li (initially 1)] \i in {2,...,6}{
                        \draw[-Kite] (\li.80) to[bend left] (\i.100);
                    }
                }
            \end{tikzpicture}}
        \end{center}
        \vfill\hbox{}
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Klassische Suchverfahren}
    \begin{plainjava}
    !*\onslide<2->*!int linearSearch(int[] sequence, int key){
    !*\onslide<3->*!    for(int i = 0; i < sequence.length; i++)
    !*\onslide<4->*!        if(sequence[i] == key) return i;
    !*\onslide<5->*!    return -1; // Magic Number für "not found"
    !*\onslide<2->*!}
    \end{plainjava}
    \end{frame}

\begin{frame}{Klassische Suchverfahren}
    \begin{itemize}[<+(1)->]
        \item[]\begin{description}[Linear]
            \item[Binär] Die binäre Suche benötigt eine (aufsteigend) \emph{sortierte} und arbeitet sich baumartig durch die Folge.\pause{} Sie vergleicht das mittlere Element des aktuellen Suchbereiches mit dem Suchbegriff.\pause{} Wenn er größer ist, wird im Suchfenster rechts von der Mitte, wenn er kleiner links von der Mitte weitergesucht.\pause{} Die Komplexität beträgt \(\O(\log n)\) (ohne Sortieren).
        \end{description}
        \vspace*{1em}
        \begin{center}
            \onslide<7->{\scalebox{0.65}{\begin{forest}
                for tree={inner sep=4pt,ball,outer sep=1pt}
                [,name=m1[[[][[][,phantom]]][[][[][]]]][,name=m2[][,name=m3[,name=m4,iball,inner sep=4.35pt,double[,phantom][]][[]]]]]
                \onslide<+->{
                    \draw[-Kite] (m1) to[bend left,looseness=1.25] (m2);
                    \draw[-Kite] (m2) to[bend left,looseness=1.15] (m3);
                    \draw[-Kite] (m3) to[bend right,looseness=1] (m4);
                }
            \end{forest}}}
        \end{center}
        \vfill\hbox{}
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Klassische Suchverfahren}
    \begin{plainjava}
!*\onslide<2->*!int binarySearch(int[] sequence, int key){
!*\onslide<3->*!    int min = 0, max = sequence.length-1;
!*\onslide<4->*!    while(min <= max) {
!*\onslide<5->*!        int middle = (min + max)/2; // Mitte
!*\onslide<6->*!        if(sequence[middle] == key) // gefunden
!*\onslide<6->*!            return middle;
!*\onslide<7->*!        else if(key < sequence[middle]) // links
!*\onslide<7->*!            max = middle - 1;
!*\onslide<8->*!        else // rechts
!*\onslide<8->*!            min = middle + 1;
!*\onslide<4->*!    }
!*\onslide<9->*!    return -1; // Magic Number für "not found"
!*\onslide<2->*!}
\end{plainjava}
\end{frame}

\subsection{Sortierverfahren}

\begin{frame}{Sortierverfahren formal}
    \begin{itemize}[<+(1)->]
        \item Beschreibt einen Prozess bei dem Elemente aufgrund eines Ordnungskriteriums ihrer Eigenschaften in eine Reihenfolge gebracht werden.
        \item Daten werden sortiert um die Suche zu vereinfachen.
        \item Wir unterscheiden zwei Sortierverfahren: \begin{description}[Extern]
            \item[Intern] Hier liegt der gesamte Datenbestand im Arbeitspeicher,\pause{} alle Elemente sind zugreifbar (Array, \ldots)
            \item[Extern] Der Datenbestand ist (überwiegend) ausgelagert,\pause{} für das Sortieren werden in der Regel nur die obersten Element eines Stapels betrachtet (Dateien, \ldots).\pause{} In der Regel lassen sich durch Modifikationen und unterstützenden Methoden die selben Verfahren wie bei der Internen Variante verwenden.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Sortierverfahren formal}
    \begin{itemize}[<+(1)->]
        \widei
        \item Bei der Vorgehensweise unterscheiden wir (im Kontext der Vorlesung) drei Ansätze: \begin{description}[Divide-and-Conquer]
            \item[Sukzessiv] Schritt für Schritt wird die Anzahl an unsortierten Elementen verringert.\pause{} In der Regel iterativ implementiert.
            \item[Divide-and-Conquer] Daten werden aufgeteilt,\pause{} in Teilen sortiert und dann aus sortierten Teilmengen sortiert zusammengefügt.\pause{} In der Regel rekursiv implementiert.
            \item[Halde] Sortieren mit dafür geeigneten Datenstrukturen wie dem \emph{Heap}.\pause{} In der Regel rekursiv implementiert.
        \end{description}
    \end{itemize}
\end{frame}

\def\List#1#2{
    \foreach[count=\i,remember=\i as \li(initially 0)] \n in {#1}{
        \ifnum\i>#2
            \node[inner sep=4pt,ball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
        \else
            \node[inner sep=4pt,iball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
        \fi
        \ifnum\i>1
            \draw (\li.east) -- (\i.west);
        \fi
    }
}

\begin{frame}{Sortierverfahren: Selectionsort}\alglabel{Selectionsort}
    \begin{definition}<2->[Selectionsort \hfill{}(iterativ)]
        \onslide<3->{Prinzip: Wahl des kleinsten Elements im unsortierten Teil, \onslide<4->{Anfügen des Elements als größtes Element des sortierten Teils.}}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Kann auch von oben nach unten implementiert werden.
        \item Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item Ist das kleinste Element an erster Stelle des unsortierten Teils wird dennoch getauscht (nach Vorlesung).
    \end{itemize}
    \vfill
    \begin{center}\pause{}
        \begin{minipage}{0.9\linewidth}
            \begin{multicols}{2}
                \begin{enumerate}[<+(1)->]
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{4,2,1,3}{0}
                        \draw[Kite-Kite] (1.north) to[bend left] (3.north);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{1,2,4,3}{1}
                        \draw[Kite-Kite] (2) to[loop above] (2);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{1,2,4,3}{2}
                        \draw[Kite-Kite] (3.north) to[bend left] (4.north);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{1,2,3,4}{4}
                    \end{tikzpicture}
                \end{enumerate}
            \end{multicols}
        \end{minipage}
    \end{center}
\end{frame}

\begin{frame}[fragile,c]{Sortierverfahren: Selectionsort}
    \begin{plainjava}
!*\onslide<2->*!public static void selectionSort(int[] arr) {
!*\onslide<3->*!    for(int i = 0; i < arr.length-1; i++) {
!*\onslide<4->*!        int min = i; // Suche Minimum
!*\onslide<5->*!        for (int j = i+1; j < arr.length; j++)
!*\onslide<6->*!            if(arr[j] < arr[min])
!*\onslide<6->*!                min = j;
!*\onslide<7->*!        // Tausche 'i' und 'min'
!*\onslide<8->*!        int tmp = arr[i];
!*\onslide<9->*!        arr[i] = arr[min];
!*\onslide<10->*!        arr[min] = tmp;
!*\onslide<3->*!    }
!*\onslide<2->*!}
    \end{plainjava}
\end{frame}

\begin{frame}{Sortierverfahren: Insertionsort}\alglabel{Insertionsort}
    \begin{definition}<2->[Insertionsort \hfill{}(iterativ)]
        \onslide<3->{Prinzip: Wahl des ersten Elements im unsortierten Teil, \onslide<4->{Sortieren des Elements in den bereits sortierten Teil.}}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item Das Tauschen erfolgt durch durchgehende Vertauschungen.
        \item Ist das Element schon an der richtigen Position wird dennoch getauscht.
    \end{itemize}
    \vfill
    \begin{center}\pause
        \begin{minipage}{0.9\linewidth}
            \begin{multicols}{2}
                \begin{enumerate}[<+(1)->]
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{4,2,1,3}{1}
                        \draw[-Kite] (1) to (2);
                        \draw[Kite-Kite] ([xshift=-15pt]1.north) to[bend left] (2.north);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{2,4,1,3}{2}
                        \draw[-Kite] (1) to (2);
                        \draw[-Kite] (2) to (3);
                        \draw[Kite-Kite] ([xshift=-15pt]1.north) to[bend left] (3.north);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{1,2,4,3}{3}
                        \draw[-Kite] (3) to (4);
                        \draw[Kite-Kite] ([xshift=-15pt]3.north) to[bend left] (4.north);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{1,2,3,4}{4}
                    \end{tikzpicture}
                \end{enumerate}
            \end{multicols}
        \end{minipage}
    \end{center}
\end{frame}

\begin{frame}[fragile,c]{Sortierverfahren: Insertionsort}
    \begin{plainjava}
!*\onslide<2->*!public static void insertionSort(int[] arr) {
!*\onslide<3->*!    for(int i = 0; i < arr.length; i++) {
!*\onslide<4->*!        int pos = i - 1, elem = arr[i];
!*\onslide<5->*!        while(pos >= 0 && arr[pos] > elem) { // Verschiebe
!*\onslide<6->*!            arr[pos+1] = arr[pos];
!*\onslide<6->*!            pos--;
!*\onslide<5->*!        }
!*\onslide<7->*!        arr[pos+1] = elem;
!*\onslide<3->*!    }
!*\onslide<2->*!}
    \end{plainjava}
\end{frame}

% \fi


\def\List#1#2{
    \foreach[count=\i,remember=\i as \li(initially 0)] \n in {#1}{
        \ifnum\i<#2
            \node[inner sep=4pt,ball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
        \else
            \node[inner sep=4pt,iball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
        \fi
        \ifnum\i>1
            \draw (\li.east) -- (\i.west);
        \fi
    }
}

\begin{frame}{Sortierverfahren: Bubblesort}\alglabel{Bubblesort}
    \begin{definition}<2->[Bubblesort \hfill{}(iterativ)]
        \onslide<3->{Prinzip: Vertausche benachbarte Elemente wenn sie nicht in Sortierungsreihenfolge sind.}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item Mit jedem Durchgang über das Array wird (mindestens) ein Element an die richtige Position getauscht.
        \item Verbesserung: Shaker-Sort, schiebt abwechselnd das maximale und minimale Element an die (Ziel-)Position.
    \end{itemize}
    \vfill
    \begin{center}\pause
        \begin{minipage}{0.9\linewidth}
            \begin{multicols}{2}
                \begin{enumerate}[<+(1)->]
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{4,2,1,3}{5}
                        \draw[Kite-Kite] (1.north) to[bend left] (2.north);
                        \draw[Kite-Kite] (2.north) to[bend left] (3.north);
                        \draw[Kite-Kite] (3.north) to[bend left] (4.north);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{2,1,3,4}{4}
                        \draw[Kite-Kite] (1.north) to[bend left] (2.north);
                    \end{tikzpicture}
                    \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                        \List{1,2,3,4}{0}
                    \end{tikzpicture}
                    \item<1->[]
                \end{enumerate}
            \end{multicols}
        \end{minipage}
    \end{center}
\end{frame}

\begin{frame}[fragile,c]{Sortierverfahren: Bubblesort}
    \begin{plainjava}
public static void bubbleSort(int[] arr) {
    for(int i = arr.length - 1; i >= 1; i--) {
        for(int j = 0; j < i; j++) {
            if(arr[j] > arr[j+1]) { // Vertausche
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            }
        }
    }
}
    \end{plainjava}
\end{frame}

% TODO: maybe make with separate circles?

\newsavebox{\dotA}
\newsavebox{\dotB}
\newsavebox{\dotC}
\newsavebox{\dotD}
\newsavebox{\dotE}
\newsavebox{\dotF}
\newsavebox{\dotG}


\def\TikzList#1#2#3{%
\savebox{#3}{\begin{tikzpicture}
    \foreach[count=\i,remember=\i as \li (initially 0)] \n in {#1}{
        \ifnum\i=#2
            \node[inner sep=4pt,iball,outer sep=0pt,scale=0.8] (\i) at(0.7*\i,0) {\n};
        \else
            \node[inner sep=4pt,ball,outer sep=0pt,scale=0.8] (\i) at(0.7*\i,0) {\n};
        \fi
        \ifnum\i>1 \draw(\li) -- (\i); \fi
    }
    \end{tikzpicture}}
}

\TikzList{4,2,1,3}{5}{\dotA}
\TikzList{4,2}{5}{\dotB}
\TikzList{1,3}{5}{\dotC}
\TikzList{4}{5}{\dotD}
\TikzList{2}{5}{\dotE}
\TikzList{1}{5}{\dotF}
\TikzList{3}{5}{\dotG}


\begin{frame}{Sortierverfahren: Mergesort}\alglabel{Mergesort}
    \begin{definition}<2->[Mergesort \hfill{}(rekursiv)]
        \onslide<3->{Prinzip: Aufteilen der Elemente in einelementige, sortierte Teilfolgen. \onslide<4->{Zusammenfügen sortierter Teilefolgen.}}
    \end{definition}
    \begin{itemize}[<+(1)->]
        % \item Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item Verfolgt \emph{easy split}, \emph{hard join}. Das Aufteilen ist leicht (trivial), das Zusammenfügen aufwändig, da hier die Sortierung erfolgen muss.
        \item Teilt sich auf in: \emph{Split} (aufteilen) und \emph{Merge} (verschmelzen).
    \end{itemize}
    \vfill
    \begin{center}\pause
        \scalebox{0.58}{\begin{forest}
            for tree={}
            [\usebox{\dotA},[{\usebox{\dotB}}[{\usebox{\dotD}}][{\usebox{\dotE}}]][{\usebox{\dotC}}[{\usebox{\dotF}}][{\usebox{\dotG}}]]]
            \node at(0,1) {Split};
        \end{forest}} \qquad~~\qquad%
        \TikzList{1,2,3,4}{5}{\dotA}%
        \TikzList{2,4}{5}{\dotB}%
        \TikzList{1,3}{5}{\dotC}%
        \TikzList{4}{5}{\dotD}%
        \TikzList{2}{5}{\dotE}%
        \TikzList{1}{5}{\dotF}%
        \TikzList{3}{5}{\dotG}%
        \scalebox{0.48}{\begin{forest}
            for tree={grow=north}
            [\usebox{\dotA},[{\usebox{\dotC}}[{\usebox{\dotG}}][{\usebox{\dotF}}]][{\usebox{\dotB}}[{\usebox{\dotE}}][{\usebox{\dotD}}]]]
            \node at(0,3.75) {Merge};
        \end{forest}}
    \end{center}
\end{frame}

\TikzList{4,2,1,3}{4}{\dotA}
\TikzList{1,2}{2}{\dotB}
\TikzList{1,3}{5}{\dotC}
\TikzList{4}{5}{\dotD}
\TikzList{2}{5}{\dotE}
\TikzList{1}{5}{\dotF}
\TikzList{3}{5}{\dotG}

\begin{frame}{Sortierverfahren: Quicksort}\alglabel{Quicksort}
    \begin{definition}<2->[Quicksort \hfill{}(rekursiv)]
        \onslide<3->{Prinzip: Wahl eines Pivotelements (nach Vorlesung: das Letzte).
        \onslide<4->{Aufteilen der Liste in Teil größer und kleiner des Pivotelements. \onslide<5->{Wenn Teillisten nach gleichem Prinzip sortiert: zusammenfügen aus \emph{Links + Pivot + Rechts}.}}}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item Verfolgt \emph{hard split}, \emph{easy join}. Das Aufteilen ist aufwändig (sortieren), das Zusammenfügen trivial.
    \end{itemize}
    \vfill
    \begin{center}\pause
        \scalebox{0.58}{\begin{forest}
            for tree={}
            [{\usebox{\dotA}},[{\usebox{\dotB}}[{\usebox{\dotF}}][,phantom]][{{\usebox{\dotD}}}[,phantom][,phantom]]]
            \node at(0,1) {Split};
        \end{forest}} \qquad~~\qquad%
        \TikzList{1,2,3,4}{3}{\dotA}
        \TikzList{1,2}{2}{\dotB}
        \TikzList{1,3}{5}{\dotC}
        \TikzList{4}{5}{\dotD}
        \TikzList{2}{5}{\dotE}
        \TikzList{1}{5}{\dotF}
        \TikzList{3}{5}{\dotG}
        \scalebox{0.58}{\begin{forest}
            for tree={grow=north}
            [{\usebox{\dotA}},[{{\usebox{\dotD}}}[,phantom][,phantom]][{\usebox{\dotB}}[,phantom][{\usebox{\dotF}}]]]
            %[{\(1,2,\mathbf{3},4\)},iblock[{\(4\)}[,phantom][,phantom]][{\(1,\mathbf{2}\)}[,phantom][\(1\)]]]
            \node at(0,3.75) {Merge};
        \end{forest}}
    \end{center}
\end{frame}

\begin{frame}{Sortierverfahren: Heapsort}\alglabel{Heapsort}
    \begin{definition}<2->[Heapsort \hfill{}(rekursiv)]
        \onslide<3->{Prinzip: Verwenden eines (Min-)Heaps zur Speicherung der Elemente. \onslide<4->{Sukzessives Entfernen des Wurzelelements (aktuelles Minimum), wiederherstellung der Heap-Eigenschaft.}}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item Die genaue Funktionsweise eines Heaps veranschaulichen wir gleich separat
    \end{itemize}
    \vfill
    \begin{center}\pause
        \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1,iball[3[4][,phantom]][2]]
        \end{forest}}} \(\rightarrow\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [2,iball[3][4]]
        \end{forest}}} \(\rightarrow\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [3,iball[4][,phantom]]
        \end{forest}}} \(\rightarrow\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [4,iball]
        \end{forest}}}
    \end{center}
\end{frame}

\begin{frame}{Exkurs: Heap}
    \hypertarget{mrk:Heap}{}%
    \begin{definition}<2->[Heap]
        \onslide<3->{Binärbaum, bei dem gilt: \(\text{Vaterknoten} < \text{Kindknoten}\).}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Neue Elemente werden von Unten an als neues Kind hinzugefügt. \pause{}Wird die Eigenschaft verletzt, werden solange kleinere Kinder nach oben getauscht bis die Eigenschaft wiederhergestellt ist.
        \item Beim Entfernen eines Elements wird das Blatt vor der aktuellen Einfügeposition als neue Wurzel getauscht.
        \item Beispiel: Einfügen der Elemente \(4,2,1,3\).
    \end{itemize}
    \vfill
    \begin{center}\pause
        \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [4[,fill=white][,phantom]]
        \end{forest}}} \(\overset{1}{\rightarrow}\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [4,name=4[1,name=1][,fill=white]]
            \draw[Kite-Kite] (4) to[bend right] (1);
        \end{forest}}} \(\overset{2}{\rightarrow}\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1[4[,fill=white][,phantom]][2]]
        \end{forest}}} \(\overset{3}{\rightarrow}\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1[4,name=4[3,name=3][,phantom]][2]]
            \draw[Kite-Kite] (4) to[bend right] (3);
        \end{forest}}} \(\rightarrow\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1[3[4][,phantom]][2]]
        \end{forest}}}
    \end{center}
\end{frame}

\begin{frame}[c]{Sortierverfahren: Zusammenfassung}
    \begin{table}[H]
        \renewcommand\arraystretch{1.35}
        \begin{tabular}{p{0.2\linewidth}p{0.175\linewidth}p{0.175\linewidth}p{0.15\linewidth}p{0.15\linewidth}}
        \toprule
            Sortierverfahren & worst-case & average-case & Speicher & Ansatz \\
        \midrule
            \linksort{Selectionsort} & \(\O(n^2)\) & \(\O(n^2)\) & \(\O(1)\) & iterativ \\
            \linksort{Insertionsort} & \(\O(n^2)\) & \(\O(n^2)\) & \(\O(1)\) & iterativ \\
            \linksort{Bubblesort} & \(\O(n^2)\) & \(\O(n^2)\) & \(\O(1)\) & iterativ \\
            \linksort{Mergesort} & \(\O(n \log n)\) & \(\O(n \log n)\) & \(\O(n)\) & rekursiv \\
            \linksort{Quicksort} & \(\O(n^2)\) & \(\O(n \log n)\) & \(\O(\log n)\) & rekursiv \\
            \linksort{Heapsort} & \(\O(n\log n)\) & \(\O(n \log n)\) & \(\O(1)\) & rekursiv \\
        \bottomrule
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}{Eigenschaft: Stabil}
    \begin{definition}<2->[Stabiles Sortierverfahren]
        \onslide<3->{Ein Sortierverfahren heißt stabil, wenn es die Reihenfolge (aus Sicht des Verfahrens) gleicher Element nicht ändert.}
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Beispiel: Eine bereits alphabetisch nach Nachnamen sortierte Liste an Personen wird nun nach Alter sortiert.\pause{} Bei einem stabilen Sortierverfahren bleibt die alphabetische Sortierung bei Personen des selben Alters erhalten.
        \item Stabile Sortierverfahren (nach Implementation der Vorlesung):\pause{} \linksort{Insertionsort}, \linksort{Quicksort} und \linksort{Mergesort}.
    \end{itemize}
\end{frame}


\subsection{Konzept: Backtracking}

\begin{frame}{Backtracking}
    \begin{itemize}[<+(1)->]
        \item Backtracking ist eine rekursive Lösungsstrategie.
        \item Das Problem wird von einer Teillösung aus erweitert, bis man auf die Gesamtlösung stößt,\pause{} oder in eine \say{Sackgasse} gelangt (trial and error), in diesem Fall probiert man eine andere Erweiterung.
        \item Beispiele: \begin{itemize}
            \item Wegfindung im Labyrinth.\pause{} Wir beginnen mit dem Startfeld und gehen solange einen Weg entlang bis wir am Zeil ankommen.\pause{} Kommen wir an eine Sackgasse springen wir zur letzten Position zurück an der es noch einen anderen Weg gab.
            \item Lösung eines Sudoku.\pause{} Wir beginnen mit dem Sudoku und fügen in das erste freie Feld eine der möglichen Zahlen ein.\pause{} Wir verfahren so, bis alle Felder gefüllt sind, oder wir in ein Feld keine Zahl mehr eintragen können.\pause{} In diesem Fall springen wir zum letzen Punkt zurück, an dem wir noch andere Zahlen eintragen konnten.
            \item Rucksackproblem, \(8\)-Damen Problem, \ldots
        \end{itemize}
    \end{itemize}
\end{frame}

\subsection{Übungsaufgaben}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Sortieralgorithmen abwägen}
    \begin{exercise}<2->[Sortieralgorithmen abwägen \Time{2}]
        Quicksort hat eine schlechtere \emph{worst-case} Laufzeit als Mergesort, wieso trifft man in der Praxis dennoch häufig Quicksort?
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Sortieralgorithmen abwägen]
        \pause{}Mergesort benötigt einen zusätzlichen Speicherplatz von \(\O(n)\), Quicksort ist in-place implementiert und benötigt lediglich \(\O(\log n)\) Speicherplatz zum Verwalten der rekursiven Aufrufe.
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Sortieralgorithmen zeichnen}
    \begin{exercise}<2->[Sortieralgorithmen zeichnen \Time{5}]
        \pause{}Veranschauliche den Sortierprozess der Zahlenfolge \(5,7,2,5,3,-19,6\) unter der Verwendung von \emph{Mergesort} grafisch.\pause{} Gib jeden Schritt aus.
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Sortieralgorithmen zeichnen]
        \pause{}Hier sind Split- und Mergephase wieder aufgespalten:\pause{}
\begin{center}
    \tikzset{block/.append style={rounded rectangle}}%
    \scalebox{0.75}{
    \begin{forest}
        for tree={inner sep=4pt,block,outer sep=1pt,execute at begin node={\strut}}
        [{\(5,7,2,5,3,-19,6\)}[{\(5,7,2,5\)}[{\(5,7\)}[5][7]][{\(2,5\)}[2][5]]][{\(3,-19,6\)}[3][{\(-19,6\)}[-19][6]]]]
    \end{forest}}\qquad~~\qquad\pause{}\scalebox{0.75}{
        \begin{forest}
            for tree={inner sep=4pt,block,outer sep=1pt,execute at begin node={\strut},grow=north}
            [{\(-19,2,3,5,5,6,7\)},iblock[{\(-19,3,6\)}[{\(-19,6\)}[6][-19]][3]][{\(2,5,5,7\)}[{\(2,5\)}[5][2]][{\(5,7\)}[7][5]]]]
        \end{forest}}
\end{center}
    \end{solve}
\end{frame}

\section{Dynamische Datenstrukturen}

\subsection{Listen}

\begin{frame}{Listen - Dynamische Arrays}
    \begin{itemize}[<+(1)->]
        \widei
        \item Für eine Implementation: Betrachte das \href{https://github.com/EagleoutIce/eidi-weihnachttsblatt-19_20}{Weihnachtsblatt}.
        \item Eine ArrayList ist die einfachste Implementation einer Liste.
        \item Wir halten intern ein Array, welches wir dynamisch vergrößern oder Verkleinern.
        \item Das Problem: Einfüge und Löschoperationen bedeuten einen großen Aufwand (kopieren der Elemente).
        \item Der Vorteil: Der Zugriff auf ein bestimmtes Element erfolgt (da ein Array zugrunde liegt) in \(\O(1)\).
    \end{itemize}
\end{frame}

% Ugly but still, i am lazy right now
\def\Element#1{%
    \begin{tabular}{|>{\centering}p{1em}|p{1em}|}
        \hline
            \strut#1 & \\
        \hline
    \end{tabular}%
}

\def\EndElement{
    \begin{tabular}{|>{\centering\arraybackslash}p{1em}|}
        \hline
            \strut/\\
        \hline
    \end{tabular}
}

\begin{frame}[fragile]{Listen - Einfach verkettete Liste}
    \renewcommand\arraystretch{1.35}%
    \begin{itemize}[<+(1)->]
        \widei
        \item Hier ist ein Datentyp als Objekt konstruiert, das eine Referenz auf das nächste Objekt besitzt.
        \item Das erste Element, das die Liste beginnt, bezeichnen wir als \emph{Head}, das Letzte, das auf einen definierten letzten Wert (wie \bjava{null}) zeigt, nennen wir \emph{Tail}/\emph{Foot}.
    \end{itemize}%
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Element {
    public int value;
    public Element next;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\begin{tikzpicture}[scale=0.7,every node/.style={transform shape}]
    \node[inner sep=0pt] (a) at (0,0) {\Element{4}};
    \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
    \node[inner sep=0pt] (c) at (4.5,0) {\Element{1}};
    \node[inner sep=0pt] (d) at (6.75,0) {\Element{3}};
    \node[inner sep=0pt] (e) at (9,0) {\EndElement};

    \foreach[remember=\i as \li (initially a)] \i in {b,c,d,e}{
        \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
        \fill ($(\li.east)+(-1em,0)$) circle (2pt);
    }

    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]a.south west) to[edge node={node[below=5pt] {head}}] ([xshift=3.75pt,yshift=-4pt]a.south east);
    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]d.south west) to[edge node={node[below=5pt] {foot}}] ([xshift=3.75pt,yshift=-4pt]d.south east);

\end{tikzpicture}
\end{minipage}
    \begin{itemize}[<+(1)->]
        \widei
        \item Doppelt verkettete Listen verbrauchen mehr Speicher und sind komplizierter (da zwei Verweise).
    \end{itemize}%
\end{frame}


\begin{frame}[fragile]{Listen - Einfach verkettete Liste}
    \begin{itemize}[<+(1)->]
        \item Vorteil einer einfach Verketten Liste:\pause{} Das Löschen und Hinzufügen neuer Elemente ist leicht (\(\O(1)\)).\pause{} Nachteil:\pause{} Der direkte Zugriff ist nur durch ein Traversieren möglich.
        \item Hinweis: Manche Operationen benötigen eine Sonderbehandlung im Falle einer leeren Liste.\pause{} So zum Beispiel das Einfügen.
        \item Betrachten wir einmal das Einfügen eines neuen Elements:
    \end{itemize}%
    \begin{multicols}{2}
\begin{enumerate}[<+(1)->]
    \widei
    \item \begin{tikzpicture}[scale=0.75,every node/.style={transform shape}]
            \node[inner sep=0pt] (a) at (0,0) {\Element{4}};
            \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
            \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
            \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

            \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
                \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
                \fill ($(\li.east)+(-1em,0)$) circle (2pt);
            }

            \node[inner sep=0pt] (e) at (4.5,1) {\Element{1}};

        \end{tikzpicture}
    \item \begin{tikzpicture}[scale=0.75,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{4}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};
        \node[inner sep=0pt] (e) at (4.5,1) {\Element{1}};

        \foreach[remember=\i as \li (initially a)] \i in {b}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[-Kite,densely dashed] ($(b.east)+(-1em,0)$) -- (c.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);


        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0.5,1) -- (e.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(e.east)+(-1em,0)$) -- (c.north);
        \fill ($(e.east)+(-1em,0)$) circle (2pt);

        \foreach[remember=\i as \li (initially c)] \i in {d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

    \end{tikzpicture}
    \item \begin{tikzpicture}[scale=0.75,every node/.style={transform shape}]
        \node[inner sep=0pt] (a) at (0,0) {\Element{4}};
        \node[inner sep=0pt] (b) at (2.25,0) {\Element{2}};
        \node[inner sep=0pt] (c) at (4.5,0) {\Element{3}};
        \node[inner sep=0pt] (d) at (6.75,0) {\EndElement};

        \node[inner sep=0pt] (e) at (4.5,1) {\Element{1}};

        \foreach[remember=\i as \li (initially a)] \i in {b}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0.5,1) -- (e.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(e.east)+(-1em,0)$) -- (c.north);
        \fill ($(e.east)+(-1em,0)$) circle (2pt);

        \foreach[remember=\i as \li (initially c)] \i in {d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }
    \end{tikzpicture}
\end{enumerate}
    \end{multicols}
\end{frame}


\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{LinkedList - insert}
    \begin{exercise}<2->[Einfach verkettete Liste - Einfügen\Time{5}]
        \pause{}Sei der folgende Code gegeben:\pause{}
\begin{plainjava}
class Element {
    public int value;
    public Element next;
    public Element(int value, Element next) {
        this.value = value; this.next = next;
    }
}
\end{plainjava}
        \pause{}Schreibe eine Methode \bjava{appendLast(Element root, int i)},\pause{} die ein neues \bjava{Element} mit Wert \(i\) an das Ende der Liste,\pause{} die durch den Kopf \bjava{root} gekennzeichnet wird, anhängt.
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[Einfach verkettete Liste - Einfügen]
        Die erste Methode behandelt den Sonderfall \say{leere Liste}. Die zweite traversiert die Liste so lange,\pause{} bis wir am \emph{Foot} angekommen sind und ersetzt dann den Verweis des vorletzten:\pause{}
\begin{plainjava}
public void appendLast(Element root, int i) {
    if(root == null) root = new Element(i, null);
    else appendLastIter(root, i);
}
\end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<2->[Einfach verkettete Liste - Einfügen\hfill{}(Fortsetzung)]
        Wir iterieren:
\begin{plainjava}
public void appendLastIter(Element current, int i){
    if(current.next == null) // found
        current.next = new Element(i, null);
    else appendLastIter(current.next, i);
}
\end{plainjava}
    \end{solve}
\end{frame}

\def\Element#1{%
    \begin{tabular}{|p{1em}|>{\centering}p{1em}|p{1em}|}
        \hline
            & \strut#1 & \\
        \hline
    \end{tabular}%
}

% NOTE: TODO: NOTE: gutes Beispiel: Undo & Redo, Vearbeitungsverlauf.
% Für doppelt verketteter Baum: GUI/Scene graph parent/child beziehung

\begin{frame}[fragile]{Listen - Doppelt verkettete Liste}
    \renewcommand\arraystretch{1.35}%
    \begin{itemize}[<+(1)->]
        \widei
        \item Mit einfach verketteten Listen können wir in \say{eine Richtung iterieren}.\pause{} Einen Vorgänger kann man damit nur sehr aufwändig bestimmen.
        \item Die doppelt verkettete Liste hält nun jeweils auch noch die Referenz auf das vorherige Element.
    \end{itemize}%
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Element {
    public int value;
    public Element next;
    public Element prev;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\begin{tikzpicture}[scale=0.7,every node/.style={transform shape}]
    \node[inner sep=0pt] (a) at (1.25*0,0) {\Element{4}};
    \node[inner sep=0pt] (b) at (1.25*2.25,0) {\Element{2}};
    \node[inner sep=0pt] (c) at (1.25*4.5,0) {\Element{1}};
    \node[inner sep=0pt] (d) at (1.15*6.75,0) {\EndElement};
    \node[inner sep=0pt] (e) at (-2.25,0) {\EndElement};

    \foreach[remember=\i as \li (initially a)] \i in {b,c}{
        \draw[-Kite] ($(\li.east)+(-1em,-4pt)$) -- ($(\i.west)+(0,-4pt)$);
        \fill ($(\li.east)+(-1em,-4pt)$) circle (2pt);

        \draw[-Kite] ($(\i.west)+(1em,4pt)$) -- ($(\li.east)+(0,4pt)$);
        \fill ($(\i.west)+(1em,4pt)$) circle (2pt);
    }

    \draw[-Kite] ($(c.east)+(-1em,0)$) -- ($(d.west)+(0,0)$);
    \fill ($(c.east)+(-1em,0)$) circle (2pt);

    \draw[-Kite] ($(a.west)+(1em,0)$) -- ($(e.east)+(0,0)$);
    \fill ($(a.west)+(1em,0)$) circle (2pt);

    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]a.south west) to[edge node={node[below=5pt] {head}}] ([xshift=3.75pt,yshift=-4pt]a.south east);
    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]c.south west) to[edge node={node[below=5pt] {foot}}] ([xshift=3.75pt,yshift=-4pt]c.south east);

\end{tikzpicture}
\end{minipage}
    \begin{itemize}[<+(1)->]
        \widei
        \item Den \say{Datentyp} einfach verkettete Liste gliedern wir in eine neue Klasse \bjava{LinkedList} aus, die auch die Operationen wie hinzufügen und löschen übernimmt.
    \end{itemize}%
\end{frame}


% Weitere Aufgabe mit toString()?

\subsection{Stacks \& Queues}

\begin{frame}{Datenstruktur: Stack}
    \hypertarget{mrk:Stack}{}%
    \begin{itemize}[<+(1)->]
        \item Ein Stack ist eine Datenstruktur, nach dem LIFO-Prinzip (Last-In, First-Out).\pause{} Es ist nur möglich Elemente oben auf den Stapel zu legen, oder das oberste zu nehmen.
        \item Stacks lassen sich als eine Liste implementieren,\pause{} die nur Zugriffe wie \bjava{appendLast(Element)} und \bjava{removeLast(Element)} zulässt.
        \item Stacks können bei der Auswertung arithmetischer Funktionien verwendet werden (siehe GdRa).
        \item Die Verwaltung rekursiver Methoden erfolgt über den Stack, so \say{überlagern} die Parameter im rekursiven Aufruf die alten, bis die Methode wieder verlassen wird.
        \item Auf Stacks sind zwei wichtige Operationen definiert: \begin{description}[push]
            \item[push] Legt das Element oben auf dem Stack ab.
            \item[pop] Entfernt das oberste Element und liefert es zurück.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Datenstruktur: Queue}
    \begin{itemize}[<+(1)->]
        \item Eine Warteschlange ist eine Datenstruktur, nach dem FIFO-Prinzip (First-In, First-Out).\pause{} Es ist nur möglich Elemente hinten in der Schlange einzureihen und vorne von der Schlange zu entfernen.
        \item Queues lassen sich als eine Liste implementieren,\pause{} die nur Zugriffe wie \bjava{appendFirst(Element)} und \bjava{removeLast(Element)} zulässt.
        \item Queues können zum Puffern verwendet werden (analog zum Schalter).
        \item Auf Queues sind zwei wichtige Operationen definiert: \begin{description}[dequeue]
            \item[enqueue] Reiht ein Element (hinten) in die Schlange ein.
            \item[dequeue] Nimmt ein Element (vorne) aus der Schlange.
        \end{description}
        \item Es existieren Derivate, wie die \emph{double-ended queue} (ein- und ausreihen auf beiden Seiten) oder die \emph{priority queue} (Elemente mit höherer Prioritöt werden bei \T{enqueue} zuerst aus der Schlange genommen).
    \end{itemize}
\end{frame}

\begin{frame}[c]{Vergleich: Stack und Queue}
    \begin{center}
        \begin{columns}
            \pause{}
            \begin{column}{.45\textwidth}
\centering\begin{tikzpicture}[scale=0.85,every node/.style={transform shape}]
    \draw (0,0) |- ++(3,-4) -- ++(0,4);
    \node at(1.5,-3.5) {42};
    \node at(1.5,-2.5) {13};
    \draw (0,-3) -- ++(3,0);
    \draw (0,-2) -- ++(3,0);

    \draw[Kite-] (3,-2.5) -- ++(1,0) node[right] {top};

    \draw[-Kite] (-0.5,0.25) node[left] {push} -| ++(1.75,-0.75);
    \draw[Kite-] (3.5,0.25) node[right] {pop} -| ++(-1.75,-0.75);

\end{tikzpicture}
            \end{column}
            \pause{}%
            \begin{column}{.45\textwidth}
\centering\begin{tikzpicture}[scale=0.85,every node/.style={transform shape}]
    \draw (0,0) -- ++(0,-4)++(3,0) -- ++(0,4);
    \node at(1.5,-2.5) {42};
    \node at(1.5,-1.5) {13};
    \draw (0,-3) -- ++(3,0);
    \draw (0,-2) -- ++(3,0);
    \draw (0,-1) -- ++(3,0);

    \draw[Kite-] (3,-2.5) -- ++(1,0) node[right] {head};
    \draw[Kite-] (3,-1.5) -- ++(1,0) node[right] {tail};

    \draw[-Kite] (-0.5,0.25) node[left] {enqueue} -| ++(1.75,-0.75);
    \draw[Kite-,overlay] (3.5,-4.25) node[right] {dequeue} -| ++(-1.75,0.75);

\end{tikzpicture}
            \end{column}
        \end{columns}
    \end{center}
\end{frame}

\subsection{Bäume}

\begin{frame}{Bäume: Formal}
    \begin{itemize}[<+(1)->]
        \item Im Gegensatz zu Listen halten Bäume referenzen auf mehrere Nachfolger.
        \item Ein Spezialfall von Bäumen sind Binärbäume, die maximal zwei Nachfolger haben können.
        \item Knoten erhalten verschiedene Bezeichner: \begin{description}
            \item[Wurzel] Ein Knoten ohne Vorgänger, der den Baum anführt. Ein Baum hat \emph{eine} Wurzel.
            \item[Blatt] Ein Blatt ist ein Knoten ohne Nachfolger.
            \item[Innerer] Ein innerer Knoten ist jeder Knoten der weder Blatt noch Wurzel ist.\pause{} Ein innerer Knoten hat genau einen Vater.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Bäume: Mathematisch}
    \begin{definition}[Baum]
Ein Baum \(B\) ist ein Tupel (azyklischer Graph) \(T = (V,E)\) mit einer endlichen Menge an Knoten \(V\) und einer Mente an Kanten \(E = V \times V\).\pause{} Die Kanten sind gerichtet und zwischen zwei Knoten darf nur eine Kante in eine Richtung existieren.\pause{} Weiter darf die Anzahl der eingehenden Kanten für jeden Knoten nur maximal \(1\) sein und kein Zyklus vorkommen.
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Ein Baum lässt sich auch als rekursive Datenstruktur auffassen.
        \item Hier ist jeder Knoten gleichzeitig die \say{Wurzel} eines Teilbaumes\pause{} der entweder leer sein (\(\widehat{=}\) Blatt)\pause{} oder noch weitere Knoten enthalten kann (\(\widehat{=}\) innerer Knoten).
        \item Jedem Knoten ordnen wir eine \emph{Ebene} zu. \pause{}Sie entspricht der Länge des Pfades von der Wurzel zum Knoten.\pause{} Der Wurzelknoten hat die Ebene \(1\).
    \end{itemize}
\end{frame}

\begin{frame}{Bäume: Mathematisch}
    \begin{itemize}[<+(1)->]
        \item Die Höhe des Baumes ist die tiefste Ebene auf der ein Knoten existiert.
        \item Die Verzweigung eines Knotens bezeichnet die Anzahl seiner Kinder.
        \item Binärbäume, bei denen alle Knoten einen Verzweigungsgrad von maximal zwei haben,\pause{} sind von einer besonderen Bedeutung für die Informatik.\pause{} (Sie lassen sich übrigens auch in einem Array repräsentieren.)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Bäume: Implementation}
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Node {
    public int value;
    public Node left;
    public Node right;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\scalebox{0.625}{\begin{forest}
    for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,edge=-Kite}
    [7[3[4[1][9]][,phantom]][6[1[,phantom][5]][3[,phantom][,phantom]]]]
\end{forest}}
\end{minipage}\vfill
    \begin{itemize}[<+(1)->]
        \item Wie bei einer einfach verketteten Liste können wir nun den Baum in eine Richtung traversieren.
        \item Analog zur doppelt verketteten Liste gibt es einen Binärbaum mit Verweis auf den Vaterknoten.
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Bäume: Implementation, II}
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Node {
    public Node father;

    public int value;
    public Node left;
    public Node right;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\scalebox{0.625}{\begin{forest}
    for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,edge=Kite-Kite}
    [7[3[4[1][9]][,phantom]][6[1[,phantom][5]][3[,phantom][,phantom]]]]
\end{forest}}
\end{minipage}\vfill
    \begin{itemize}[<+(1)->]
        \item Wie bei einer einfach verketteten Liste können wir nun den Baum in eine Richtung traversieren.
        \item Analog zur doppelt verketteten Liste gibt es einen Binärbaum mit Verweis auf den Vaterknoten.
    \end{itemize}
\end{frame}

\begin{frame}[c]{Traversierungsverfahren}
    \begin{center}\pause{}
    \begin{tikzpicture}[fakeblock/.style={rectangle,draw=btcd@color@black},fakesource/.style={midway, centered,minimum height=\baselineskip,execute at begin node={\strut}}]
        \draw[fakeblock] (0,0) rectangle ++ (3.5,0.65) node[fakesource] {Breitendurchlauf};
    \draw[fakeblock] (4,0) rectangle ++ (3.5,0.65) node[fakesource] {Tiefendurchlauf};
    \draw[fakeblock] (1.5,-1.5) rectangle ++ (2.5,0.65) node[fakesource] {Pre-Order};
    \draw[fakeblock] (4.5,-1.5) rectangle ++ (2.5,0.65) node[fakesource] {In-Order};
    \draw[fakeblock] (7.5,-1.5) rectangle ++ (2.5,0.65) node[fakesource] {Post-Order};
    \draw[-latex] (4+3.5/2,0) to[in=90,out=270] (2.75,-0.85);
    \draw[-latex] (4+3.5/2,0) to[in=90,out=270] (5.75,-0.85);
    \draw[-latex] (4+3.5/2,0) to[in=90,out=270] (8.75,-0.85);
    \draw[fakeblock] (1.5+0.25,-1.5) |- ++(2,-0.5) -- ++(0,0.5);
    \draw[fakeblock] (4.5+0.25,-1.5) |- ++(2,-0.5) -- ++(0,0.5);
    \draw[fakeblock] (7.5+0.25,-1.5) |- ++(2,-0.5) -- ++(0,0.5);

    \draw[fakeblock] (0+0.75,0) |- ++(2,-0.5) -- ++(0,0.5);
    \node at(0.1 + 1.65, -0.25) {\tiny Ebenen};

    \node at(0.1 + 1.65, 0.75) [above] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
            \draw (one) -- (two);
            \draw (one) -- (tre);
            \draw (two) -- (six);
            \draw (two) -- (sev);
            \draw (tre) -- (for);
            \draw (tre) -- (fiv);
            \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-latex] (one) -- (two);
            \draw[-latex] (two) -- (tre);
            \draw[-latex] (tre) -- (six);
            \draw[-latex] (six) -- (sev);
            \draw[-latex,scale=0.5,transform shape] (sev) -- (fiv);
            \draw[-latex] (fiv) -- (for);
        \end{scope}

    \end{tikzpicture}};


    \node at(1.6 + 1.15, -1.75) {\tiny root, left, right};
    \node at(1.6 + 1.15, -2.15) [below] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
        \draw (one) -- (two);
        \draw (one) -- (tre);
        \draw (two) -- (six);
        \draw (two) -- (sev);
        \draw (tre) -- (for);
        \draw (tre) -- (fiv);
        \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-latex] (one) -- (two);
            \draw[-latex] (two) -- (six);
            \draw[-latex] (six) to[bend left] (sev);
            \draw[-latex] (sev) to[out=85,in = 185,looseness=1.15] (tre);
            \draw[-latex] (tre) -- (fiv);
            \draw[-latex] (fiv) -- (for);
        \end{scope}
        %%DRAW DEFAULTS DENSLEY DOTTED IN GRAY TO KEEP STYLE
    \end{tikzpicture}};
    \node at(4.6 + 1.15, -1.75) {\tiny left, root, right};
    \node at(4.6 + 1.15, -2.15) [below] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
            \draw (one) -- (two);
            \draw (one) -- (tre);
            \draw (two) -- (six);
            \draw (two) -- (sev);
            \draw (tre) -- (for);
            \draw (tre) -- (fiv);
            \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-latex] (six) -- (two);
            \draw[-latex] (two) -- (sev);
            \draw[-latex] (sev) to[bend left] (one);
            \draw[-latex] (one) to[bend left] (fiv);
            \draw[-latex] (fiv) -- (tre);
            \draw[-latex] (tre) -- (for);
        \end{scope}

    \end{tikzpicture}};
    \node at(7.6 + 1.15, -1.75) {\tiny left, right, root};
    \node at(7.6 + 1.15, -2.15) [below] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
            \draw (one) -- (two);
            \draw (one) -- (tre);
            \draw (two) -- (six);
            \draw (two) -- (sev);
            \draw (tre) -- (for);
            \draw (tre) -- (fiv);
            \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-latex] (six) -- (sev);
            \draw[-latex] (sev) -- (two);
            \draw[-latex] (two) to[bend left] (fiv);
            \draw[-latex] (fiv) -- (for);
            \draw[-latex] (for) -- (tre);
            \draw[-latex] (tre) -- (one);
        \end{scope}

    \end{tikzpicture}};
    \end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}{Traversierung: Breitensuche}
    \begin{itemize}[<+(1)->]
        \item In der Breitensuche werden die Knoten Ebene für Ebene von links nach rechts besucht.
        \item \say{Besucht} steht hier für alle möglichen Varianten der Bearbeitung. Dies gilt auch für alle folgenden Traversierungen.
        \item Der folgende Baum veranschaulicht die Reihenfolge der Besuche:
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [1[2[4[8][9]][5[10][11]]][3[6[12][13]][7[14][15]]]]
        \end{forest}}
    \end{center}
\end{frame}

\begin{frame}{Traversierung: Pre-Order}
    \begin{itemize}[<+(1)->]
        \item Bei der Pre-Order Tiefensuche traversieren wir die Knoten über ihre Kinder.
        \item Mit der Pre-Order Strategie wird der aktuelle Knoten bearbeitet, dann rekursiv der linke, dann rekursiv der rechte Teilbaum.\pause{} (Analog gespiegelt)
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [1[2[3[4][5]][6[7][8]]][9[10[11][12]][13[14][15]]]]
        \end{forest}}
    \end{center}
\end{frame}


\begin{frame}{Traversierung: In-Order}
    \begin{itemize}[<+(1)->]
        \item Bei der In-Order Tiefensuche traversieren wir die Knoten über ihre Kinder.
        \item Mit der In-Order Strategie wird erst rekursiv der linke Teilbaum bearbeitet, dann der Knoten selbst und dann rekursiv der rechte Teilbaum.\pause{} (Analog gespiegelt)
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [8[4[2[1][3]][6[5][7]]][12[10[9][11]][14[13][15]]]]
        \end{forest}}
    \end{center}
\end{frame}

\begin{frame}{Traversierung: Post-Order}
    \begin{itemize}[<+(1)->]
        \item Bei der Post-Order Tiefensuche traversieren wir die Knoten über ihre Kinder.
        \item Mit der Post-Order Strategie wird erst rekursiv der linke, dann der rechte Teilbaum und erst dann der Knoten selbst bearbeitet.\pause{} (Analog gespiegelt)
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [15[7[3[1][2]][6[4][5]]][14[10[8][9]][13[11][12]]]]
        \end{forest}}
    \end{center}
\end{frame}

\begin{frame}{Suchbäume}
    \begin{itemize}[<+(1)->]
        \item Bäume können auch nützliche Datenstrukturen sein, wenn man sie \emph{ordnet}.
        \item So existieren Suchbäume (Alle Elemente im linken Teilbaum sind kleiner oder gleich der Wurzel, alle rechten größer \(\Rightarrow\) binäre Suche)
        \item Vergleiche hierzu auch die Datenstruktur \hyperlink{mrk:Heap}{Heap}.
        \item Die Traversierungsverfahren lassen sich auch auf Bäume mit höherem Verzweigungsgrad anwenden!
    \end{itemize}
\end{frame}

\begin{frame}{Arithmetische Bäume}
    \begin{itemize}[<+(1)->]
        \item Binärbäume helfen uns arithmetische Operationen darzustellen.
    \end{itemize}
    \pause{}
    \begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [*[+[A][B]][-[C][D]]]
        \end{forest}}
    \end{center}
    \begin{itemize}[<+(1)->]
    \item Die Traversierungsverfahren entsprechen Notationsschemata: \begin{description}[Post-Order]
        \item[In-Order] repräsentiert die geläufige Infix Notation: \((A + B) * (C - D)\) (die Klammern entsprechen der Ausführreihenfolge und sind natürlich nicht Teil)
        \item[Pre-Order] entspricht der Präfix-Notation: \(* + A B - C D\).
        \item[Post-Order] entspricht der Postifx-Notation: \(A B + C D - *\).
    \end{description}
    \end{itemize}
\end{frame}


\subsection{Graphen}

\begin{frame}{Graphen}
    \begin{itemize}[<+(1)->]
        \item Im Gegensatz zu Bäumen können in Graphen die Knoten auch mehrere Vorgänger haben.
    \end{itemize}
    \pause{}
    \begin{definition}[Ungerichter Graph]
        Ist ein Tupel \(G = (V,E)\) aus Knoten \(V\) und Kanten \(E \subset \binom{V}{2}\).
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Die Definitionen von Graphen sind bereits aus FG bekannt. Sie werden hier dennoch zusammengefasst.
    \end{itemize}
    \pause{}
    \begin{definition}[Gerichteter Graph]
        Ein gerichteter Graph definiert sich grundlegend identisch zum ungerichteten, unterscheidet sich aber in sofern, als dass die Kanten nicht durch Mengen sondern durch Tupel dargestellt, also gerichtet sind.
    \end{definition}
\end{frame}


\begin{frame}{Begriffe in einem Graphen}
    \pause{}
    \begin{description}[Zusammenhang]
        \item[Zusammenhang] ein Graph heißt zusammenhängend, wenn man jeden Knoten von jedem anderen aus (über die Kanten) erreichen kann.\pause{}
        \item[Weg] Ein Weg bezeichnet eine endliche Folge an Knoten die durch Kanten (egal welcher Richtung) verbunden sind.\pause{}
        \item[Pfad] Ein Pfad ist ein Weg, der die Kantenrichtung beachtet.\pause{}
        \item[Grad] bezeichnet die Anzahl an Knoten die mit einem Knoten verbunden sind.\pause{} Ist der Graph gerichtet so wird zwischen Eingangs- und Ausgangsgrad unterschieden.
    \end{description}
\end{frame}

\begin{frame}{Varianten von Graphen}
    \begin{itemize}[<+(1)->]
        \item Ein gewichteter Graph weißt den Kanten durch eine Abbildung \(w: E \to M\) einen Wert zu.
        \item Wir können einen Graphen durch eine \emph{Adjazenzmatrix} beschreiben.\pause{} Hierbei entsprechen die jeweiligen Zellen \(m_{i,j}\), dass eine Verbindung vom Knoten \(i\) zum Knoten \(j\) besteht.
    \end{itemize}
    \vfill\pause{}
    \begin{minipage}{0.45\linewidth}
\centering\begin{tikzpicture}[kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}]
    \node[kreis] (a) at (0,0) {1};
    \node[kreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
    \end{minipage}\quad\begin{minipage}{0.45\linewidth}
        \[\bordermatrix{~ & 1 & 2 & 3 & 4 \cr
        1 & 0 & 1 & 0 & 0\cr
        2 & 0 & 0 & 1 & 1\cr
        3 & 1 & 0 & 0 & 1\cr
        4 & 0 & 1 & 0 & 0 \cr
        }\]
    \end{minipage}
\end{frame}

\begin{frame}{Adjazenzlisten}
    \begin{itemize}[<+(1)->]
        \item Adjazenzlisten sind eine andere Variante Graphen zu repräsentieren.
        \item Hier hält jeder Knoten eine (verkettete) Liste an seinen benachbarten Knoten.
    \end{itemize}
    \vfill\pause{}
    \begin{minipage}{0.45\linewidth}
\centering\begin{tikzpicture}[kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}]
    \node[kreis] (a) at (0,0) {1};
    \node[kreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
    \end{minipage}\quad\begin{minipage}{0.45\linewidth}
        \begin{enumerate}
            \item \(\to 2\)
            \item \(\to 3 \to 4\)
            \item \(\to 1 \to 4\)
            \item \(\to 2\)
        \end{enumerate}
    \end{minipage}
\end{frame}

\begin{frame}{Algorithmen auf Graphen}
    \begin{itemize}[<+(1)->]
        \item Eine gängiges Problem ist es herauszufinden ob ein Graph Zyklen enthält und/oder ob er zusammenhängend ist.
        \item Wegfindungsproblem wie das kürzeste Wege Probleme (Routenfindung, \ldots), Traveling Salesman Problem
        \item Finden des minimalen, aufspannenden Baum.
        \item Exemplarisch betrachtet die Vorlesung die Breiten- und die Tiefensuche.
    \end{itemize}
\end{frame}

\begin{frame}{Graphen durchsuchen: Tiefensuche}
    \begin{itemize}[<+(1)->]
        \item In der Tiefensuche besucht man von einem Startknoten aus die anderen benachbarten Knoten und markiert diese.
        \item Dies wird solange vollzogen bis man auf einen bereits beobachteten Knoten trifft.
        \item In diesem Fall wird eine andere Kante besucht. Existiert keine mehr, so geht man zum letzten Knoten zuvor zurück und probiert die Ansätze dort erneut.
    \end{itemize}
    \vfill\pause{}
    \begin{multicols}{5}
        \scriptsize%
    \begin{enumerate}[<+(1)->]
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
    \node[ikreis] (a) at (0,0) {1};
    \node[kreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge[armark] (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[kreis] (c) at (2,-2) {3};
            \node[kreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge[armark] (d) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[kreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge[armark] (b) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[kreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge[armark] (c) (c) edge (a) (d) edge (b) (b) edge (d) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[ikreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge (d) (c) edge (d);
        \end{tikzpicture}
    \end{enumerate}
\end{multicols}
\end{frame}

\begin{frame}{Graphen durchsuchen: Breitensuche}
    \begin{itemize}[<+(1)->]
        \item In der Breitensuche besucht man von einem Startknoten aus erst alle benachbarten Knoten.
        \item In diesem Zuge merkt man sich die Nachbarn dieser Knoten uns besucht anschließend diese.
        \item Der Vorteil:\pause{} Wenn alle Kanten gleich Gewichtet sind lässt sich so direkt der kürzeste Weg identifizieren.
    \end{itemize}
    \vfill\pause{}
    \begin{multicols}{5}
        \scriptsize%
    \begin{enumerate}[<+(1)->]
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
    \node[ikreis] (a) at (0,0) {1};
    \node[okreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge[armark] (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[okreis] (c) at (2,-2) {3};
            \node[okreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge[armark] (d) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[okreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge[armark] (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[ikreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge[armark] (b) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[ikreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge (d) (c) edge (d);
        \end{tikzpicture}
    \end{enumerate}
\end{multicols}
\end{frame}

\subsection{Übungsaufgaben}

% TODO: Liste aufgaben, Baum Aufgaben und eine Aufgabe für binärbäume sowie suchbäume und so.. heap and STack..

\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{LinkedList - toString()}
    \begin{exercise}<2->[LinkedList - toString() \Time{4}]
        Gegeben sei folgender Code.\pause{} Es darf davon ausgegangen werden, dass \bjava{get(int)} korrekt implementiert ist.\pause{} Schreibe eine Methode \bjava{toString()} die die Elemente in korrekter Reihenfolge setzt.\pause{}
{\footnotesize
\begin{plainjava}
public class LinkedList {
    public static class Element {
        int value; Element next;
        public Element(int _v, Element _n) {
            value = _v; next = _n;
        }
    }
    Element head;
    public LinkedList() { /* ... */ }
    public Element get(int index) { /* ... */ }
}
\end{plainjava}
}
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[LinkedList - toString()]
        \pause{}
\begin{plainjava}
!*\onslide<3->*!public String toString() {
!*\onslide<4->*!    Element current = head;
!*\onslide<5->*!    String str_list = "";
!*\onslide<6->*!    while(current != null) {
!*\onslide<7->*!        str_list += current.value + ", ";
!*\onslide<8->*!        current = current.next;
!*\onslide<6->*!    }
!*\onslide<9->*!    return str_list;
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Theorie: Stack und Queue}
    \begin{exercise}<2->[Theoretisches zu Stapel und Warteschlange \Time{5}]
        Bewerte (wahr/falsch) und Begründe jeweils: \begin{enumerate}[<+(1)->]
            \item Eine Warteschlange lässt sich auch dann implementieren, wenn nur die Datenstruktur \emph{Stack} existiert.
            \item Stacks folgen dem FIFO-Prinzip.
            \item Der Java-(Objekt-)Heap bezeichnet sich nach der Datenstruktur Heap.
        \end{enumerate}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Theoretisches zu Stapel und Warteschlange]
        \begin{enumerate}[<+(1)->]
            \item Queue durch Stack:\pause{} Dies ist wahr. Hierzu benötigt man zwei Stacks, \(A\) und \(B\).\pause{} Neue Elemente werden auf \(A\) abgelegt und von \(B\) genommen.\pause{} Ist \(B\) leer, so werden alle Elemente von \(A\) genommen und auf \(B\) abgelegt (und damit umgedreht).
            \item Stacks sind FIFO:\pause{} Dies ist falsch.\pause{} Stacks folgen dem LIFO (Last-In, First-Out) Prinzip (siehe: \hyperlink{mrk:Stack}{Stack}).
            \item Java-Heap ist Heap:\pause{} Dies ist falsch, der Heap auf dem (komplexe) Daten abgelegt werden,\pause{} hat nur den selben Namen.\pause{} (Siehe: \url{https://stackoverflow.com/questions/756861/whats-the-relationship-between-a-heap-and-the-heap}.)
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Traversierung eines Baumes}
    \begin{exercise}<2->[Traversierung eines Baumes \Time{4}]
        Gegeben sei der folgende Binärbaum. Gib sowohl die Besuchsreihenfolge des Breitendurchlaufs als auch des In- und Post-Order Durchlaufs an.\pause{}
        \begin{center}
            \scalebox{0.6}{\begin{forest}
                for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,execute at begin node={\strut},minimum width=1.2cm}
                [A[B[,phantom][C[D][,phantom]]][E[F[,phantom][,phantom]][G[H][I]]]]
            \end{forest}}
        \end{center}
        \pause{}Hinweis: Das Ergebnis der Pre-Order Traversierung wäre: \(A,B,C,D,E,F,G,H,I\).
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Traversierung eines Baumes]
        \begin{center}
            \scalebox{0.5}{\begin{forest}
                for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,execute at begin node={\strut},minimum width=1.2cm}
                [A[B[,phantom][C[D][,phantom]]][E[F[,phantom][,phantom]][G[H][I]]]]
            \end{forest}}
        \end{center}
        \begin{enumerate}[<+(1)->]
            \item Breitendurchlauf:\pause{} \(A,B,E,C,F,G,D,H,I\).
            \item In-Order:\pause{} \(B,D,C,A,F,E,H,G,I\)
            \item Post-Order:\pause{} \(D,C,B,F,H,I,G,E,A\).
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{Traversierung eines Baumes - Java}
    \begin{exercise}<2->[Traversierung eines Baumes - Java \Time{4}]
        Es sei durch folgende Klasse ein Knoten eines Binärbaums notiert, der mit \bjava{Node root} beginnt.\pause{} Schreibe eine Funktion \bjava{inorder(Node)}, die eine In-Order Traversierung vornimmt.\pause{} Der Knoten soll (jeweils) einfach durch \bjava{System.out.println} ausgegeben werden.\pause{}
\begin{plainjava}
public class Node {
    public int value;
    public Node left, right;
    public Node(int _v) {
        /* ... */
    }
}
\end{plainjava}
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[Traversierung eines Baumes - Java]
\begin{plainjava}
void inorder(Node n)  {
    if (n == null) return;

    inorder(n.left);
    System.out.println(n.value);
    inorder(n.right);
}
\end{plainjava}
    \end{solve}
\end{frame}


\section{Java Advanced}

\subsection{Vererbung \& Abstraktion}

\begin{frame}{Das Konzept der Vererbung}
    \hypertarget{mrk:Vererbung}{}%
    \begin{itemize}[<+(1)->]
        \item Eine Klasse die von einer anderen Klasse erbt, übernimmt all ihre Eigenschaften und kann diese verändern oder modifizieren.
        \item Die Subklasse kann hier sowohl als Spezialisierung aufgefasst werden (die Eigenschaften und Operationen des Supertyps bleiben unverändert),\pause{} als auch als Erweiterung (die Methoden werden modifiziert).
        \item In Java/in der Objektorientierung wird das Konzept der Erweiterung verfolgt.
        \item Beispiel: Die Klasse \emph{Mensch} (Name) erbt von \emph{Lebewesen} (Alter, Größe),\pause{} wird erweitert durch \emph{Student} (Matrikelnummer), \emph{Dozent} (zugeteilte Vorlesung), \ldots
        \item Zwischen vererbenden Klassen gilt eine \emph{is-a} Relation.\pause{} So gilt Beispielsweise \emph{Student is-a Mensch is-a Lebewesen}.
    \end{itemize}
\end{frame}

\begin{frame}{Vererbung in Java}
    \begin{itemize}[<+(1)->]
        \item Vererbung wird in Java durch den Schlüsselbegriff \bjava{extends} realisiert.
        \item In Java kann eine Klasse nur von maximal einer anderen Erben.
        \item Auf Attribute der Mutterklasse die \bjava{private} sind,\pause{} können wir in erbenden Kindklassen nicht zugreifen.
        \item Der Konstruktor sowie Methoden der Superklasse können (soweit Sichtbar) durch \bjava{super} erreicht werden.
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Ein Beispiel in Java}
    \begin{itemize}[<+(1)->]
        \item Hinweis: Die Attribute sind lediglich exemplarisch und nicht wertend gemeint.
    \end{itemize}
    \pause{}\begin{center}
        \scriptsize%
        \begin{columns}
            \begin{column}{.42\textwidth}
\begin{plainjava}
class Lebewesen {
    int alter;
    float grosse;

    Lebewesen(int a, float g) {
        alter = a;
        groesse = g;
    }
}
\end{plainjava}
            \end{column}\pause{}
            \begin{column}{.5\textwidth}
\begin{plainjava}
class Mensch extends Lebewesen {
    String name;

    Mensch(int a, float g, String n) {
        super(a,g);
        name = n;
    }
}
\end{plainjava}
            \end{column}
        \end{columns}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Ein Beispiel in Java}
    \begin{itemize}[<+(1)->]
        \item<1-> Hinweis: Die Attribute sind lediglich exemplarisch und nicht wertend gemeint.
    \end{itemize}
    \pause{}\begin{center}
        \scriptsize%
        \begin{columns}
            \begin{column}{.49\textwidth}
\begin{plainjava}
class Student extends Mensch {
    long matrikelnummer;

    Student(int a, float g, String n,
            long m) {
        super(a,g,n);
        matrikelnummer = m:
    }
}
\end{plainjava}
            \end{column}\pause{}
            \begin{column}{.49\textwidth}
\begin{plainjava}
class Dozent extends Mensch {
    String vorlesung;

    Dozent(int a, float g, String n,
           String v) {
        super(a,g,n);
        vorlesung = v:
    }
}
\end{plainjava}
            \end{column}
        \end{columns}
    \end{center}
\end{frame}

\begin{frame}[fragile]{instanceof und getClass()}
    \begin{itemize}[<+(1)->]
        \item Das Prinzip erlaubt uns Polymorphie.\pause{} So ist folgender Code valide:\pause{}
\begin{plainjava}
Mensch herbert = new Student(19, 184.12f, "herbert", 123456789);
\end{plainjava}
        \pause{}da die Klasse \bjava{Student} von \bjava{Mensch} \emph{erbt}.\pause{} Wir können allerdings nicht auf die Zusatzfunktionalitäten von \bjava{Student} zugreifen.
        \item Ob \bjava{herbert} auch wirklich ein Student ist,\pause{} können wir mit \bjava{instanceof} prüfen:\pause{}
\begin{plainjava}
herbert instanceof Student // :yields: true
herbert instanceof Mensch // :yields: true
herbert instanceof Lebewesen // :yields: true
herbert instanceof Dozent // :yields: false
\end{plainjava}
    \end{itemize}
\end{frame}


\begin{frame}{Kommentare}
    \begin{itemize}[<+(1)->]
        \widei
        \item Das Prinzip der Vererbung ist integral für die Objektorientierung und unglaublich mächtig.
        \item Methoden der Superklasse lassen sich überladen (gleicher Name, andere Signatur),\pause{} als auch überschreiben (gleiche Signatur)
        \item Vererbung sollte nur dann verwendet werden,\pause{} wenn es sich wirklich um eine Erweiterung handelt und nicht wenn die Klasse nur die Eigenschaften (logisch) besitzt.\pause{} Beispiel: \bjava{Auto} sollte nicht von \bjava{Motor} erben, da es zwar einen besitzt, aber kein Motor ist.
    \end{itemize}
\end{frame}

\begin{frame}{Abstrakte Klassen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Vererbung ermöglicht uns Polymorphie erst wirklich.\pause{} So können wir eine Klasse \bjava{List} erschaffen (in Java: \bjava{AbstractList}, bereits vorhanden), die die Zugriffe definiert und entsprechend Klassen \bjava{ArrayList}, \bjava{LinkedList}, \ldots\pause{} die diese Operationen implementieren.
        \item Wenn diese Klassen (wie bei \bjava{List}) wirklich nur Blaupausen/Vorlagen sind,\pause{} können wir sie als \bjava{abstract} bezeichnen.\pause{} Von solchen Klassen darf kein Objekt erstellt werden,\pause{} von ihnen kann aber geerbt werden.
        \item Eine abstrakte Klasse kann weiter abstrakte Methoden (ohne Rumpf!) definieren.\pause{} Solche Methoden \emph{müssen} von einer nicht-abstrakten erbenden Klasse implementiert werden.
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Abstrakte Klassen, ein Beispiel}
\begin{plainjava}
!*\onslide<2->*!abstract class AbstractList {
!*\onslide<2->*!
!*\onslide<3->*!    // Für 'super()'
!*\onslide<3->*!    public AbstractList() { }
!*\onslide<2->*!
!*\onslide<4->*!    abstract void add(Element e);
!*\onslide<5->*!    int size() {
!*\onslide<5->*!        // ...
!*\onslide<5->*!    }
!*\onslide<2->*!
!*\onslide<6->*!    // ...
!*\onslide<2->*!}
\end{plainjava}
\end{frame}


\begin{frame}[fragile,c]{Abstrakte Klassen, ein Beispiel}
\begin{plainjava}
!*\onslide<2->*!abstract class ArrayList extends AbstractList {
!*\onslide<3->*!    Element[] elems;
!*\onslide<2->*!
!*\onslide<4->*!    public ArrayList() {
!*\onslide<5->*!        super();
!*\onslide<6->*!        elems = new Element[0];
!*\onslide<4->*!    }
!*\onslide<2->*!
!*\onslide<7->*!    public void add(Element e) {
!*\onslide<8->*!        // ...
!*\onslide<7->*!    }
!*\onslide<2->*!
!*\onslide<9->*!    // ...
!*\onslide<2->*!}
\end{plainjava}
\end{frame}


% \subsection{Bindungen in Java}

\begin{frame}[fragile]{Statische Bindung}
    \begin{itemize}[<+(1)->]
        \item Attribute werden Java \emph{statisch} und Methoden \emph{dynamisch} gebunden.
        \item Doch was bedeuten diese Bindungsarten: \begin{description}[dynamisch]
            \item[statisch] Nehmen wir an, wir haben zwei Klassen \bjava{A} und \bjava{B}, wobei \bjava{B} von \bjava{A} erbt.\pause{} Beide deklarieren die Variable \bjava{i}, in \bjava{A} wird sie auf \(32\), in \bjava{B} auf \(42\) gesetzt.\pause{} Es ergibt sich:
\begin{plainjava}
!*\onslide<+->*!A a = new A();
!*\onslide<+->*!B b = new B();
!*\onslide<+->*!A c = new B();
!*\onslide<+->*!System.out.println(a.i); // :yields: 32
!*\onslide<+->*!System.out.println(b.i); // :yields: 42
!*\onslide<+->*!System.out.println(c.i); // :yields: 32
            \end{plainjava}
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Dynamische Bindung}
    \begin{itemize}[<+(1)->]
        \item<1-> Attribute werden Java \emph{statisch} und Methoden \emph{dynamisch} gebunden.
        \item<1-> Doch was bedeuten diese Bindungsarten: \begin{description}[dynamisch]
            \item[dynamisch] Angenommen die Klasse \bjava{Mensch} hat die Methode \bjava{hallo()}, die einfach \say{Hallo ich bin ein Mensch} ausgibt.\pause{} \bjava{Student} überschreibt nun \bjava{hallo()} sie gibt nun \say{Hallo ich bin ein Student} aus.\pause{} Wir erhalten:\pause{} \begin{plainjava}
!*\onslide<+->*!Student a = new Student(/*...*/);
!*\onslide<+->*!Mensch b = new Mensch(/*...*/);
!*\onslide<+->*!Mensch c = new Student(/*...*/);
!*\onslide<+->*!a.hallo(); // :yields: Hallo ich bin ein Student
!*\onslide<+->*!b.hallo(); // :yields: Hallo ich bin ein Mensch
!*\onslide<+->*!c.hallo(); // :yields: Hallo ich bin ein Student
            \end{plainjava}
        \end{description}
    \end{itemize}
\end{frame}


\subsection{Interfaces}

% Wichtige Interfaces

% TODO: 'default', warum keine Attribute
\begin{frame}{Wenn Vererbung nicht reicht}
    \begin{itemize}[<+(1)->]
        \item Java erlaubt keine Mehrfachvererbung.\pause{} Allerdings gibt es Klassen die mehrere \say{Eigenschaften} erfüllen.
        \item So können wir über unsere Listen iterieren,\pause{} über Bäume aber auch.
        \item Deswegen kann eine Java Klasse (beliebig viele) Schnittstellen mittels \bjava{implements} implementieren.
        \item Ein solches \bjava{interface} kann von einer Klasse die es implementieren will Methoden fordern.
        \item Weiter kann ein \bjava{interface} seit Java \(8\) durch \bjava{default} Standardimplementationen für die Methoden liefern.
        \item Ein \bjava{interface} kann \emph{keine} Attribute definieren, diese werden automatisch zu Konstanten.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Wenn Vererbung nicht reicht}
    \begin{itemize}[<+(1)->]
        \item So gibt es zum Beispiel das Java-Interface \bjava{Iterable} welches anzeigt, dass man über den Datentyp (mittels \bjava{for}-each) iterieren kann.
        \item Da \emph{Generics} kein Teil der Vorlesung sind, wurde das Interface \emph{Sortable} definiert:\pause{}
\begin{plainjava}
public interface Sortable {
    boolean le(Sortable o); // '<='
    boolean lt(Sortable o); // '<'
    boolean eq(Sortable o); // '=='
}
\end{plainjava}
        \item Dies zeigt auch, wie man Interface-Bezeichnet wie (abstrakte) Klassen als Typanforderung liefern kann.\pause{} (Polymorphieeee)
    \end{itemize}
\end{frame}

\begin{frame}[fragile,c]{Interface Beispiel}
\begin{plainjava}
public class Element implements Sortable /*, interfaceB, ... */ {
    int value;
    Element next;

    // Nur als Beispiel:
    public boolean le(Sortable o) {
        return this.value <= ((Element)o).value;
    }

    // ...
}
\end{plainjava}
\end{frame}

\begin{frame}{Weitere Kommentare}
    \begin{itemize}[<+(1)->]
        \widei
        \item Auch für ein Interface wird die \emph{is-a} Relation durch \bjava{instanceof} erfüllt.
        \item Ein Interface wie \bjava{Sortable} wird in Java durch \bjava{Comparable} mit nur einer einzelnen Funktion \bjava{compareTo()} gelöst.
        \item Interfaces sollten dann verwendet werdenn wenn es um eine Funktionalität geht (wie \bjava{Drawable}, \bjava{Moveable}, \bjava{Consumeable}, \ldots)
        \item Das Implementieren eines Interfaces wird in UML durch eine gestrichelte, das Erweitern einer Klasse durch eine durchgezogene  Linie gekennzeichnet.% Pfeil am Ende?
    \end{itemize}
\end{frame}

\subsection{Fehlerbehandlungen}
\begin{frame}{Arten von Fehlern}
    \begin{itemize}[<+(1)->]
        \widei
        \item Wir unterscheiden zwei Arten von Fehlern: \begin{description}[Schwere]
            \item[Schwere] solche Fehler sind kritisch sollen zu einem Programmabbruch führen.
            \item[Leichte] solche Fehler können (zur Laufzeit) korrigiert werden.
        \end{description}
        \item Wie schwer ein Fehler ist, hängt von der Situation ab.
        \item Die Behandlung eines Fehlers erfolgt in der Regel durch die aufrufende Methode.
        \item Ein Fehlerobjekt wird nur dann erzeugt,\pause{} wenn die Methode scheitert.
        \item Fehlerobjekte sind in Java Objekte von Klasse,\pause{} die von der \bjava{Exception} Klasse erben.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Arten von Fehlern}
    \begin{itemize}[<+(1)->]
        \widei
        \item Eine \emph{explizite} Ausnahme können wir mittels \bjava{throw} werfen.
        \item Eine \emph{implizite} Ausnahme wird von der Java Virtual Machine geworfen\pause{} (Division durch Null, Zugriff auf \bjava{null}, \ldots)
        \item Wir werfen eine explizite Ausnahme/einen Error (allgemein: ein \bjava{Throwable}): \pause{}
\begin{plainjava}
throw new IndexOutOfBoundsException();
\end{plainjava}
        \item Wird eine Ausnahme nicht behandelt,\pause{} bricht das Programm ab.
        \item Java-Errors wie \bjava{InternalError}  lassen sich nicht sinnvoll behandeln!
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Behandeln von Fehlern}
    \begin{itemize}[<+(1)->]
        \widei
        \item Um einen Fehler zu behandeln, bietet Java das \bjava{try-catch}-Konstrukt
\begin{plainjava}
try {
    // Anweisungen, Methodenaufrufe, :ldots:
} catch(:lan:FehlerKlasseA:ran: :lan:Bezeichner:ran:) {
    // Behandle Fehler der Klasse :lan:FehlerKlasseA:ran:
} catch(:lan:FehlerKlasseB:ran: :lan:Bezeichner:ran:) {
    // Behandle Fehler der Klasse :lan:FehlerKlasseB:ran:
} finally {
    // Anweisungen die immer ausgeführt werden.
}
\end{plainjava}
        \item Das \bjava{finally} ist optional, auch kann nur ein \bjava{catch}-Block auftreten.
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Behandeln von Fehlern}
    \begin{itemize}[<+(1)->]
        \widei
        \item bei mehreren \bjava{catch}-Blöcken wird von oben nach unten ein passender gesucht.\pause{} Erben die Fehler also voneinander (so wie alle von \bjava{Exception}),\pause{} sollten die \say{allgemeineren} weiter unten stehen.
        \item Beispiel:\pause{}
\begin{plainjava}
try {
    System.out.println(42 / 0);
} catch (ArithmeticException ex) {
    // Behandlung
    System.err.println("Division durch 0!");
    ex.printStackTrace();
}
\end{plainjava}
    \end{itemize}
\end{frame}


\subsection{Übungsaufgaben}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Statische/Dynamische Bindung}
    \begin{exercise}<2->[Statische/Dynamische Bindung \Time{4}]
        Erkläre kurz den Unterschied zwischen statischer und dynamischer Bindung und wann Java was verwendet.
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Statische/Dynamische Bindung]
        Die \emph{statische} Bindung verwendet Java bei Attributen. Sie wird zur Kompilierzeit aufgelöst und sorgt dafür, dass in Subklassen überschriebene Variablen stets die Klasse der Variable, die auf das Objekt zeigt bestimmt welche Ausprägung des Attributs verwendet wird.\medskip\newline%
        \pause{}Die \emph{dynamische} Bindung verwendet Java bei Methoden. Sie wird zur Laufzeit aufgelöst und bedeutet, dass im Falle des Überschreibens von Methoden einer Subklasse die Klasse des Objekts entscheidet welche verwendet wird und nicht die der Variable die darauf zeigt.
    \end{solve}
\end{frame}


\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Suche syntaktischer Fehler, V}
    \begin{exercise}<2->[Fehler finden, V \Time{4}]
        \pause{}Finde und korrigiere alle (syntaktischen und semantischen) Fehler:\pause{}
{\footnotesize
        \begin{plainvoid}
public class A {
    private static final class B extends A {
        public B() {
            super(this);
        }
    }

    public A(A other){}
    public abstract class C extends A.B {
        protected abstract boolean _$get$(String);
    }
}
        \end{plainvoid}
}
    \end{exercise}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \begin{solve}<2->[Fehler finden, V]
        \pause{}\footnotesize\begin{plainjava}
public class A {
    private static class B extends A {
        public B() {
            super(null);
        }
    }

    public A(A other){}
    public abstract class C extends A.B {
        protected abstract boolean _$get$(String a);
    }
}
        \end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<1->[Fehler finden, V\hfill{}(Fortsetzung)]
        \begin{enumerate}
            \item Das \bjava{final} ist an sich nicht Falsch, dann kann aber \bjava{C} nicht mehr von \bjava{B} erben.
            \item Der Bezeichner \bjava{this} darf nicht innerhalb eines Konstruktoraufrufs verwendet werden.
            \item In der Methode \bjava{_$get$} genügt nicht die Signatur,\pause{} Java erwartet (nicht-bindende) Variablenbezeichner.
        \end{enumerate}
        \pause{}\textit{Hinweis:}\pause{} Die Dollarzeichen sind kein Fehler,\pause{} aber es ist Konvention sie nicht zu verwenden (Java verwendet sie intern für zum Beispiel generierten Code).
    \end{solve}
\end{frame}


\begin{frame}\relax
    \usebeamercolor{title}%
    \vskip1em
    {\centering\usebeamerfont{title}\MakeUppercase{Ein Wort zum Abschluss}\par}
    \vfill
    \begin{center}
        \footnotesize\begin{minipage}{0.95\linewidth}
Wie bereits gesagt erhebt dieses Dokument keinen Anspruch auf Vollständigkeit und sieht sich vermutlich auch weiteren Aktualisierungen unterworfen. Eine aktuelle Variante sollte es hier geben: \url{https://github.com/EagleoutIce/eidi-pseudo-rep}.
\begin{center}
    Bei Anregungen oder Verbesserungsvorschlägen einfach melden!\\
\end{center}
Zum Ende dann wohl noch ein bisschen Meta-Gequatsche. Dieses Dokument ergründet sich auf Basis wundervoller \immediate\write18{wc -l < eidi-tutorium-rep.src > \jobname.cmd.tmp}\input{\jobname.cmd.tmp}(für die Ausgabe relevanter) Zeilen und Summa Summarum \immediate\write18{wc -m < eidi-tutorium-rep.src > \jobname.cmd.tmp}\input{\jobname.cmd.tmp}Zeichen einiger Zeit und Arbeit die in es geflossen ist. Ich hoffe die war es auch wert!\newline\hbox{}\hfill {\tiny Florian Sihler, \href{mailto:florian.sihler@uni-ulm.de}{florian.sihler@uni-ulm.de}}\\
\begin{center}
    \say{Viel Spaß beim Lernen und natürlich viel Erfolg!}
\end{center}
        \end{minipage}
    \end{center}
    \vfill\hbox{}
\end{frame}

% TODO: korrektheitsbeweis?

% Erkläre Begriffe wie Debugger, IDE, ... Korrektheitsbeweise
% TODO: Foliensatz 06
% TODO: bei Klassen enums
% TODO: bei Übersicht: andere Programmeirsprachen
% TODO: cofindg
% Bei klassen und Arrays nochmalauf POinter eignehen
% Method with final
% TODO: For in while und umgekehrt?
\end{document}