\section{Theoretische Grundlagen}
\subsection{Der Algorithmusbegriff}
\begin{frame}{Was ist ein Algorithmus?}
    \begin{definition}<2->[Algorithmus]
        \onslide<3->{Eine \emph{eindeutige} Handlungsvorschrift zur Lösung eines Problems.}
    \end{definition}
    \begin{itemize}
        \widei
        \item<4-> Es existieren verschiedene Darstellungsformen:\medskip
\begin{center}
\color{gray}\SetKwIF{If}{ElseIf}{Else}{Ist}{tue:}{}{sonst:}{}%
\RestyleAlgo{tworuled}%
\onslide<5->{\parbox[5em]{.29\linewidth}{\footnotesize
(1) Wenn der \textit{Wert} 42 übersteigt, (2) soll A ausgeführt werden.
Ansonsten soll (3) B durchgeführt werden.}}\quad
\onslide<6->{\parbox[5em]{.29\linewidth}{\centering\footnotesize
\scalebox{.825}{\begin{tikzpicture}[rounded corners=1pt,yscale=.8]
    \node[iblock] (0) at(0,0) {Wert > 42};
    \node[block] (1) at(1.35,-1) {Mache A};
    \node[block] (2) at(1.35,-2) {Mache B};
    \draw[-Kite] (0) |- (1);
    \draw[-Kite] (0) |- (2);
\end{tikzpicture}}}}\quad
\onslide<7->{\parbox[5em]{.29\linewidth}{\footnotesize
\begin{algorithm}[H]
    \footnotesize\PreCode
    \StartCode
    \eIf{Wert > 42}{Mache A\;}{Mache B\;}
\end{algorithm}}}\medskip\par
\color{black}\onslide<5->{\parbox{.29\linewidth}{\centering Textuell\par}}\quad\onslide<6->{\parbox{.29\linewidth}{\centering Grafisch\par}}\quad\onslide<7->{\parbox{.29\linewidth}{\centering Pseudocode\par}}
\end{center}\medskip
        \item<8-> Klassische Alltagsbeispiele: (Koch-)Rezepte, Gebrauchsanleitungen, \ldots
    \end{itemize}
\end{frame}

\subsection{Algorithmen analysieren}
\begin{frame}{Algorithmuseigenschaften}
    \begin{itemize}[<+(1)->]
        \widei
        \item Zu Beginn gilt es einige \imp{Begriffe} zu klären: \begin{description}[Elementaroperation]
            \item[Prozess] Die Ausführung der Schritte eines Algorithmus.
            \item[Prozessor] Der Ausführende (Mensch, Computer,~\ldots).
            \item[Elementaroperation] Eine einzelne, eindeutige Handlung.
        \end{description}
        \item Ein Algorithmus besitzt einige grundlegende \imp{Eigenschaften}: \begin{description}[Ausführbarkeit]
            \item[Ausführbarkeit] Die Anleitung muss ausführ- und reproduzierbar sein.
            \item[Endlichkeit] Er muss mit endlich viel Text beschreibbar sein.
            \item[Verarbeitung] Ein Algorithmus erhält Eingabedaten \(E\), hält lokale Daten \(D\) und erzeugt Ausgabedaten \(A\).
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}[c]{Eigenschaften für die Analyse}
    \twosplit{%
    \begin{block}<2->{Termination}
        \onslide<3->{Ein Algorithmus terminiert, wenn er nach endlich vielen \vphantom{g}Schritten zum Ende \vphantom{g}kommt.}
    \end{block}\bigskip
    }{%
    \begin{block}<4->{Partielle Korrektheit}
        \onslide<5->{Wenn der Algorithmus für eine korrekte Eingabe terminiert, ist die erzeugte Ausgabe korrekt.}
    \end{block}
    % \begin{block}<4->{Robustheit}
    %     \onslide<5->{Ein Algorithmus ist (maximal) robust, wenn er falsche Eingaben erkennen und abfangen kann.}
    % \end{block}\bigskip
    }
    \begin{center}
        \begin{minipage}{.5\linewidth}
            \begin{block}<6->{Totale Korrektheit}
                \onslide<7->{Der Algorithmus terminiert und ist partiell korrekt.}
            \end{block}
        \end{minipage}
    \end{center}
\end{frame}

\begin{frame}{Eigenschaften für die Analyse, II}
    \twosplit{%
    \begin{block}<2->{Determinismus}
        \onslide<3->{Der Ablauf ist \emph{eindeutig}. Jeder Anweisung folgt (bei gleichen Voraussetzungen) die selbe.}
    \end{block}
    }{%
    \begin{block}<4->{Determiniertheit}
        \onslide<5->{Dieselben Eingabedaten erzeugen immer dieselben Ausgabedaten.}
    \end{block}
    }\bigskip
    \begin{itemize}
        \item<6-> Die Begriffe sind zu unterscheiden!
        \item<7-> Es können verschiedene Wege zum selben Ziel führen.
        \item<8-> (Sinnfreies) Beispiel: \onslide<9->{Der Algorithmus kann jedes Element eines Arrays quadrieren. Die Reihenfolge wählt er zufällig aus!}\smallskip\par
        \onslide<10->{\faAngleRight~Dieser Algorithmus \emph{determiniert}, \onslide<11->{ist aber \emph{nicht-deterministisch}!}}
    \end{itemize}
\end{frame}


\begin{frame}{Schema eines Algorithmus}
    \pause\begin{center}
        \begin{tikzpicture}
            \node[block] (A) at(0,0) {Algorithmus};
            \node (V) at(-5,0) {Vorbedingung};
            \node (N) at(5,0) {Nachbedingung};
            \draw[link] (V) edge (A) (A) edge (N);
        \end{tikzpicture}
    \end{center}
    \begin{itemize}[<+(1)->]
        \widei
        \item Ein Algorithmus benötigt (formal) eine: \begin{itemize}
            \item Vorbedingung \textcolor{gray}{(wie \say{positive ganze Zahl})}
            \item Nachbedingung \textcolor{gray}{(wie \say{negative Fließkommazahl})}
        \end{itemize}
        \item Algorithmen fundieren oft auf einem Problem der realen Welt und bedienen sich Mechaniken, wie der Abstraktion, zur Lösung.
        \item (Java-)Programme sind eine Darstellungsform von Algorithmen.\par\pause{}
              Diese kann von Maschinen interpretiert und ausgeführt werden.
     \end{itemize}
\end{frame}

\begin{frame}[c]{Schema eines Algorithmus, II}
    \centering\smallskip\onslide<2->{%
\scalebox{.7}{\begin{tikzpicture}[yscale=1.1,block/.append style={minimum width={3.5cm}}]
    \onslide<2->{\node[block] at (0,0) (PM)  {Problem};}
    \onslide<3->{\node[block] at (0,-3) (AL)  {Algorithmus};}
    \onslide<4->{\node[block] at (0,-5) (PR)  {Programm};}
    \onslide<5->{\node[block] at (0,-7) (MA)  {Maschine};}
    \onslide<3->{
        \draw[link] (PM) -- (AL);
        \pgfinterruptboundingbox
        \node[left=.5cm] at (0,-1.5) {Abstraktion};
        \node[right,align=left,text width=5.5cm] at (.5,-1.45) {\begin{itemize}
            \item Problemanalyse
            \item Funktionale\par Spezifikation
            \item Algorithmenentwurf
        \end{itemize}
        };
        \endpgfinterruptboundingbox
    }
    \onslide<4->{
        \draw[link] (AL) -- (PR);
        \pgfinterruptboundingbox
        \node[left=.5cm] at (0,-4) {Implementierung};
        \node[right,align=left,text width=5.5cm] at (.5,-3.85) {\begin{itemize}
            \item Darstellung in\par Programmiersprache
        \end{itemize}
        };
        \endpgfinterruptboundingbox
    }
    \onslide<5->{
        \draw[link] (PR) -- (MA);
        \pgfinterruptboundingbox
        \node[left=.5cm] at (0,-6) {Realisierung};
        \node[right,align=left,text width=5.5cm] at (.5,-5.85) {\begin{itemize}
            \item Umsetzung in\par Maschinenbefehle
        \end{itemize}
        };
        \endpgfinterruptboundingbox
    }
\end{tikzpicture}}}
\end{frame}

\subsection{Konzeptionalisierung}
\begin{frame}{Wie ein Programm entsteht}
    \begin{itemize}[<+(1)->]
        \widei
        \item Ein Programm fällt nicht aus den Wolken (leider).
        \item Im Softwareengineering gliedert man den Prozess meist in sechs Phasen.
        \item Die sechste Phase (Dokumentation) läuft dabei parallel zu den anderen.
        \item Die Dokumentation bezeichnet nicht nur die exakte Beschreibung aller für die Umsetzung notwendiger Komponenten,\pause{} sondern schließt auch Beschreibungen des Codes,\pause{} sowie des Ablaufs selbst mit ein!
    \end{itemize}
\end{frame}

\begin{frame}[c]{Wie ein Programm entsteht, II}
\begin{center}
    \resizebox{.95\linewidth}{!}{%
    \begin{tikzpicture}
        \onslide<2->{\node[iblock,minimum width=3cm] (init) at (-5.5,0) {Problem};}
        \foreach[count=\i,remember=\i as \li (initially init)] \l in {Analyse, Entwurf, Implementierung, Test \& Revision} {
            \pgfmathsetmacro\ovlskip{int(\i+2)};
            \onslide<\ovlskip->{
            \node[block,minimum width=5cm] (\i) at(0,-1.6*\i+1.6) {\l};
            \node[right,gray] at (\i.west) {\i.};
            \draw[link] (\li) -- (\i);}
        }
        \onslide<3->{
            \node[above right=0.75cm,yshift=-.5cm,align=left,font=\scriptsize,text width=4.25cm] (d1) at (1.north east) {Untersuche Problem (in der Regel in Zusammenarbeit mit Nicht-Informatikern).};
            \draw[densely dashed] (d1.west) -- (1.east);
        }
        \onslide<4->{
            \node[above right=0.75cm,yshift=-1cm,align=left,font=\scriptsize,text width=4.25cm] (d2) at (2.north east) {Entwickle Algorithmus. Kreativer Prozess (Beantwortet auch Fragen wie: \say{Gibt es das schon?})};
            \draw[densely dashed] (d2.west) -- (2.east);
        }
        \onslide<5->{
            \node[right=0.75cm,align=left,font=\scriptsize,text width=4.25cm] (d3) at (3.north east) {Übersetze Algorithmus in Programmiersprache};
            \draw[densely dashed] (d3.west) -- (3.east);
        }
        \onslide<6->{
            \node[left=0.75cm,yshift=.25cm,align=right,font=\scriptsize,text width=4.25cm] (d4) at (4.north west) {Prüft das Programm auf (logische und technische) Fehler.\\[0.25em] Diese Phase kann im Allgemeinen nur die Anwesenheit und nicht die Abwesenheit von Fehlern aufzeigen.};
            \draw[densely dashed] (d4.east) -- (4.west);
        }
        \onslide<7->{
            \node[block,minimum width=5cm] (7) at(0,1.6) {Dokumentation};
            \node[right,gray] at (7.west) {6.};
        }
        \onslide<8->{
            \node[iblock,minimum width=3cm] (exit) at (5.5,-3*1.6) {Programm};
            \node[below,gray,scale=.9] at (exit.south) {5. Wartung};
            \draw[link] (4) -- (exit);
        }\onslide<1->{}
    \end{tikzpicture}}
\end{center}
\end{frame}

% #region Übungsaufgaben
\fullsubsection{Übungsaufgaben}
\ifull
\begin{frame}[c]{Übungsaufgabe}
    \Task{Algorithmus beschreiben}
    \begin{exercise}<2->[Algorithmus beschreiben \Time{2}]
        \onslide<3->{Beschreiben Sie einen Algorithmus, der das maximale Element einer Datenmenge bestimmt.}\par
        \onslide<4->{\textit{Hinweis:} Auf den Elementen muss keine \say{numerische} Ordnung definiert sein. Sie können aber vergleichen, ob ein Element größer als ein anderes ist.}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Algorithmus beschreiben]
        \pause{}Wir betrachten den textuellen Ansatz: \begin{enumerate}[<+(1)->]
            \item Keine Eingabedaten? \(\to\) Fertig.
            \item Setze Maximum auf erstes Element der Eingabedaten.
            \item Tue für jedes weitere Element der Eingabedaten: \begin{enumerate}
                \item Ist das zu betrachtende Element \say{größer} als das bisherige Maximum? \begin{description}[iNein]
                    \item[Ja] Ersetze Maximum durch dieses Element.
                    \item[Nein] Tue nichts.
                \end{description}
            \end{enumerate}
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c,fragile]{Übungsaufgabe}
    \Task{Charakteristika eines Algorithmus}
    \begin{exercise}<2->[Charakteristika \Time{2}]
        \onslide<3->{Ist der folgende Algorithmus für die Berechnung des Modulo \(a \bmod b\) (total) korrekt?}
        \begin{plainjava}
!*\onslide<4->*!public static int simpleMod(int a, int b){
!*\onslide<4->*!    while(a >= b)
!*\onslide<4->*!        a -= b;
!*\onslide<4->*!    return a;
!*\onslide<4->*!}
        \end{plainjava}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Charakteristika]
       \pause{}Der Algorithmus ist nicht total korrekt.\pause{} So liefert er für ein negatives \T{b} kein korrektes Ergebnis,\pause{} da hier \T{a -= b} zu einem Überlauf führt (bis dahin ist stets \bjava{a >= b}). Weiter terminiert er nicht für ein \(b = 0\) mit einem \(a > 0\) (da dann von \(a\) immer nur \(0\) abgezogen wird, was es nicht weiter verkleinert).\medskip\par
       \pause{}Ferner ist er auch nicht partiell korrekt.\pause{} So liefert er für ein negatives \T{a} bei einem positiven \T{b} einfach nur \T{a} zurück.
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Korrektheitsbeweis}
    \begin{exercise}<2->[Korrektheitsbeweis \Time{4}]
        Zeigen Sie die totale Korrektheit des folgenden Algorithmus:\smallskip\par
\onslide<3->{%
\begin{algorithm}[H]
    \PreCode
        \KwIn{$a, b, c \in \mathbb{N}$}
        \KwOut{Minimum of $a, b, c$}
    \StartCode
        $elems := (a, b, c)$\;
        $min := a$\;\label{alg:ex-min1}
        \ForEach{elem \textbf{in} elems}{\label{alg:ex-fe1}%
            \lIf{$elem < min$}{
                $min := elem$
            }
        }
        \KwRet{min}\;
    \caption{Finden des Minimum}
\end{algorithm}}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Korrektheitsbeweis]
       \pause{}Wir zeigen die Termination und die partielle Korrektheit getrennt: \begin{itemize}[<+(1)->]
           \item Das for-each aus Zeile~\ref{alg:ex-fe1} endet sicher nach drei Durchläufen. Es gibt keine weiteren Sprünge (wie Rekursion,~\ldots): der Algorithmus \emph{terminiert} für alle \(a, b, c \in \mathbb{N}\).
           \item Hier kann man alle Fälle \(a = b = c\), \(a > b = c\),~\ldots\ einzeln prüfen. Sonst: \begin{itemize}
             \item \(a = \min\{a, b, c\}\) so initialisiert Zeile~\ref{alg:ex-min1} \(min\) schon korrekt, \(b \geq a\) und \(c \geq a\).
             \item \(b = \min\{a, b, c\}\) so überschreibt Zeile~\ref{alg:ex-fe1} \(min\) für \(b\), da \(b \leq a\) und \(c \geq b\).
             \item \(c = \min\{a, b, c\}\) so überschreibt Zeile~\ref{alg:ex-fe1} \(min\) für \(c\), da \(c \leq a\) und \(b \geq c\).
           \end{itemize}
       \end{itemize}
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Determinismus und Determiniertheit}
    \begin{exercise}<2->[Deterministische Determiniertheit \Time{2}]
        \pause{}Nennen Sie je ein Beispiel für einen Algorithmus der:
        \begin{enumerate}[<+(1)->]
            \item[i)] nicht-deterministisch ist und determiniert.
            \item[ii)] sowohl deterministisch ist, als auch determiniert.
        \end{enumerate}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Deterministische Determiniertheit]
        \pause{}\begin{enumerate}[<+(1)->]
            \item[i)] Suche, ob ein Element in den Eingabedaten vorkommt.\pause{} Die Elemente werden in einer zufälligen Reihenfolge verglichen.
            \item[ii)] Ein Algorithmus der eine Zahl verdoppelt, indem er sie mit \(2\) multipliziert.
        \end{enumerate}
    \end{solve}
\end{frame}
\fi
% #endregion