\section{Weiterführende Konzepte}
\subsection{Suchverfahren}

\begin{frame}{Suchverfahren formal}
    \begin{itemize}[<+(1)->]
        \widei
        \item Ein Suchverfahren hat die Aufgabe in einer Folge an Elementen,\pause{} die Elemente zu finden, welche einem Muster oder gewissen Eigenschaften entsprechen.
        \item Es gibt zwei Varianten von Suchverfahren: \begin{description}[Heuristisch]
            \item[Einfach] Durchlaufen Suchraum auf Basis einer Datenstruktur.
            \item[Heuristisch] Besitzen zusätzliches Wissen (Sortierung,~\ldots) über die Daten die sie zur Beschleunigung der Suche verwenden.
        \end{description}
        \item Die \emph{Eigenschaften} nach denen gesucht werden soll, kann man auch als \emph{Merkmale} bezeichnen.
    \end{itemize}
\end{frame}

\begin{frame}{Klassische Suchverfahren}
    \begin{itemize}[<+(1)->]
        \widei
        \item Uns sind zwei Verfahren bekannt, Elemente zu suchen: \begin{description}[Linear]
            \item[Linear] Die lineare/naive/sequentielle Suche beginnt am Anfang der Folge und prüft Element für Element ob es sich um das gesuchte handelt.\pause{} Die Komplexität beträgt \(\O(n)\).
        \end{description}
        \vfill
        \begin{center}
\onslide<5->{\begin{tikzpicture}
    \foreach[remember=\i as \li(initially 0)] \i in {1,...,10}{
        \ifnum\i=6
            \node[inner sep=4.35pt,iball,double,outer sep=2pt] (\i) at(\i,0) {};
        \else
            \node[inner sep=4pt,ball,outer sep=2pt] (\i) at(\i,0) {};
        \fi
        \ifnum\i>1
            \draw (\li.east) -- (\i.west);
        \fi
    }
    \onslide<+->{
        \foreach[remember=\i as \li (initially 1)] \i in {2,...,6}{
            \draw[-Kite] (\li.80) to[bend left] (\i.100);
        }
    }
\end{tikzpicture}}
        \end{center}
        \vfill\hbox{}
    \end{itemize}
\end{frame}

\ifull
\begin{frame}[c]{Lineare Suche}
    \Task{Die lineare Suche}
    \begin{exercise}<2->[Lineare Suche \Time{4}]
        \pause{}Schreiben Sie eine Methode \bjava{int linearSearch(int[], int)}, die ein Array mit der linearen Suche nach einem gegebene Schlüssel durchsucht und den (ersten) Index des Schlüssels zurückliefert.
        Wird der Schlüssel nicht gefunden, so soll die Methode einen negativen Wert zurückliefern.
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Lineare Suche -- Lösung}
    \begin{solve}<2->[Lineare Suche]
\begin{plainjava}
!*\onslide<3->*!int linearSearch(int[] sequence, int key){
!*\onslide<4->*!    for(int i = 0; i < sequence.length; i++)
!*\onslide<5->*!        if(sequence[i] == key)
!*\onslide<5->*!            return i;
!*\onslide<6->*!    return -1; // Magic Number für "not found"
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}
\else
\begin{frame}[fragile,c]{Klassische Suchverfahren}
\begin{plainjava}
!*\onslide<2->*!int linearSearch(int[] sequence, int key){
!*\onslide<3->*!    for(int i = 0; i < sequence.length; i++)
!*\onslide<4->*!        if(sequence[i] == key) return i;
!*\onslide<5->*!    return -1; // Magic Number für "not found"
!*\onslide<2->*!}
\end{plainjava}
\end{frame}
\fi

\begin{frame}{Klassische Suchverfahren}
    \begin{itemize}[<+(1)->]
        \item[]\begin{description}[Linear]
            \item[Binär] \hypertarget<1>{mrk:binsearch}{}Benötigt eine (z.B. aufsteigend) \emph{sortierte} Folge, die baumartig durchstöbert wird.\smallskip\par\pause{} Sie vergleicht das mittlere Element des aktuellen Suchbereiches mit dem Suchbegriff.\pause{} Ist er größer, wird rechts, ist er kleiner, wird links von der Mitte weitergesucht.\pause{} Die Komplexität beträgt \(\O(\log n)\) (ohne Sortieren).
        \end{description}
        \vspace*{1em}
\begin{center}
    \begin{minipage}[c]{.35\linewidth}
        \centering\onslide<7->{\scalebox{0.65}{\begin{forest}
            for tree={inner sep=4pt,ball,outer sep=1pt}
            [,name=m1[[[][[][,phantom]]][[][[][]]]][,name=m2[][,name=m3[,name=m4,iball,inner sep=4.35pt,double[,phantom][]][[]]]]]
            \onslide<+->{
                \draw[-Kite] (m1) to[bend left,looseness=1.25] (m2);
                \draw[-Kite] (m2) to[bend left,looseness=1.15] (m3);
                \draw[-Kite] (m3) to[bend right,looseness=1] (m4);
            }
        \end{forest}}}
    \end{minipage}\qquad\begin{minipage}[c]{.35\linewidth}
        \onslide<8->{\scalebox{0.65}{\begin{tikzpicture}
\foreach[remember=\i as \li(initially 0)] \i in {1,...,9}{
    \ifnum\i=6
        \node[inner sep=4.35pt,iball,double,outer sep=2pt] (\i) at(\i,0) {};
    \else
        \node[inner sep=4pt,ball,outer sep=2pt] (\i) at(\i,0) {};
    \fi
    \ifnum\i>1
        \draw (\li.east) -- (\i.west);
    \fi
}
\onslide<+->{
    \draw[-Kite] (5.80) to[bend left] (7.100);
    \draw[-Kite] (7.-100) to[bend left] (6.-80);
}
\end{tikzpicture}}}
\end{minipage}
\end{center}
        \vfill\hbox{}
    \end{itemize}
\end{frame}

\ifull
\begin{frame}[c]{Binäre Suche}
    \Task{Die binäre Suche}
    \begin{exercise}<2->[Binäre Suche \Time{6}]
        \pause{}Schreiben Sie eine Methode \bjava{int binarySearch(int[], int)}, die ein bereits aufsteigend sortiertes Array mit der binären Suche nach einem gegebene Schlüssel durchsucht und den Index des Schlüssels zurückliefert.
        Wird der Schlüssel nicht gefunden, so soll die Methode einen beliebigen negativen Wert zurückliefern.
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Binäre Suche -- Lösung}
    \begin{solve}<2->[Binäre Suche]
\lstfs{10}\begin{plainjava}
!*\onslide<3->*!int binarySearch(int[] sequence, int key){
!*\onslide<4->*!    int min = 0; // Suche von min
!*\onslide<4->*!    int max = sequence.length - 1; // Suche bis max
!*\onslide<5->*!    while(min <= max) { // Solange [min, max] nicht ungültig ist.
!*\onslide<6->*!        int middle = (min + max)/2; // Mitte
!*\onslide<7->*!        if(sequence[middle] == key) // gefunden
!*\onslide<7->*!            return middle;
!*\onslide<8->*!        else if(key < sequence[middle]) // Suche links [min, middle-1]
!*\onslide<8->*!            max = middle - 1;
!*\onslide<9->*!        else // Suche rechts [middle+1, max]
!*\onslide<9->*!            min = middle + 1;
!*\onslide<5->*!    }
!*\onslide<10->*!    return -1; // Magic Number für "not found"
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}
\else
\begin{frame}[fragile,c]{Klassische Suchverfahren}
    \lstfs{10}%
    \begin{plainjava}
!*\onslide<2->*!int binarySearch(int[] sequence, int key){
!*\onslide<3->*!    int min = 0; // Suche von min
!*\onslide<3->*!    int max = sequence.length - 1; // Suche bis max
!*\onslide<4->*!    while(min <= max) { // Solange [min, max] nicht ungültig ist.
!*\onslide<5->*!        int middle = (min + max)/2; // Mitte
!*\onslide<6->*!        if(sequence[middle] == key) // gefunden
!*\onslide<6->*!            return middle;
!*\onslide<7->*!        else if(key < sequence[middle]) // Suche links [min, middle-1]
!*\onslide<7->*!            max = middle - 1;
!*\onslide<8->*!        else // Suche rechts [middle+1, max]
!*\onslide<8->*!            min = middle + 1;
!*\onslide<4->*!    }
!*\onslide<9->*!    return -1; // Magic Number für "not found"
!*\onslide<2->*!}
\end{plainjava}
\end{frame}
\fi


\subsection{Sortierverfahren}

\begin{frame}{Sortierverfahren formal}
    \begin{itemize}[<+(1)->]
        \item Beschreibt einen Prozess, bei dem Elemente aufgrund eines Ordnungskriteriums in eine Reihenfolge gebracht werden.
        \item Daten werden sortiert um beispielsweise Suchen zu vereinfachen.
        \item Wir unterscheiden zwei konzeptionelle Arten: \begin{description}[Extern]
            \item[Intern] Hier liegt der gesamte Datenbestand im Arbeitspeicher,\pause{} alle Elemente sind zugreifbar (Array,~\ldots)
            \item[Extern] Der Datenbestand ist (überwiegend) ausgelagert.\pause{} Für das Sortieren werden meist nur die obersten Element eines Stapels betrachtet (Dateien,~\ldots).\pause{} Oft erlauben Modifikationen und Hilfsmethoden, dieselben Verfahren wie bei der internen Variante zu verwenden.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Sortierverfahren formal, II}
    \begin{itemize}[<+(1)->]
        \widei
        \item Bei der Vorgehensweise unterscheiden wir (im Kontext der Vorlesung) drei Ansätze: \begin{description}[Divide-and-Conquer]
            \item[Sukzessiv] Schritt für Schritt wird die Anzahl an unsortierten Elementen verringert.\pause{} In der Regel iterativ implementiert.
            \item[Divide-and-Conquer] Daten werden aufgeteilt,\pause{} in Teilen sortiert und dann aus sortierten Teilmengen zusammengefügt.\pause{} In der Regel rekursiv implementiert.
            \item[Halde] Sortieren mit dafür geeigneten Datenstrukturen wie dem \emph{Heap}.\pause{} In der Regel rekursiv implementiert.
        \end{description}
    \end{itemize}
\end{frame}

\def\List#1#2{
    \foreach[count=\i,remember=\i as \li(initially 0)] \n in {#1}{
        \ifnum\i>#2
            \node[inner sep=4pt,ball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
        \else
            \node[inner sep=4pt,iball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
        \fi
        \ifnum\i>1
            \draw (\li.east) -- (\i.west);
        \fi
    }
}

\begin{frame}{Sortierverfahren: Selectionsort}\alglabel{Selectionsort}
    \begin{definition}<2->[Selectionsort \hfill{}(iterativ)]
        \onslide<3->{Prinzip: Wahl des kleinsten Elements im unsortierten Teil, \onslide<4->{Anfügen des Elements als größtes Element des sortierten Teils.}}
    \end{definition}
    \begin{itemize}
        \item<5-> Kann auch von oben nach unten implementiert werden.
        \item<6-> Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item<7-> Ist das kleinste Element an erster Stelle des unsortierten Teils wird dennoch getauscht (nach Vorlesung).
    \end{itemize}
    \vfill
    \begin{center}
\begin{minipage}{.9\linewidth}
\begin{multicols}{2}
    \begin{enumerate}
        \item<8-> \begin{tikzpicture}[scale=.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{4,2,1,3}{0}
            \draw[Kite-Kite] (1.north) to[bend left] (3.north);
        \end{tikzpicture}
        \item<9-> \begin{tikzpicture}[scale=.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{1,2,4,3}{1}
            \draw[Kite-Kite] (2) to[loop above] (2);
        \end{tikzpicture}
        \item<10-> \begin{tikzpicture}[scale=.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{1,2,4,3}{2}
            \draw[Kite-Kite] (3.north) to[bend left] (4.north);
        \end{tikzpicture}
        \item<11-> \begin{tikzpicture}[scale=.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{1,2,3,4}{4}
        \end{tikzpicture}
    \end{enumerate}
\end{multicols}
\end{minipage}
    \end{center}
\end{frame}


\ifull
\begin{frame}[c]{Selectionsort implementieren}
    \Task{Selectionsort implementieren}
    \begin{exercise}<2->[Selectionsort implementieren \Time{6}]
        \pause{}Gegeben sei eine Methode \bjava{int getMin(int[] arr, int i, int j)}, die korrekt das Minimum im Teilarray \([i, j]\) von \bjava{arr} findet. Weiter gegeben sei eine Methode \bjava{void swap(int[] arr, int i, int j)}, die die Elemente mit Index \(i\) und \(j\) in \bjava{arr} vertauscht.\medskip\par\pause Schreiben Sie eine Methode \bjava{int[] selectionSort(int[])}, die das übergebene Array mittels Selectionsort als \emph{neues} aufsteigend sortiertes Array zurückliefert. Das übergebene Array darf nicht verändert werden.
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Selectionsort implementieren -- Lösung}
    \begin{solve}<2->[Selectionsort implementieren]
\lstfs{10}\begin{plainjava}
!*\onslide<3->*!public static int[] selectionSort(int[] arr) {
!*\onslide<4->*!    // Erzeuge Kopie
!*\onslide<5->*!    int[] newArr = new int[arr.length];
!*\onslide<5->*!    for(int i = 0; i < arr.length; i++)
!*\onslide<5->*!        newArr[i] = arr[i];
!*\onslide<5->*!
!*\onslide<6->*!    // Sortiere nach Selectionsort
!*\onslide<7->*!    for(int i = 0; i < newArr.length - 1; i++) {
!*\onslide<8->*!        int min = getMin(newArr, i, newArr.length);
!*\onslide<9->*!        swap(newArr, i, min);
!*\onslide<7->*!    }
!*\onslide<7->*!
!*\onslide<10->*!    return arr;
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}
\fi

\begin{frame}[fragile,c]{Sortierverfahren: Selectionsort}
    \begin{plainjava}
!*\onslide<2->*!public static void selectionSort(int[] arr) {
!*\onslide<3->*!    for(int i = 0; i < arr.length - 1; i++) {
!*\onslide<4->*!        int min = i; // Suche Minimum
!*\onslide<5->*!        for (int j = i + 1; j < arr.length; j++)
!*\onslide<6->*!            if(arr[j] < arr[min])
!*\onslide<6->*!                min = j;
!*\onslide<7->*!        // Tausche 'i' und 'min'
!*\onslide<8->*!        int tmp = arr[i];
!*\onslide<9->*!        arr[i] = arr[min];
!*\onslide<10->*!        arr[min] = tmp;
!*\onslide<3->*!    }
!*\onslide<2->*!}
    \end{plainjava}
\end{frame}

\begin{frame}{Sortierverfahren: Insertionsort}\alglabel{Insertionsort}
    \begin{definition}<2->[Insertionsort \hfill{}(iterativ)]
        \onslide<3->{Prinzip: Wahl des ersten Elements im unsortierten Teil, \onslide<4->{Sortieren des Elements in den bereits sortierten Teil.}}
    \end{definition}
    \begin{itemize}
        \item<5-> Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item<6-> Das Tauschen erfolgt durch durchgehende Vertauschungen.
        \item<7-> Ist das Element schon an der richtigen Position, wird dennoch getauscht.
    \end{itemize}
    \vfill
    \begin{center}\pause
\begin{minipage}{0.9\linewidth}
\begin{multicols}{2}
    \begin{enumerate}[<+(1)->]
        \item<8-> \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{4,2,1,3}{1}
            \draw[-Kite] (1) to (2);
            \draw[Kite-Kite] ([xshift=-15pt]1.north) to[bend left] (2.north);
        \end{tikzpicture}
        \item<9-> \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{2,4,1,3}{2}
            \draw[-Kite] (1) to (2);
            \draw[-Kite] (2) to (3);
            \draw[Kite-Kite] ([xshift=-15pt]1.north) to[bend left] (3.north);
        \end{tikzpicture}
        \item<10-> \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{1,2,4,3}{3}
            \draw[-Kite] (3) to (4);
            \draw[Kite-Kite] ([xshift=-15pt]3.north) to[bend left] (4.north);
        \end{tikzpicture}
        \item<11-> \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \List{1,2,3,4}{4}
        \end{tikzpicture}
    \end{enumerate}
\end{multicols}
\end{minipage}
    \end{center}
\end{frame}

\ifull
\begin{frame}[c]{Insertionsort implementieren}
    \Task{Insertionsort implementieren}
    \begin{exercise}<2->[Insertionsort implementieren \Time{6}]
        \pause{}Gegeben sei eine Methode \bjava{void swap(int[] arr, int i, int j)}, die die Elemente mit Index \(i\) und \(j\) in \bjava{arr} vertauscht.\medskip\par\pause Schreiben Sie eine Methode \bjava{void insertionSort(int[])}, die das übergebene Array mittels Insertionsort aufsteigend sortiert. Dabei darf das Array \emph{nur} durch die übergeben \bjava{swap}-Methode verändert werden.
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Insertionsort implementieren -- Lösung}
    \begin{solve}<2->[Insertionsort implementieren]
\lstfs{10}\begin{plainjava}
!*\onslide<2->*!public static void insertionSort(int[] arr) {
!*\onslide<3->*!    for(int i = 1; i < arr.length; i++) {
!*\onslide<4->*!        int pos = i;
!*\onslide<5->*!        while(pos > 0 && arr[pos] <= arr[pos - 1]) {
!*\onslide<6->*!            swap(arr, pos, pos - 1);
!*\onslide<6->*!            pos -= 1;
!*\onslide<5->*!        }
!*\onslide<3->*!    }
!*\onslide<2->*!}
    \end{plainjava}
    \end{solve}
\end{frame}
\fi

\begin{frame}[fragile,c]{Sortierverfahren: Insertionsort}
    \pause Hier eine Variante, die verschiebt:
    \begin{plainjava}
!*\onslide<3->*!public static void insertionSort(int[] arr) {
!*\onslide<4->*!    for(int i = 1; i < arr.length; i++) {
!*\onslide<5->*!        int pos = i - 1, elem = arr[i];
!*\onslide<6->*!        while(pos >= 0 && arr[pos] > elem) { // Verschiebe
!*\onslide<7->*!            arr[pos + 1] = arr[pos];
!*\onslide<7->*!            pos--;
!*\onslide<6->*!        }
!*\onslide<8->*!        arr[pos+1] = elem;
!*\onslide<4->*!    }
!*\onslide<3->*!}
    \end{plainjava}
\end{frame}

% \fi

\def\List#1#2{
\foreach[count=\i,remember=\i as \li(initially 0)] \n in {#1}{
    \ifnum\i<#2
        \node[inner sep=4pt,ball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
    \else
        \node[inner sep=4pt,iball,outer sep=2pt] (\i) at(1.25*\i,0) {\n};
    \fi
    \ifnum\i>1
        \draw (\li.east) -- (\i.west);
    \fi
}}

\begin{frame}{Sortierverfahren: Bubblesort}\alglabel{Bubblesort}
    \begin{definition}<2->[Bubblesort \hfill{}(iterativ)]
        \onslide<3->{Prinzip: Vertausche benachbarte Elemente wenn sie nicht in Sortierungsreihenfolge sind.}
    \end{definition}
    \begin{itemize}
        \item<4-> Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item<5-> Mit jedem Durchgang über das Array wird (mindestens) ein Element an die richtige Position getauscht.
        \item<6-> (Geringfügige) Verbesserung: Shaker-Sort, schiebt abwechselnd das maximale und minimale Element an die (Ziel-)Position.
    \end{itemize}
    \vfill
    \begin{center}\pause
\begin{minipage}{.9\linewidth}
    \begin{multicols}{2}
        \begin{enumerate}[<+(1)->]
            \item<7-> \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                \List{4,2,1,3}{5}
                \draw[Kite-Kite] (1.north) to[bend left] (2.north);
                \draw[Kite-Kite] (2.north) to[bend left] (3.north);
                \draw[Kite-Kite] (3.north) to[bend left] (4.north);
            \end{tikzpicture}
            \item<8-> \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                \List{2,1,3,4}{4}
                \draw[Kite-Kite] (1.north) to[bend left] (2.north);
            \end{tikzpicture}
            \item<9-> \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                \List{1,2,3,4}{0}
            \end{tikzpicture}
            \item<1->[]
        \end{enumerate}
    \end{multicols}
\end{minipage}
    \end{center}
\end{frame}

\begin{frame}[fragile,c]{Sortierverfahren: Bubblesort}
    \begin{plainjava}
public static void bubbleSort(int[] arr) {
    for(int i = arr.length - 1; i >= 1; i--) {
        for(int j = 0; j < i; j++) {
            if(arr[j] > arr[j+1]) { // Vertausche
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            }
        }
    }
}
    \end{plainjava}
\end{frame}


\ifull
\begin{frame}[c]{Shakersort implementieren}
    \Task{Shakersort implementieren}
    \begin{exercise}<2->[Shakersort implementieren \Time{6}]
        \pause{}Gegeben sei eine Methode \bjava{void swap(int[] arr, int i, int j)}, die die Elemente mit Index \(i\) und \(j\) in \bjava{arr} vertauscht.\medskip\par\pause Schreiben Sie eine Methode \bjava{void shakerSort(int[])}, die das übergebene Array mittels Shakersort aufsteigend sortiert. Dabei darf das Array \emph{nur} durch die übergeben \bjava{swap}-Methode verändert werden.\medskip\par
        Ausgehend von Bubblesort, geht Shakersort \textit{abwechselnd} von links nach rechts und von rechts nach links durch das noch zu sortierende Array. In beiden Richtungen werden Vertauschungen nach Bubblesort durchgeführt.
        Jede Aufwärts- und jede Abwärtsbewegung verringert dabei den noch zu sortierenden Bereich um \(1\).
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Shakersort implementieren -- Lösung}
    \begin{solve}<2->[Shakersort implementieren]
        \pause{}Den noch zu sortierenden Bereich grenzen wir mit \bjava{l} und \bjava{r} ein:
\lstfs{10}\begin{plainjava}
!*\onslide<3->*!public void shakerSort(int[] arr) {
!*\onslide<4->*!    int l = 0, r = arr.length - 1;
!*\onslide<5->*!    while(l < r) {
!*\onslide<6->*!        for(int i = l; i < r; i++) { // aufwärts
!*\onslide<7->*!            if(arr[i] > arr[i + 1]) swap(arr, i, i + 1);
!*\onslide<6->*!        }
!*\onslide<8->*!        r -= 1;
!*\onslide<9->*!        for(int i = r - 1; i >= l; i--) { // abwärts
!*\onslide<10->*!            if(arr[i] > arr[i + 1]) swap(arr, i, i + 1);
!*\onslide<9->*!        }
!*\onslide<11->*!        l += 1;
!*\onslide<5->*!    }
!*\onslide<3->*!}
    \end{plainjava}
    \end{solve}
\end{frame}

\def\XList#1{
\foreach[count=\i,remember=\i as \li(initially 0)] \n in {#1}{
    \node[inner sep=4pt,draw,rounded rectangle,minimum width=3.5em,outer sep=2pt] (\i) at(4em*\i,0) {\strut\n};
    \ifnum\i>1
        \draw (\li.east) -- (\i.west);
    \fi
}}
\begin{frame}[c]{Shakersort visualisieren}
    \Task{Shakersort visualisieren}
    \begin{exercise}<2->[Shakersort visualisieren \Time{5}]
        \pause{}Gegeben sei das folgende Tupel: \begin{equation*}
            (13, -15, 9, 8, 23, 8, 0)
        \end{equation*}
        Visualisieren Sie die einzelnen Durchläufe des Shaker-Sort, indem Sie für jeden auf- und für jeden absteigenden Durchlauf nacheinander alle getätigten Vertauschungen und den (aus Sicht des Algorithmus) noch unsortierten Teil des Tupels angeben.\medskip\par
        Eine beispielhafte erste Ausgabe für das Tupel \((5, 2, 3, 7, 8, 9, 3)\):
        \begin{center}
            \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
                \XList{2, 3, 5, 7, 8, 3, 9}
                \draw[thick] ([yshift=1mm]1.north west) -- ([yshift=1mm]6.north east);
                \draw[Kite-Kite] (1.south) to[bend right] (2.south);
                \draw[Kite-Kite] (2.south) to[bend right] (3.south);
                \draw[Kite-Kite] (6.south) to[bend right] (7.south);
            \end{tikzpicture}
        \end{center}
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[c]{Shakersort visualisieren -- Lösung}
    \begin{solve}<2->[Shakersort visualisieren]
    \begin{enumerate}[<+(1)->]
        \widei
        \setcounter{enumi}{-1}
        \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{13, -15, 9, 8, 23, 8, 0}
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{-15, 9, 8, 13, 8, 0, 23}
            \draw[thick] ([yshift=1mm]1.north west) -- ([yshift=1mm]6.north east);
            \draw[Kite-Kite] (1.south) to[bend right] (2.south);
            \draw[Kite-Kite] (2.south) to[bend right] (3.south);
            \draw[Kite-Kite] (3.south) to[bend right] (4.south);
            \draw[Kite-Kite] (5.south) to[bend right] (6.south);
            \draw[Kite-Kite] (6.south) to[bend right] (7.south);
        \end{tikzpicture} (up)
        \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{-15, 0, 9, 8, 13, 8, 23}
            \draw[thick] ([yshift=1mm]2.north west) -- ([yshift=1mm]6.north east);
            \draw[Kite-Kite] (6.south) to[bend left] (5.south);
            \draw[Kite-Kite] (5.south) to[bend left] (4.south);
            \draw[Kite-Kite] (4.south) to[bend left] (3.south);
            \draw[Kite-Kite] (3.south) to[bend left] (2.south);
        \end{tikzpicture} (down)
        \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{-15, 0, 8, 9, 8, 13, 23}
            \draw[thick] ([yshift=1mm]2.north west) -- ([yshift=1mm]5.north east);
            \draw[Kite-Kite] (3.south) to[bend right] (4.south);
            \draw[Kite-Kite] (5.south) to[bend right] (6.south);
        \end{tikzpicture} (up)
        \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{-15, 0, 8, 8, 9, 13, 23}
            \draw[thick] ([yshift=1mm]3.north west) -- ([yshift=1mm]5.north east);
            \draw[Kite-Kite] (5.south) to[bend left] (4.south);
        \end{tikzpicture} (down)
    \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c]{Shakersort visualisieren -- Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<2->[Shakersort visualisieren\hfill(Fortsetzung)]
    \begin{enumerate}[<+(1)->]
        \widei
        \setcounter{enumi}{3}
        \item \begin{tikzpicture}[gray, scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{-15, 0, 8, 8, 9, 13, 23}
            \draw[thick] ([yshift=1mm]3.north west) -- ([yshift=1mm]5.north east);
            \draw[Kite-Kite] (5.south) to[bend left] (4.south);
        \end{tikzpicture} \textcolor{gray}{(down)}
        \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{-15, 0, 8, 8, 9, 13, 23}
            \draw[thick] ([yshift=1mm]3.north west) -- ([yshift=1mm]4.north east);
        \end{tikzpicture} (up)
        \item \begin{tikzpicture}[scale=0.65,every node/.style={transform shape},baseline=-0.6ex]
            \XList{-15, 0, 8, 8, 9, 13, 23}
            \draw[thick] ([yshift=1mm]4.north west) -- ([yshift=1mm]4.north east);
        \end{tikzpicture} (down)
    \end{enumerate}
    \end{solve}
\end{frame}
\fi

\newsavebox\dotA \newsavebox\dotB \newsavebox\dotC \newsavebox\dotD \newsavebox\dotE \newsavebox\dotF \newsavebox\dotG

\def\TikzList#1#2#3{%
\savebox{#3}{\begin{tikzpicture}
    \foreach[count=\i,remember=\i as \li (initially 0)] \n in {#1}{
        \ifnum\i=#2
            \node[inner sep=4pt,iball,outer sep=0pt,scale=0.8] (\i) at(0.7*\i,0) {\n};
        \else
            \node[inner sep=4pt,ball,outer sep=0pt,scale=0.8] (\i) at(0.7*\i,0) {\n};
        \fi
        \ifnum\i>1 \draw(\li) -- (\i); \fi
    }
    \end{tikzpicture}}
}
% this could be done far more elegant if used without forest :D
\TikzList{4,2,1,3}{5}{\dotA}
\TikzList{4,2}{5}{\dotB}
\TikzList{1,3}{5}{\dotC}
\TikzList{4}{5}{\dotD}
\TikzList{2}{5}{\dotE}
\TikzList{1}{5}{\dotF}
\TikzList{3}{5}{\dotG}


\begin{frame}{Sortierverfahren: Mergesort}\alglabel{Mergesort}
    \begin{definition}<2->[Mergesort \hfill{}(rekursiv)]
        \onslide<3->{Prinzip: Aufteilen der Elemente in einelementige, sortierte Teilfolgen. \onslide<4->{Zusammenfügen sortierter Teilefolgen.}}
    \end{definition}
    \begin{itemize}
        % \item Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item<5-> Verfolgt \emph{easy split}, \emph{hard join}. Das Aufteilen ist leicht (trivial), das Zusammenfügen aufwändig, da hier die Sortierung erfolgen muss.
        \item<6-> Teilt sich auf in: \emph{Split} (aufteilen) und \emph{Merge} (verschmelzen).
    \end{itemize}
    \vfill
    \begin{center}\onslide<7->{
        \scalebox{0.58}{\begin{forest}
            for tree={}
            [\usebox{\dotA},[{\usebox{\dotB}}[{\usebox{\dotD}}][{\usebox{\dotE}}]][{\usebox{\dotC}}[{\usebox{\dotF}}][{\usebox{\dotG}}]]]
            \node at(0,1) {Split};
        \end{forest}} \qquad~~\qquad%
        \TikzList{1,2,3,4}{5}{\dotA}%
        \TikzList{2,4}{5}{\dotB}%
        \TikzList{1,3}{5}{\dotC}%
        \TikzList{4}{5}{\dotD}%
        \TikzList{2}{5}{\dotE}%
        \TikzList{1}{5}{\dotF}%
        \TikzList{3}{5}{\dotG}%
        \scalebox{0.58}{\begin{forest}
            for tree={grow=north}
            [\usebox{\dotA},[{\usebox{\dotC}}[{\usebox{\dotG}}][{\usebox{\dotF}}]][{\usebox{\dotB}}[{\usebox{\dotE}}][{\usebox{\dotD}}]]]
            \node at(0,3.75) {Merge};
        \end{forest}}}
    \end{center}
\end{frame}


\ifull
\begin{frame}[c]{Mergesort Pseudocode}
    \Task{Mergesort Pseudocode}
    \begin{exercise}<2->[Mergesort Pseudocode \Time{7}]
        \pause{}Formulieren Sie Pseudocode, welcher eine gegebene Liste \(l\) mit Elementen \(l_i \in \mathbb{R}\) und Länge \(n\) durch Mergesort aufsteigend sortiert.\pause{}\medskip\par
        Sie dürfen weitere Routinen formulieren. Es sei eine korrekt implementierte Routine \T{cut(l, i, j)} mit folgendem Vertrag gegeben:\RestyleAlgo{tworuled}
\begin{algorithm}[H]
    \PreCode
        \KwIn{Liste \(l = (l_1, \ldots, l_n)\), \(i, j \in \{1, \ldots, n\}\)}
        \KwOut{Teilliste \((l_i, \ldots, l_j)\), falls \(i \leq j\). Sonst (wenn \(i > j\)) eine leere Liste.}
    \StartCode
\end{algorithm}
        \medskip\par
        Weiter dürfen Sie mit \(x_i\) direkt auf das Listenelement an Stelle \(i\) in \(x\) zugreifen (sofern \(1 \leq i \leq n_x\) mit Länge \(n_x\)). Der Ausdruck \say{\T{x + l\textsubscript{i}}} erzeugt eine \emph{neue} Liste \((x_1, \ldots, x_n, l_i)\). Ebenso \say{\T{x + l}} mit \((x_1, \ldots, x_n, l_1, \ldots, l_n)\).
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[c]{Mergesort Pseudocode -- Lösung}
    \begin{solve}<2->[Mergesort Pseudocode]
        \pause{}\small\begin{algorithm}[H]
        \PreCode
            \KwIn{Liste \(l = (l_1, \ldots, l_n)\)}
            \KwOut{Aufsteigend sortierte Liste \(l\).}
        \StartCode
            \Comment{Ein- oder Nullelementig, bereits sortiert:}
            \lIf{\(n \leq 1\)}{\KwRet{l}}
            \(left := \text{\T{cut}}(l, 1, \lfloor\sfrac{n}{2}\rfloor)\)\;
            \(right := \text{\T{cut}}(l, \lfloor\sfrac{n}{2}\rfloor, n)\)\;
            \Comment{Rekursion}
            \(left := \text{\T{mergesort}}(left)\)\;
            \(right := \text{\T{mergesort}}(right)\)\;
            \KwRet \(\text{\T{merge}}(left, right)\)\Comment*[l]{Auf der nächsten Folie}
            \caption{mergesort(t)}
    \end{algorithm}
    \end{solve}
\end{frame}

\begin{frame}[c]{Mergesort Pseudocode -- Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<2->[Mergesort Pseudocode\hfill(Fortsetzung)]
        \pause{}\small\begin{algorithm}[H]
        \PreCode
            \KwIn{Aufsteigend sortierte Listen \(left\) und \(right\) (Längen \(n_{left}\), \(n_{right}\))}
            \KwOut{Aufsteigend sortierte Liste aus \(left\) und \(right\)}
        \StartCode
            \(res := ()\)\Comment*[l]{Initialisiere leere merge-Liste}
            \While(\Comment*[h]{Beide Listen enthalten noch Elemente}){%
                $left \neq ()$ \KwAnd $right \neq ()$%
            }{%
                \eIf{$left_1 \leq right_1$}{
                    \(res := res + left_1\);
                    \(left = \text{\T{cut}}(left, 2, n_{left})\)\;
                }{
                    \(res := res + right_1\);
                    \(right = \text{\T{cut}}(right, 2, n_{right})\)\;
                }
            }
            \(res := (res + left) + right\)\Comment*[l]{Es gilt $left = () \lor right = ()$}
            \KwRet{res}\;
        \caption{merge(left, right)}
    \end{algorithm}
    \end{solve}
\end{frame}
\fi

\TikzList{4,2,1,3}{4}{\dotA}
\TikzList{1,2}{2}{\dotB}
\TikzList{1,3}{5}{\dotC}
\TikzList{4}{5}{\dotD}
\TikzList{2}{5}{\dotE}
\TikzList{1}{5}{\dotF}
\TikzList{3}{5}{\dotG}

\begin{frame}{Sortierverfahren: Quicksort}\alglabel{Quicksort}
    \begin{definition}<2->[Quicksort \hfill{}(rekursiv)]
        \onslide<3->{Prinzip: Wahl eines Pivotelements (z.B. das Letzte).
        \onslide<4->{Aufteilen der Liste in Teil größer und kleiner des Pivotelements. \onslide<5->{Wenn Teillisten nach gleichem Prinzip sortiert: Zusammenfügen aus \emph{Links + Pivot + Rechts}.}}}
    \end{definition}
    \begin{itemize}
        \item<6-> Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item<7-> Verfolgt \emph{hard split}, \emph{easy join}. Das Aufteilen ist aufwändig (sortieren), das Zusammenfügen trivial.
    \end{itemize}
    \vfill
    \begin{center}\onslide<8->{
        \scalebox{0.58}{\begin{forest}
            for tree={}
            [{\usebox{\dotA}},[{\usebox{\dotB}}[{\usebox{\dotF}}][,phantom]][{{\usebox{\dotD}}}[,phantom][,phantom]]]
            \node at(0,1) {Split};
        \end{forest}}\qquad~~\qquad%
        \TikzList{1,2,3,4}{3}{\dotA}
        \TikzList{1,2}{2}{\dotB}
        \TikzList{1,3}{5}{\dotC}
        \TikzList{4}{5}{\dotD}
        \TikzList{2}{5}{\dotE}
        \TikzList{1}{5}{\dotF}
        \TikzList{3}{5}{\dotG}
        \scalebox{0.58}{\begin{forest}
            for tree={grow=north}
            [{\usebox{\dotA}},[{{\usebox{\dotD}}}[,phantom][,phantom]][{\usebox{\dotB}}[,phantom][{\usebox{\dotF}}]]]
            \node at(0,3.75) {Merge};
        \end{forest}}}
    \end{center}
\end{frame}

\ifull
\begin{frame}[c]{Quicksort implementieren}
    \Task{Quicksort implementieren}
    \begin{exercise}<2->[Quicksort implementieren \Time{6}]
        \pause{}Gegeben sei eine Methode \bjava{void swap(int[] arr, int i, int j)}, die die Elemente mit Index \(i\) und \(j\) in \bjava{arr} vertauscht.\medskip\par\pause Schreiben Sie eine Methode \bjava{void quickSort(int[])}, die das übergebene Array mittels Quicksort aufsteigend sortiert. Als Pivot-Element soll stets das erste Element gewählt werden.\medskip\par\pause{}\textit{Tipp:} Arbeiten Sie mit einer Hilfsmethode \bjava{void quickSort(int[] arr, int l, int r)}, welche das Quicksort-Verfahren auf den Array-Ausschnitt \([l, r]\) anwendet.
    \end{exercise}\onslide<1->
\end{frame}

\begin{frame}[fragile,c]{Quicksort implementieren -- Lösung}
    \begin{solve}<2->[Quicksort implementieren]
\lstfs{10}\begin{plainjava}
!*\onslide<2->*!public static void quickSort(int[] arr) {
!*\onslide<3->*!    quickSort(arr, 0, arr.length - 1);
!*\onslide<2->*!}
!*\onslide<2->*!
!*\onslide<4->*!static void quickSort(int[] arr, int l, int r) {
!*\onslide<5->*!    if(l >= r) return;
!*\onslide<6->*!    int div = partition(arr, l, r); // Nächste Folie
!*\onslide<7->*!    quickSort(arr, l, div - 1);
!*\onslide<7->*!    quickSort(arr, div + 1, r);
!*\onslide<4->*!}
    \end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Quicksort implementieren -- Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<2->[Quicksort implementieren\hfill(Fortsetzung)]
\lstfs{10}\begin{plainjava}
static int partition(int[] arr, int l, int r) {
    int end = r;
    swap(arr, l, end); // Einfach: Pivotelement ans Ende tauschen
    int pivot = arr[end];
    l -= 1;

    while (l < r) {
        do { l++; } while (arr[l] < pivot);
        do { r--; } while (arr[r] >= pivot && l < r);
        if (l < r) swap(arr, l, r);
    }
    swap(arr, l, end); // Tausche Pivot zu Marker
    return l;
}
    \end{plainjava}
    \end{solve}
\end{frame}
\fi

\begin{frame}{Sortierverfahren: Heapsort}\alglabel{Heapsort}
    \begin{definition}<2->[Heapsort \hfill{}(rekursiv)]
        \onslide<3->{Prinzip: Verwenden eines (Min-)Heaps zur Speicherung der Elemente. \onslide<4->{Sukzessives Entfernen des Wurzelelements (aktuelles Minimum), zur Wiederherstellung der Heap-Eigenschaft.}}
    \end{definition}
    \begin{itemize}
        \item<5-> Wir arbeiten \emph{in-place}, das heißt wir tauschen die Elemente im Array.
        \item<6-> Die genaue Funktionsweise eines Heaps veranschaulichen wir gleich separat.
    \end{itemize}
    \vfill
    \begin{center}\onslide<7->{%
        \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1,iball[3[4][,phantom]][2]]
        \end{forest}}} \(\to\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [2,iball[3][4]]
        \end{forest}}} \(\to\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [3,iball[4][,phantom]]
        \end{forest}}} \(\to\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [4,iball]
        \end{forest}}}}
    \end{center}
\end{frame}

\begin{frame}{Exkurs: Heap}
    \hypertarget<1>{mrk:Heap}{}%
    \begin{definition}<2->[Heap]
        \onslide<3->{Binärbaum, bei dem gilt: \(\text{Vaterknoten} \leq \text{Kindknoten}\) (\textit{min}).}
    \end{definition}
    \begin{itemize}
        \item<4-> Neue Elemente werden Unten als neues Kind hinzugefügt. \onslide<5->{Wird die Eigenschaft verletzt, werden solange kleinere Kinder nach oben getauscht bis die Eigenschaft wiederhergestellt ist.}
        \item<6-> Beim Entfernen eines Elements wird das Blatt vor der aktuellen Einfügeposition als neue Wurzel getauscht.
        \item<7-> Beispiel: Einfügen der Elemente \(4,2,1,3\).
    \end{itemize}
    \vfill
    \begin{center}\onslide<8->{%
        \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [4[,fill=white][,phantom]]
        \end{forest}}} \(\overset{1}{\to}\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [4,name=4[1,name=1][,fill=white]]
            \draw[Kite-Kite] (4) to[bend right] (1);
        \end{forest}}} \(\overset{2}{\to}\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1[4[,fill=white][,phantom]][2]]
        \end{forest}}} \(\overset{3}{\to}\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1[4,name=4[3,name=3][,phantom]][2]]
            \draw[Kite-Kite] (4) to[bend right] (3);
        \end{forest}}} \(\to\) \parbox{5.65em}{\centering\scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}
            [1[3[4][,phantom]][2]]
        \end{forest}}}}
    \end{center}
\end{frame}

\immediate\write18{wget https://media.githubusercontent.com/media/EagleoutIce/Episode-Heaps/gh-pages/preview-01.png -O logoHeap-\jobname.png}
\begin{frame}[c]{Zur Vertiefung}
\hypertarget<1>{mrk:heap-and-stack}{}%
\centering\vspace*{2em}\par\begin{tikzpicture}
    \onslide<2->{\draw[thick,@primary,rounded corners=2.5pt,path picture={\node at(path picture bounding box.center) {\href{https://media.githubusercontent.com/media/EagleoutIce/Episode-Heaps/gh-pages/noanim_heap.pdf}{\includegraphics[width=8.5cm,height=4.788cm,keepaspectratio]{logoHeap-\jobname.png}}};}] (0,0) rectangle (8.5cm,4.788cm);}
    \onslide<3->{\node[below=2mm] at (current bounding box.south) {Mehr zu \say{Heaps} per Klick\ldots};}
    \onslide<3->{\node[right=1cm,yshift=4.5mm,scale=1.125] at (current bounding box.east) {\qrcode[link]{https://github.com/EagleoutIce/Episode-Heaps/tree/main}};}
\end{tikzpicture}
\end{frame}

\begin{frame}[c]{Sortierverfahren: Zusammenfassung}
    \pause\begin{table}[H]
        \def\arraystretch{1.35}
        \begin{tabular}{l*3{l}*2{r}}
        \toprule
                      & \multicolumn{3}{c}{Laufzeit}  & \\
                      \cmidrule{2-4}
            Verfahren & best & average & worst & Speicher & Ansatz \\
        \midrule
            \linksort{Selectionsort} & \(\O(n^2)\)    & \(\O(n^2)\)      & \(\O(n^2)\)      & \(\O(1)\) & iterativ \\
            \linksort{Insertionsort} & \(\O(n)\)      & \(\O(n^2)\)      & \(\O(n^2)\)      & \(\O(1)\) & iterativ \\
            \linksort{Bubblesort}    & \(\O(n)\)      & \(\O(n^2)\)      & \(\O(n^2)\)      & \(\O(1)\) & iterativ \\
            % Quick-, merge und Heapsort können auch O(n)
            \linksort{Mergesort}     & \(\O(n \log n)\) & \(\O(n \log n)\) & \(\O(n \log n)\) & \(\O(n)\) & rekursiv \\
            \linksort{Quicksort}     & \(\O(n \log n)\) & \(\O(n \log n)\) & \(\O(n^2)\)      & \(\O(\log n)\) & rekursiv \\
            \linksort{Heapsort}      & \(\O(n \log n)\) & \(\O(n\log n)\)  & \(\O(n\log n)\)  & \(\O(1)\) & rekursiv \\
        \bottomrule
        \end{tabular}
    \end{table}
\end{frame}

\begin{frame}{Eigenschaft: Stabil}
    \begin{definition}<2->[Stabiles Sortierverfahren]
        \onslide<3->{Ein Sortierverfahren heißt stabil, wenn es die Reihenfolge (aus Sicht des Verfahrens) gleicher Element nicht ändert.}
    \end{definition}
    \begin{itemize}
        \widei
        \item<4-> Beispiel: Eine alphabetisch nach Namen sortierte Liste an Personen wird nach dem Alter sortiert.\par\onslide<5->{Stabil: die alphabetische Sortierung bleibt bei selbem Alter erhalten.}\medskip
        \begin{center}
            \begin{tabular}{cc}
                32 & Apfeltine \\
                24 & {\sbfamily H}ans \\
                27 & Hansine \\
                24 & {\sbfamily I}nga
            \end{tabular}\quad\(\Longrightarrow\)\quad\begin{tabular}{cc}
                24 & {\sbfamily H}ans \\
                24 & {\sbfamily I}nga \\
                27 & Hansine \\
                32 & Apfeltine
            \end{tabular}
        \end{center}
        \item<6-> Stabile Sortierverfahren (nach Implementation der Vorlesung): \onslide<7->{\linksort{Insertionsort}, \linksort{Quicksort} und \linksort{Mergesort}.}
    \end{itemize}
\end{frame}


\subsection{Konzept: Backtracking}

\begin{frame}{Backtracking}
    \begin{itemize}[<+(1)->]
        \widei
        \item Backtracking ist eine rekursive Lösungsstrategie.
        \item Das Problem wird von einer Teillösung aus bis zur Gesamtlösung erweitert.\pause{} Eine \say{Sackgasse} veranlasst einen neuen Versuch (trial and error).
        \item Im Sackgassen-Fall macht man die Entscheidungen solange Rückgängig, bis man eine andere Erweiterung wählen kann und erweitert die Teillösung dann durch diese.
    \end{itemize}
\end{frame}


\begin{frame}{Backtracking, Beispiele}
    \begin{itemize}[<+(1)->]
        \widei
        \item \emph{Wegfindung im Labyrinth:}\pause{} Gehe vom Startfeld aus solange einen Weg entlang, bis am Ziel angekommen.\pause{} Im Fall einer Sackgasse: springe zur letzten Position zurück, an der es noch einen anderen Weg gab.
        \item \emph{Lösung eines Sudoku.}\pause{} Füge in erstes freies Feld eine der dort möglichen Zahlen ein.\pause{} Verfahre so, bis alle Felder gefüllt sind oder für ein Feld keine Zahl mehr möglich ist.\pause{} In diesem Fall: springe zum letzten Punkt zurück, an dem noch andere Zahlen möglich sind. Probiere weiter.
        \item Rucksackproblem, 8-Damen Problem,~\ldots
    \end{itemize}
\end{frame}

% #region Übungsaufgaben
\fullsubsection{Übungsaufgaben}
\ifull
\begin{frame}[c]{Übungsaufgabe}
    \Task{Sortieralgorithmen abwägen}
    \begin{exercise}<2->[Sortieralgorithmen abwägen \Time{2}]
        Quicksort hat eine schlechtere \emph{worst-case} Laufzeit als Mergesort, wieso trifft man in der Praxis dennoch häufig Quicksort?
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Sortieralgorithmen abwägen]
        \pause{}Mergesort benötigt einen zusätzlichen Speicherplatz von \(\O(n)\), Quicksort ist in-place implementiert und benötigt lediglich \(\O(\log n)\) Speicherplatz zum Verwalten der rekursiven Aufrufe.
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Sortieralgorithmen zeichnen (Mergesort)}
    \begin{exercise}<2->[Sortieralgorithmen zeichnen, I \Time{5}]
        \pause{}Veranschaulichen Sie den Sortierprozess der Zahlenfolge \say{\(5,7,2,5,3,-19,6\)} unter der Verwendung von \emph{Mergesort} grafisch. Geben Sie jeden Schritt an und sortieren Sie aufsteigend.
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Sortieralgorithmen zeichnen, I]
        \pause{}Hier sind Split- und Mergephase wieder aufgespalten:\pause{}
\begin{center}
    \tikzset{block/.append style={sharp corners,rounded rectangle}}%
    \scalebox{0.75}{
    \begin{forest}
        for tree={inner sep=4pt,block,outer sep=1pt,execute at begin node={\strut}}
        [{\(5,7,2,5,3,-19,6\)}[{\(5,7,2,5\)}[{\(5,7\)}[5][7]][{\(2,5\)}[2][5]]][{\(3,-19,6\)}[{\(3,-19\)}[3][-19]][6]]]
    \end{forest}}\qquad~~\qquad\pause{}\scalebox{0.75}{
        \begin{forest}
            for tree={inner sep=4pt,block,outer sep=1pt,execute at begin node={\strut},grow=north}
            [{\(-19,2,3,5,5,6,7\)},iblock[{\(-19,3,6\)}[6][{\(-19, 3\)}[-19][3]]][{\(2,5,5,7\)}[{\(2,5\)}[5][2]][{\(5,7\)}[7][5]]]]
        \end{forest}}
\end{center}
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Sortieralgorithmen zeichnen (Quicksort)}
    \begin{exercise}<2->[Sortieralgorithmen zeichnen, II \Time{5}]
        \onslide<3->{Veranschaulichen Sie den Sortierprozess der Zahlenfolge \(3, -5, -4, 2, 6\) unter der Verwendung von \emph{Quicksort} grafisch. Nutzen Sie das in-place Verfahren durch Vertauschung aus der Vorlesung und sortieren Sie aufsteigend. \onslide<4->{Geben Sie den Zustand der Folge nach jeder Partitionierung aus und markieren Sie die Partitionen.}\medskip\par
        \onslide<5->{Dabei soll stets das erste Element als Pivot gewählt werden.}}
    \end{exercise}
\end{frame}

\def\QsList#1#2{
\foreach[count=\i,remember=\i as \li(initially 0)] \n in {#1}{
    \ifnum\i=#2
        \node[inner sep=4pt,draw,thick,rounded rectangle,minimum width=3em,outer sep=2pt] (\i) at(3.5em*\i,0) {\strut\bfseries\n};
    \else
        \node[inner sep=4pt,draw,rounded rectangle,minimum width=3em,outer sep=2pt] (\i) at(3.5em*\i,0) {\strut\n};
    \fi
    \ifnum\i>1
        \draw (\li.east) -- (\i.west);
    \fi
}}
\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Sortieralgorithmen zeichnen, II]
        \onslide<3->{Ich führe zusätzlich auf, was mit den \bjava{l}- und \bjava{r}-Markern geschieht:}
        \begin{enumerate}
            \widei
            \item<4-> \only<8->{\color{gray}}\begin{tikzpicture}[scale=.6,every node/.style={transform shape},baseline=-.6ex]
                \QsList{3, -5, -4, 2, 6}{1}
            \end{tikzpicture}\onslide<5->{\quad Tausch ans Ende:\quad\begin{tikzpicture}[scale=.6,every node/.style={transform shape},baseline=-.6ex]
                \QsList{6, -5, -4, 2, 3}{5}
            \end{tikzpicture}\medskip\par
            \onslide<6->{\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{6, -5, -4, 2, 3}{5}
                \node[below] at(1.south) {l};
                \node[below] at(4.south) {r};
                \draw[Kite-Kite] (1.north) to[bend left=10] (4.north);
            \end{tikzpicture}:\quad\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{2, -5, -4, 6, 3}{5}
                \node[below] at(4.south) {l, r};
            \end{tikzpicture}}}\medskip\par
            \only<8->{\color{black}}\onslide<7->{Tausche \(l\) und Pivot:\quad\begin{tikzpicture}[scale=.6,every node/.style={transform shape},baseline=-.6ex]
                \QsList{2, -5, -4, 3, 6}{4}
            \end{tikzpicture}}
            \item<9-> \only<13->{\color{gray}}Links: \begin{tikzpicture}[scale=.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{2, -5, -4}{1}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}\onslide<10->{\quad Tausch ans Ende:\quad\begin{tikzpicture}[scale=.6,every node/.style={transform shape},baseline=-.6ex]
                \QsList{-4, -5, 2}{3}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}}\medskip\par
            \onslide<11->{\begin{tikzpicture}[scale=.6,every node/.style={transform shape},baseline=-.6ex]
                \QsList{-4, -5, 2}{3}
                \node[below] at(2.south) {r};
                \node[below] at(3.south) {l};
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}}\medskip\par
            \only<13->{\color{black}}\onslide<12->{Tausche \(l\) und Pivot:\quad\begin{tikzpicture}[scale=.6,every node/.style={transform shape},baseline=-.6ex]
                \QsList{-4, -5, 2}{3}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}}
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<2->[Sortieralgorithmen zeichnen, II\hfill(Fortsetzung)]
        \begin{enumerate}
            \setcounter{enumi}{2}
            \widei
            \item<3-> \only<7->{\color{gray}}Links: \begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{-4, -5}{1}
                \begin{scope}[xshift=2*3.5em,densely dashed,gray]
                    \QsList{2}{0}
                \end{scope}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}\onslide<4->{\quad Tausch ans Ende:\quad\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{-5, -4}{2}
                \begin{scope}[xshift=2*3.5em,densely dashed,gray]
                    \QsList{2}{0}
                \end{scope}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}}\medskip\par\onslide<5->{\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{-5, -4}{2}
                \node[below] at(1.south) {r};
                \node[below] at(2.south) {l};
                \begin{scope}[xshift=2*3.5em,densely dashed,gray]
                    \QsList{2}{0}
                \end{scope}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}}\medskip\par
            \only<7->{\color{black}}\onslide<6->{Tausche \(l\) und Pivot:\quad\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{-5, -4}{2}
                \begin{scope}[xshift=2*3.5em,densely dashed,gray]
                    \QsList{2}{0}
                \end{scope}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}}
            \item<8-> Rechts in\quad\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{-4, -5, 2}{3}
                \begin{scope}[xshift=3*3.5em,densely dashed,gray]
                    \QsList{3, 6}{0}
                \end{scope}
            \end{tikzpicture}\quad ist leer. \onslide<9->{Vertauschungen ändern nichts.}
            \item<10-> Rechts in\quad\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{2, -5, -4, 3, 6}{4}
            \end{tikzpicture}\quad besteht mit \begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
                \QsList{6}{0}
            \end{tikzpicture} nur aus einem Element. \onslide<11->{Vertauschungen ändern nichts}.
        \end{enumerate}
        \onslide<12->{Finales Ergebnis:\quad\begin{tikzpicture}[scale=0.6,every node/.style={transform shape},baseline=-0.6ex]
            \QsList{-5, -4, 2, 3, 6}{0}
        \end{tikzpicture}}
    \end{solve}
\end{frame}
\fi
% #endregion