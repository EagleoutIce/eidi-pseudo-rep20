
\section{Dynamische Datenstrukturen}

\subsection{Listen}

\begin{frame}{Listen - Dynamische Arrays}
    \begin{itemize}[<+(1)->]
        \widei
        \item Für eine Implementation: Betrachte das \href{https://github.com/EagleoutIce/eidi-weihnachttsblatt-19_20}{Weihnachtsblatt}.
        \item Eine ArrayList ist die einfachste Implementation einer Liste.
        \item Wir halten intern ein Array, welches wir dynamisch vergrößern oder Verkleinern.
        \item Das Problem: Einfüge und Löschoperationen bedeuten einen großen Aufwand (durch das Kopieren der Elemente).
        \item Der Vorteil: Der Zugriff auf ein bestimmtes Element erfolgt (da ein Array zugrunde liegt) in \(\O(1)\).
    \end{itemize}
\end{frame}

% Ugly but still, i am lazy right now
\def\Element#1{{\renewcommand{\arraystretch}{1.4}%
    \begin{tabular}{|>{\centering}p{1em}|p{1em}|}
        \hline
            \strut#1 & \\
        \hline
    \end{tabular}%
}}

\def\EndElement{{\renewcommand{\arraystretch}{1.5}%
    \begin{tabular}{|>{\centering\arraybackslash}p{1em}|}
        \hline
            \strut/\\
        \hline
    \end{tabular}
}}

\begin{frame}[fragile]{Listen - Einfach verkettete Liste}
    \renewcommand\arraystretch{1.35}%
    \begin{itemize}[<+(1)->]
        \widei
        \item Hier ist ein Datentyp als Objekt konstruiert, das eine Referenz auf das nächste Objekt besitzt.
        \item Das erste Element, das die Liste beginnt, bezeichnen wir als \emph{Head}, das Letzte, das auf einen definierten letzten Wert (wie \bjava{null}) zeigt, nennen wir \emph{Tail}/\emph{Foot}.
    \end{itemize}%
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Element {
    public int value;
    public Element next;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\begin{tikzpicture}[scale=0.7,every node/.style={transform shape}]
    \node[enode] (a) at (0,0) {\Element{4}};
    \node[enode] (b) at (2.25,0) {\Element{2}};
    \node[enode] (c) at (4.5,0) {\Element{1}};
    \node[enode] (d) at (6.75,0) {\Element{3}};
    \node[enode] (e) at (9,0) {\EndElement};

    \foreach[remember=\i as \li (initially a)] \i in {b,c,d,e}{
        \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
        \fill ($(\li.east)+(-1em,0)$) circle (2pt);
    }

    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]a.south west) to[edge node={node[below=5pt] {head}}] ([xshift=3.75pt,yshift=-4pt]a.south east);
    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]d.south west) to[edge node={node[below=5pt] {foot}}] ([xshift=3.75pt,yshift=-4pt]d.south east);

\end{tikzpicture}
\end{minipage}
    \begin{itemize}[<+(1)->]
        \widei
        \item Doppelt verkettete Listen verbrauchen mehr Speicher und sind komplizierter (da zwei Verweise).
    \end{itemize}%
\end{frame}


\begin{frame}[fragile]{Listen - Einfach verkettete Liste}
    \begin{itemize}[<+(1)->]
        \item Vorteil einer einfach Verketten Liste:\pause{} Das Löschen und Hinzufügen neuer Elemente ist leicht (\(\O(1)\)).\pause{} Nachteil:\pause{} Der direkte Zugriff ist nur durch ein Traversieren möglich.
        \item Hinweis: Manche Operationen benötigen eine Sonderbehandlung im Falle einer leeren Liste.\pause{} So zum Beispiel das Einfügen.
        \item Betrachten wir einmal das Einfügen eines neuen Elements:
    \end{itemize}%
    \begin{multicols}{2}
\begin{enumerate}[<+(1)->]
    \widei
    \item \begin{tikzpicture}[scale=0.75,every node/.style={transform shape}]
            \node[enode] (a) at (0,0) {\Element{4}};
            \node[enode] (b) at (2.25,0) {\Element{2}};
            \node[enode] (c) at (4.5,0) {\Element{3}};
            \node[enode] (d) at (6.75,0) {\EndElement};

            \foreach[remember=\i as \li (initially a)] \i in {b,c,d}{
                \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
                \fill ($(\li.east)+(-1em,0)$) circle (2pt);
            }

            \node[enode] (e) at (4.5,1) {\Element{1}};

        \end{tikzpicture}
    \item \begin{tikzpicture}[scale=0.75,every node/.style={transform shape}]
        \node[enode] (a) at (0,0) {\Element{4}};
        \node[enode] (b) at (2.25,0) {\Element{2}};
        \node[enode] (c) at (4.5,0) {\Element{3}};
        \node[enode] (d) at (6.75,0) {\EndElement};
        \node[enode] (e) at (4.5,1) {\Element{1}};

        \foreach[remember=\i as \li (initially a)] \i in {b}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[-Kite,densely dashed] ($(b.east)+(-1em,0)$) -- (c.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);


        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0.5,1) -- (e.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(e.east)+(-1em,0)$) -- (c.north);
        \fill ($(e.east)+(-1em,0)$) circle (2pt);

        \foreach[remember=\i as \li (initially c)] \i in {d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

    \end{tikzpicture}
    \item \begin{tikzpicture}[scale=0.75,every node/.style={transform shape}]
        \node[enode] (a) at (0,0) {\Element{4}};
        \node[enode] (b) at (2.25,0) {\Element{2}};
        \node[enode] (c) at (4.5,0) {\Element{3}};
        \node[enode] (d) at (6.75,0) {\EndElement};

        \node[enode] (e) at (4.5,1) {\Element{1}};

        \foreach[remember=\i as \li (initially a)] \i in {b}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }

        \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0.5,1) -- (e.west);
        \fill ($(b.east)+(-1em,0)$) circle (2pt);

        \draw[-Kite] ($(e.east)+(-1em,0)$) -- (c.north);
        \fill ($(e.east)+(-1em,0)$) circle (2pt);

        \foreach[remember=\i as \li (initially c)] \i in {d}{
            \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
            \fill ($(\li.east)+(-1em,0)$) circle (2pt);
        }
    \end{tikzpicture}
\end{enumerate}
    \end{multicols}
\end{frame}

\ifull
\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{LinkedList - insert}
    \begin{exercise}<2->[Einfach verkettete Liste - Einfügen \Time{6}]
        \pause{}Sei der folgende Code gegeben:\pause{}
\begin{plainjava}
class Element {
    public int value;
    public Element next;
    public Element(int value, Element next) {
        this.value = value; this.next = next;
    }
}
\end{plainjava}
        \pause{}Schreiben Sie eine Methode \bjava{appendLast(Element root, int i)},\pause{} die ein neues \bjava{Element} mit Wert \(i\) an das Ende der Liste, anhängt.\pause{} Die Liste soll durch den Kopf \bjava{root} gekennzeichnet werden.
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[Einfach verkettete Liste - Einfügen]
        Die erste Methode behandelt den Sonderfall \say{leere Liste}. Die zweite traversiert die Liste so lange,\pause{} bis wir am \emph{Foot} angekommen sind und ersetzt dann den Verweis des vorletzten:\pause{}
\begin{plainjava}
public void appendLast(Element root, int i) {
    if(root == null) root = new Element(i, null);
    else appendLastIter(root, i);
}
\end{plainjava}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \addtocounter{solve}{-1}
    \begin{solve}<2->[Einfach verkettete Liste - Einfügen\hfill{}(Fortsetzung)]
        Wir iterieren:
\begin{plainjava}
public void appendLastIter(Element current, int i){
    if(current.next == null) // found
        current.next = new Element(i, null);
    else appendLastIter(current.next, i);
}
\end{plainjava}
    \end{solve}
\end{frame}
\fi

\def\Element#1{{\renewcommand{\arraystretch}{1.4}%
    \begin{tabular}{|p{1em}|>{\centering}p{1em}|p{1em}|}
        \hline
            & \strut#1 & \\
        \hline
    \end{tabular}%
}}

% NOTE: TODO: NOTE: gutes Beispiel: Undo & Redo, Vearbeitungsverlauf.
% Für doppelt verketteter Baum: GUI/Scene graph parent/child beziehung

\begin{frame}[fragile]{Listen - Doppelt verkettete Liste}
    \renewcommand\arraystretch{1.35}%
    \begin{itemize}[<+(1)->]
        \widei
        \item Mit einfach verketteten Listen können wir in \say{eine Richtung iterieren}.\pause{} Einen Vorgänger kann man damit nur sehr aufwändig bestimmen.
        \item Die doppelt verkettete Liste hält nun jeweils auch noch die Referenz auf das vorherige Element.
    \end{itemize}%
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Element {
    public int value;
    public Element next;
    public Element prev;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\begin{tikzpicture}[scale=0.7,every node/.style={transform shape}]
    \node[enode] (a) at (1.25*0,0) {\Element{4}};
    \node[enode] (b) at (1.25*2.25,0) {\Element{2}};
    \node[enode] (c) at (1.25*4.5,0) {\Element{1}};
    \node[enode] (d) at (1.15*6.75,0) {\EndElement};
    \node[enode] (e) at (-2.25,0) {\EndElement};

    \foreach[remember=\i as \li (initially a)] \i in {b,c}{
        \draw[-Kite] ($(\li.east)+(-1em,-4pt)$) -- ($(\i.west)+(0,-4pt)$);
        \fill ($(\li.east)+(-1em,-4pt)$) circle (2pt);

        \draw[-Kite] ($(\i.west)+(1em,4pt)$) -- ($(\li.east)+(0,4pt)$);
        \fill ($(\i.west)+(1em,4pt)$) circle (2pt);
    }

    \draw[-Kite] ($(c.east)+(-1em,0)$) -- ($(d.west)+(0,0)$);
    \fill ($(c.east)+(-1em,0)$) circle (2pt);

    \draw[-Kite] ($(a.west)+(1em,0)$) -- ($(e.east)+(0,0)$);
    \fill ($(a.west)+(1em,0)$) circle (2pt);

    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]a.south west) to[edge node={node[below=5pt] {head}}] ([xshift=3.75pt,yshift=-4pt]a.south east);
    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]c.south west) to[edge node={node[below=5pt] {foot}}] ([xshift=3.75pt,yshift=-4pt]c.south east);

\end{tikzpicture}
\end{minipage}
    \begin{itemize}[<+(1)->]
        \widei
        \item Den \say{Datentyp} einfach verkettete Liste gliedern wir in eine neue Klasse \bjava{LinkedList} aus, die auch die Operationen wie hinzufügen und löschen übernimmt.
    \end{itemize}%
\end{frame}


% Weitere Aufgabe mit toString()?

\subsection{Stacks \& Queues}

\begin{frame}{Datenstruktur: Stack}
    \hypertarget<1>{mrk:Stack}{}%
    \begin{itemize}[<+(1)->]
        \widei
        \item Ein Stack ist eine Datenstruktur, nach dem LIFO-Prinzip (Last-In, First-Out).\pause{} Es ist nur möglich Elemente oben auf den Stapel zu legen, oder das oberste zu nehmen.
        \item Stacks können bei der Auswertung arithmetischer Funktionien verwendet werden (siehe GdRa).
        \item Die Verwaltung rekursiver Methoden erfolgt über den Stack. So \say{überlagern} die Parameter im rekursiven Aufruf die alten, bis die Methode wieder verlassen wird.
    \end{itemize}
\end{frame}

\begin{frame}{Datenstruktur: Stack}
    \begin{itemize}[<+(1)->]
        \widei
        \item Stacks lassen sich als eine Liste implementieren,\pause{} die nur Zugriffe wie \bjava{appendLast(Element)} und \bjava{removeLast(Element)} zulässt.
        \item Auf Stacks sind zwei wichtige Operationen definiert: \begin{description}[push]
            \item[push] Legt das Element oben auf dem Stack ab.
            \item[pop] Entfernt das oberste Element und liefert es zurück.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Datenstruktur: Queue}
    \begin{itemize}[<+(1)->]
        \widei
        \item Eine Warteschlange ist eine Datenstruktur, nach dem FIFO-Prinzip (First-In, First-Out).\pause{} Es ist nur möglich Elemente hinten in der Schlange einzureihen und vorne von der Schlange zu entfernen.
        \item Queues können zum Puffern verwendet werden (analog zum Schalter).
        \item Es existieren Derivate, wie die \emph{double-ended queue} (ein- und ausreihen auf beiden Seiten) oder die \emph{priority queue} (Elemente mit höherer Prioritöt werden bei \T{enqueue} zuerst aus der Schlange genommen).
    \end{itemize}
\end{frame}

\begin{frame}{Datenstruktur: Queue}
    \begin{itemize}[<+(1)->]
        \widei
        \item Queues lassen sich als eine Liste implementieren,\pause{} die nur Zugriffe wie \bjava{appendFirst(Element)} und \bjava{removeLast(Element)} zulässt.
        \item Auf Queues sind zwei wichtige Operationen definiert: \begin{description}[dequeue]
            \item[enqueue] Reiht ein Element (hinten) in die Schlange ein.
            \item[dequeue] Nimmt ein Element (vorne) aus der Schlange.
        \end{description}
    \end{itemize}
\end{frame}


\begin{frame}[c]{Vergleich: Stack und Queue}
    \begin{center}
        \begin{columns}
            \pause{}
            \begin{column}{.45\textwidth}
\centering\begin{tikzpicture}[scale=0.85,every node/.style={transform shape}]
    \draw[rounded corners=2pt] (0,0) |- ++(3,-4) -- ++(0,4);
    \node at(1.5,-3.5) {42};
    \node at(1.5,-2.5) {13};
    \draw (0,-3) -- ++(3,0);
    \draw (0,-2) -- ++(3,0);

    \draw[Kite-] (3,-2.5) -- ++(1,0) node[right] {top};

    \draw[-Kite,rounded corners=2pt] (-0.5,0.25) node[left] {push} -| ++(1.75,-0.75);
    \draw[Kite-,rounded corners=2pt] (3.5,0.25) node[right] {pop} -| ++(-1.75,-0.75);

\end{tikzpicture}
            \end{column}
            \pause{}%
            \begin{column}{.45\textwidth}
\centering\begin{tikzpicture}[scale=0.85,every node/.style={transform shape}]
    \draw (0,0) -- ++(0,-4)++(3,0) -- ++(0,4);
    \node at(1.5,-2.5) {42};
    \node at(1.5,-1.5) {13};
    \draw (0,-3) -- ++(3,0);
    \draw (0,-2) -- ++(3,0);
    \draw (0,-1) -- ++(3,0);

    \draw[Kite-] (3,-2.5) -- ++(1,0) node[right] {head};
    \draw[Kite-] (3,-1.5) -- ++(1,0) node[right] {tail};

    \draw[-Kite,rounded corners=2pt] (-0.5,0.25) node[left] {enqueue} -| ++(1.75,-0.75);
    \draw[Kite-,overlay,rounded corners=2pt] (3.5,-4.25) node[right] {dequeue} -| ++(-1.75,0.75);

\end{tikzpicture}
            \end{column}
        \end{columns}
    \end{center}
\end{frame}

\subsection{Bäume}

\begin{frame}{Bäume: Formal}
    \begin{itemize}[<+(1)->]
        \widei
        \item Im Gegensatz zu Listen halten Bäume Referenzen auf mehrere Nachfolger.
        \item Ein Spezialfall von Bäumen sind Binärbäume, die maximal zwei Nachfolger haben können.
        \item Knoten erhalten verschiedene Bezeichner: \begin{description}
            \item[Wurzel] Ein Knoten ohne Vorgänger, der den Baum anführt. Ein Baum hat \emph{eine} Wurzel.
            \item[Blatt] Ein Blatt ist ein Knoten ohne Nachfolger.
            \item[Innerer] Ein innerer Knoten ist jeder Knoten der weder Blatt noch Wurzel ist.\pause{} Ein innerer Knoten hat genau einen Vater.
        \end{description}
    \end{itemize}
\end{frame}

\begin{frame}{Bäume: Mathematisch}
    \begin{definition}[Baum]
Ein Baum \(B\) ist ein zusammenhängender, azyklischer Graph \(T = (V,E)\) mit einer endlichen Menge an Knoten \(V\) und Kanten \(E = V \times V\).\pause{} Die Anzahl der eingehenden Kanten darf für jeden Knoten nur maximal \(1\) sein.
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Die Kanten können ungerichtet oder gerichtet (\say{gewurzelter Baum}) sein.
        \item Ein Baum lässt sich auch als rekursive Datenstruktur auffassen.
        \item Hier ist jeder Knoten gleichzeitig die \say{Wurzel} eines Teilbaumes\pause{} der entweder leer sein (\(\widehat{=}\) Blatt)\pause{} oder noch weitere Knoten enthalten kann (\(\widehat{=}\) innerer Knoten).
        \item Jedem Knoten ordnen wir eine \emph{Ebene} zu. \pause{}Sie entspricht der Länge des Pfades von der Wurzel zum Knoten.\pause{} Der Wurzelknoten hat die Ebene \(1\).
    \end{itemize}
\end{frame}

\begin{frame}{Bäume: Mathematisch}
    \begin{itemize}[<+(1)->]
        \widei
        \item Die Höhe des Baumes ist die tiefste Ebene auf der ein Knoten existiert.
        \item Die Verzweigung eines Knotens bezeichnet die Anzahl seiner Kinder.
        \item Binärbäume, bei denen alle Knoten einen Verzweigungsgrad von maximal zwei haben,\pause{} sind von einer besonderen Bedeutung für die Informatik.\pause{} (Sie lassen sich übrigens auch in einem Array repräsentieren.)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Bäume: Implementation}
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Node {
    public int value;
    public Node left;
    public Node right;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\scalebox{0.625}{\begin{forest}
    for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,edge=-Kite}
    [7[3[4[1][9]][,phantom]][6[1[,phantom][5]][3[,phantom][,phantom]]]]
\end{forest}}
\end{minipage}\vfill
    \begin{itemize}[<+(1)->]
        \widei
        \item Wie bei einer einfach verketteten Liste können wir nun den Baum in eine Richtung traversieren.
        \item Analog zur doppelt verketteten Liste gibt es einen Binärbaum mit Verweis auf den Vaterknoten.
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Bäume: Implementation, II}
    \pause{}
    \begin{minipage}{0.4\linewidth}
\small%
\begin{plainjava}
class Node {
    public Node father;

    public int value;
    public Node left;
    public Node right;
    // ...
}
\end{plainjava}
    \end{minipage}\hfill{}\pause{}\begin{minipage}{0.55\linewidth}%
\centering\scalebox{0.625}{\begin{forest}
    for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,edge=Kite-Kite}
    [7[3[4[1][9]][,phantom]][6[1[,phantom][5]][3[,phantom][,phantom]]]]
\end{forest}}
\end{minipage}\vfill
    \begin{itemize}[<+(1)->]
        \widei
        \item Wie bei einer einfach verketteten Liste können wir nun den Baum in eine Richtung traversieren.
        \item Analog zur doppelt verketteten Liste gibt es einen Binärbaum mit Verweis auf den Vaterknoten.
    \end{itemize}
\end{frame}

% burn this -.-
\begin{frame}[c]{Traversierungsverfahren}
    \begin{center}\pause{}
    \begin{tikzpicture}[rounded corners=2pt, fakeblock/.style={rectangle,draw=btcd@color@black},fakesource/.style={midway, centered,minimum height=\baselineskip,execute at begin node={\strut}}]
        \draw[fakeblock] (-1.5,0) rectangle ++ (3.5,0.65) node[fakesource] {Breitendurchlauf};
    \draw[fakeblock] (4,0) rectangle ++ (3.5,0.65) node[fakesource] {Tiefendurchlauf};
    \draw[fakeblock] (1.5,-1.5) rectangle ++ (2.5,0.65) node[fakesource] {Pre-Order};
    \draw[fakeblock] (4.5,-1.5) rectangle ++ (2.5,0.65) node[fakesource] {In-Order};
    \draw[fakeblock] (7.5,-1.5) rectangle ++ (2.5,0.65) node[fakesource] {Post-Order};
    \draw[-Kite] (4+3.5/2,0) to[in=90,out=270] (2.75,-0.85);
    \draw[-Kite] (4+3.5/2,0) to[in=90,out=270] (5.75,-0.85);
    \draw[-Kite] (4+3.5/2,0) to[in=90,out=270] (8.75,-0.85);
    \draw[fakeblock] (1.5+0.25,-1.5) |- ++(2,-0.5) -- ++(0,0.5);
    \draw[fakeblock] (4.5+0.25,-1.5) |- ++(2,-0.5) -- ++(0,0.5);
    \draw[fakeblock] (7.5+0.25,-1.5) |- ++(2,-0.5) -- ++(0,0.5);

    \draw[fakeblock] (0+0.75-1.5,0) |- ++(2,-0.5) -- ++(0,0.5);
    \node at(0.1 + 1.65-1.5, -0.25) {\tiny Ebenen};

    \node at(0.1 + 1.65-1.5, 0.75) [above] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
            \draw (one) -- (two);
            \draw (one) -- (tre);
            \draw (two) -- (six);
            \draw (two) -- (sev);
            \draw (tre) -- (for);
            \draw (tre) -- (fiv);
            \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-Kite] (one) -- (two);
            \draw[-Kite] (two) -- (tre);
            \draw[-Kite] (tre) -- (six);
            \draw[-Kite] (six) -- (sev);
            \draw[-Kite,scale=0.5,transform shape] (sev) -- (fiv);
            \draw[-Kite] (fiv) -- (for);
        \end{scope}
    \end{tikzpicture}};

    \node at(1.6 + 1.15, -1.75) {\tiny root, left, right};
    \node at(1.6 + 1.15, -2.15) [below] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
        \draw (one) -- (two);
        \draw (one) -- (tre);
        \draw (two) -- (six);
        \draw (two) -- (sev);
        \draw (tre) -- (for);
        \draw (tre) -- (fiv);
        \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-Kite] (one) -- (two);
            \draw[-Kite] (two) -- (six);
            \draw[-Kite] (six) to[bend left] (sev);
            \draw[-Kite] (sev) to[out=85,in = 185,looseness=1.15] (tre);
            \draw[-Kite] (tre) -- (fiv);
            \draw[-Kite] (fiv) -- (for);
        \end{scope}
        %%DRAW DEFAULTS DENSLEY DOTTED IN GRAY TO KEEP STYLE
    \end{tikzpicture}};
    \node at(4.6 + 1.15, -1.75) {\tiny left, root, right};
    \node at(4.6 + 1.15, -2.15) [below] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
            \draw (one) -- (two);
            \draw (one) -- (tre);
            \draw (two) -- (six);
            \draw (two) -- (sev);
            \draw (tre) -- (for);
            \draw (tre) -- (fiv);
            \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-Kite] (six) -- (two);
            \draw[-Kite] (two) -- (sev);
            \draw[-Kite] (sev) to[bend left] (one);
            \draw[-Kite] (one) to[bend left] (fiv);
            \draw[-Kite] (fiv) -- (tre);
            \draw[-Kite] (tre) -- (for);
        \end{scope}

    \end{tikzpicture}};
    \node at(7.6 + 1.15, -1.75) {\tiny left, right, root};
    \node at(7.6 + 1.15, -2.15) [below] { \begin{tikzpicture}[
        scale=0.425, every node/.style={transform shape},
        ring/.style={
            ball,%
            execute at begin node={\strut}%
        }]
        \node[ring] at (0,0) (one) {1};
        \node[ring] at (-1.75,-1) (two) {2};
        \node[ring] at (1.75,-1) (tre) {5};
        \node[ring] at (2.75,-2) (for) {7};
        \node[ring] at (.75,-2) (fiv) {6};
        \node[ring] at (-2.75,-2) (six) {3};
        \node[ring] at (-.75,-2) (sev) {4};
        \begin{scope}[every path/.style={densely dotted, thin,black!45}]
            \draw (one) -- (two);
            \draw (one) -- (tre);
            \draw (two) -- (six);
            \draw (two) -- (sev);
            \draw (tre) -- (for);
            \draw (tre) -- (fiv);
            \end{scope}
        \begin{scope}[every path/.style={densely dashed}]
            \draw[-Kite] (six) -- (sev);
            \draw[-Kite] (sev) -- (two);
            \draw[-Kite] (two) to[bend left] (fiv);
            \draw[-Kite] (fiv) -- (for);
            \draw[-Kite] (for) -- (tre);
            \draw[-Kite] (tre) -- (one);
        \end{scope}

    \end{tikzpicture}};
    \end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}{Traversierung: Breitensuche}
    \begin{itemize}[<+(1)->]
        \item In der Breitensuche werden die Knoten Ebene für Ebene von links nach rechts besucht.
        \item \say{Besucht} steht hier für alle möglichen Varianten der Bearbeitung. Dies gilt auch für alle folgenden Traversierungen.
        \item Der folgende Baum veranschaulicht die Reihenfolge der Besuche:
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [1[2[4[8][9]][5[10][11]]][3[6[12][13]][7[14][15]]]]
        \end{forest}}
    \end{center}
\end{frame}

\begin{frame}{Traversierung: Pre-Order}
    \begin{itemize}[<+(1)->]
        \item Bei der Pre-Order Tiefensuche traversieren wir die Knoten über ihre Kinder.
        \item Mit der Pre-Order Strategie wird der aktuelle Knoten bearbeitet, dann rekursiv der linke, dann rekursiv der rechte Teilbaum.\pause{} (Analog gespiegelt)
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [1[2[3[4][5]][6[7][8]]][9[10[11][12]][13[14][15]]]]
        \end{forest}}
    \end{center}
\end{frame}


\begin{frame}{Traversierung: In-Order}
    \begin{itemize}[<+(1)->]
        \item Bei der In-Order Tiefensuche traversieren wir die Knoten über ihre Kinder.
        \item Mit der In-Order Strategie wird erst rekursiv der linke Teilbaum bearbeitet, dann der Knoten selbst und dann rekursiv der rechte Teilbaum.\pause{} (Analog gespiegelt)
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [8[4[2[1][3]][6[5][7]]][12[10[9][11]][14[13][15]]]]
        \end{forest}}
    \end{center}
\end{frame}

\begin{frame}{Traversierung: Post-Order}
    \begin{itemize}[<+(1)->]
        \item Bei der Post-Order Tiefensuche traversieren wir die Knoten über ihre Kinder.
        \item Mit der Post-Order Strategie wird erst rekursiv der linke, dann der rechte Teilbaum und erst dann der Knoten selbst bearbeitet.\pause{} (Analog gespiegelt)
    \end{itemize}
    \pause{}\begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [15[7[3[1][2]][6[4][5]]][14[10[8][9]][13[11][12]]]]
        \end{forest}}
    \end{center}
\end{frame}

\begin{frame}{Suchbäume}
    \begin{itemize}[<+(1)->]
        \widei
        \item Bäume können auch nützliche Datenstrukturen sein, wenn man sie \emph{ordnet}.
        \item So existieren Suchbäume (Alle Elemente im linken Teilbaum sind kleiner oder gleich der Wurzel, alle rechten größer \(\Rightarrow\) \hyperlink{mrk:binsearch}{binäre Suche})
        \item Vergleiche hierzu auch die Datenstruktur \hyperlink{mrk:Heap}{Heap}.
        \item Die Traversierungsverfahren lassen sich auch auf Bäume mit höherem Verzweigungsgrad anwenden!
    \end{itemize}
\end{frame}

\begin{frame}{Arithmetische Bäume}
    \begin{itemize}[<+(1)->]
        \item Binärbäume helfen uns, arithmetische Operationen darzustellen.
    \end{itemize}
    \pause{}
    \begin{center}
        \scalebox{0.625}{\begin{forest}
            for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,minimum width=1.15cm,edge=-Kite}
            [*[+[A][B]][-[C][D]]]
        \end{forest}}
    \end{center}
    \begin{itemize}[<+(1)->]
    \item Die Traversierungsverfahren entsprechen Notationsschemata: \begin{description}[Post-Order]
        \item[In-Order] repräsentiert die geläufige Infix Notation: \((A + B) * (C - D)\) (die Klammern entsprechen der Ausführreihenfolge und sind natürlich nicht Teil)
        \item[Pre-Order] entspricht der Präfix-Notation: \(* + A B - C D\).
        \item[Post-Order] entspricht der Postifx-Notation: \(A B + C D - *\).
    \end{description}
    \end{itemize}
\end{frame}


\subsection{Graphen}

\begin{frame}{Graphen}
    \begin{itemize}[<+(1)->]
        \item Im Gegensatz zu Bäumen können in Graphen die Knoten auch mehrere Vorgänger haben.
    \end{itemize}
    \pause{}
    \begin{definition}[Ungerichter Graph]
        Ist ein Tupel \(G = (V,E)\) aus Knoten \(V\) und Kanten \(E \subseteq \binom{V}{2}\).
    \end{definition}
    \begin{itemize}[<+(1)->]
        \item Die Definitionen von Graphen sind bereits aus FG bekannt. Sie werden hier dennoch zusammengefasst.
    \end{itemize}
    \pause{}
    \begin{definition}[Gerichteter Graph]
        Ein gerichteter Graph definiert sich ähnlich zum ungerichteten, definiert die Kanten aber nicht als Mengen sondern als Tupel \(E \subseteq V \times V\).
    \end{definition}
\end{frame}


\begin{frame}{Begriffe in einem Graphen}
    \pause{}
    \begin{description}[Zusammenhang]
        \widei
        \item[Zusammenhang] Ein Graph heißt zusammenhängend, wenn man jeden Knoten von jedem anderen aus (über die Kanten) erreichen kann.\pause{}
        \item[Weg] Ein Weg bezeichnet eine endliche Folge an Knoten die durch Kanten (egal welcher Richtung) verbunden sind.\pause{}
        \item[Pfad] Ein Pfad ist ein Weg, der die Kantenrichtung beachtet.\pause{}
        \item[Grad] Bezeichnet die Anzahl an Knoten die mit einem Knoten verbunden sind.\pause{} Ist der Graph gerichtet so wird zwischen Eingangs- und Ausgangsgrad unterschieden.
    \end{description}
\end{frame}

\begin{frame}{Varianten von Graphen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Ein gewichteter Graph weißt den Kanten durch eine Abbildung \(w: E \to M\) einen Wert zu.
        \item Wir können einen Graphen durch eine \emph{Adjazenzmatrix} beschreiben.\pause{} Hierbei geben die jeweiligen Zellen \(m_{i,j}\), ob eine Verbindung vom Knoten \(i\) zum Knoten \(j\) besteht (\(m_{i, j} > 0\) für eine Kante).
    \end{itemize}
    \vfill\pause{}
    \begin{minipage}{0.45\linewidth}
\centering\begin{tikzpicture}[kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}]
    \node[kreis] (a) at (0,0) {1};
    \node[kreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
    \end{minipage}\quad\begin{minipage}{0.45\linewidth}%
        \[\bordermatrix{~ & \textcolor{gray}{1} & \textcolor{gray}{2} & \textcolor{gray}{3} & \textcolor{gray}{4} \cr
        \textcolor{gray}{1} & 0 & 1 & 0 & 0\cr
        \textcolor{gray}{2} & 0 & 0 & 1 & 1\cr
        \textcolor{gray}{3} & 1 & 0 & 0 & 1\cr
        \textcolor{gray}{4} & 0 & 1 & 0 & 0\cr
        }\]
    \end{minipage}
\end{frame}

\begin{frame}{Adjazenzlisten}
    \begin{itemize}[<+(1)->]
        \widei
        \item Adjazenzlisten sind eine andere Variante Graphen zu repräsentieren.
        \item Hier hält jeder Knoten eine (verkettete) Liste an seinen benachbarten Knoten.
    \end{itemize}
    \vfill\pause{}
    \begin{minipage}{0.45\linewidth}
\centering\begin{tikzpicture}[kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt}]
    \node[kreis] (a) at (0,0) {1};
    \node[kreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
    \end{minipage}\quad\begin{minipage}{0.45\linewidth}
        \begin{enumerate}
            \item \(\to 2\)
            \item \(\to 3 \to 4\)
            \item \(\to 1 \to 4\)
            \item \(\to 2\)
        \end{enumerate}
    \end{minipage}
\end{frame}

\begin{frame}{Algorithmen auf Graphen}
    \begin{itemize}[<+(1)->]
        \widei
        \item Eine gängiges Problem ist es herauszufinden ob ein Graph Zyklen enthält und/oder ob er zusammenhängend ist.
        \item Wegfindungsproblem wie das kürzeste Wege Probleme (Routenfindung,~\ldots), Traveling Salesman Problem.
        \item Finden des minimalen, aufspannenden Baum.
        \item Exemplarisch betrachtet die Vorlesung die Breiten- und die Tiefensuche.
    \end{itemize}
\end{frame}

\begin{frame}{Graphen durchsuchen: Tiefensuche}
    \begin{itemize}[<+(1)->]
        \widei
        \item In der Tiefensuche besucht man von einem Startknoten aus die anderen benachbarten Knoten und markiert diese.
        \item Dies wird solange vollzogen bis man auf einen bereits beobachteten Knoten trifft.
        \item In diesem Fall wird eine andere Kante besucht. Existiert keine mehr, so geht man zum letzten Knoten zuvor zurück und probiert die Ansätze dort erneut.
    \end{itemize}
    \vfill\pause{}
    \begin{multicols}{5}
        \scriptsize%
    \begin{enumerate}[<+(1)->]
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
    \node[ikreis] (a) at (0,0) {1};
    \node[kreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge[armark] (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[kreis] (c) at (2,-2) {3};
            \node[kreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge[armark] (d) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[kreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge[armark] (b) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[kreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge[armark] (c) (c) edge (a) (d) edge (b) (b) edge (d) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[ikreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge (d) (c) edge (d);
        \end{tikzpicture}
    \end{enumerate}
\end{multicols}
\end{frame}

\begin{frame}{Graphen durchsuchen: Breitensuche}
    \begin{itemize}[<+(1)->]
        \widei
        \item In der Breitensuche besucht man von einem Startknoten aus erst alle benachbarten Knoten.
        \item In diesem Zuge merkt man sich die Nachbarn dieser Knoten uns besucht anschließend diese.
        \item Der Vorteil:\pause{} Wenn alle Kanten gleich Gewichtet sind lässt sich so direkt der kürzeste Weg identifizieren.
    \end{itemize}
    \vfill\pause{}
    \begin{multicols}{5}
        \scriptsize%
    \begin{enumerate}[<+(1)->]
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
    \node[ikreis] (a) at (0,0) {1};
    \node[okreis] (b) at (2,0) {2};
    \node[kreis] (c) at (2,-2) {3};
    \node[kreis] (d) at (0,-2) {4};

    \draw[-Kite] (a) edge[armark] (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
\end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[okreis] (c) at (2,-2) {3};
            \node[okreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge[armark] (d) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[okreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge[armark] (c) (c) edge (a) (b) edge (d) (d) edge (b) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},okreis/.style={inner sep=4pt,oball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[ikreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (b) edge (d) (d) edge[armark] (b) (c) edge (d);
        \end{tikzpicture}
        \item \begin{tikzpicture}[scale=0.625,every node/.style={transform shape},kreis/.style={inner sep=4pt,ball,font=\sffamily,outer sep=1pt},ikreis/.style={inner sep=4pt,iball,font=\sffamily,outer sep=1pt},armark/.style={thick,btcd@color@alerted},baseline=-0.6ex]
            \node[ikreis] (a) at (0,0) {1};
            \node[ikreis] (b) at (2,0) {2};
            \node[ikreis] (c) at (2,-2) {3};
            \node[ikreis] (d) at (0,-2) {4};

            \draw[-Kite] (a) edge (b) (b) edge (c) (c) edge (a) (d) edge (b) (b) edge (d) (c) edge (d);
        \end{tikzpicture}
    \end{enumerate}
\end{multicols}
\end{frame}

\fullsubsection{Übungsaufgaben}
\ifull
% TODO: Liste aufgaben, Baum Aufgaben und eine Aufgabe für binärbäume sowie suchbäume und so.. heap and STack..

\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{LinkedList - toString()}
    \begin{exercise}<2->[LinkedList - toString() \Time{4}]
        Gegeben sei folgender Code.\pause{} Es darf davon ausgegangen werden, dass \bjava{get(int)} korrekt implementiert ist.\pause{} Schreiben Sie eine Methode \bjava{toString()}, die die Elemente in korrekter Reihenfolge ausgibt.\pause{}
{\footnotesize
\begin{plainjava}
public class LinkedList {
    public static class Element {
        int value; Element next;
        public Element(int _v, Element _n) { value = _v; next = _n; }
    }
    Element head;
    public LinkedList() { /* ... */ }
    public Element get(int index) { /* ... */ }
}
\end{plainjava}
}\pause{} Beispiel: \bjava{13, 12, -4, 9,}
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[LinkedList - toString()]
        \pause{}%
\begin{plainjava}
!*\onslide<3->*!public String toString() {
!*\onslide<4->*!    Element current = head;
!*\onslide<5->*!    String strList = "";
!*\onslide<6->*!    while(current != null) {
!*\onslide<7->*!        strList += current.value + ", ";
!*\onslide<8->*!        current = current.next;
!*\onslide<6->*!    }
!*\onslide<9->*!    return strList;
!*\onslide<3->*!}
\end{plainjava}
        \pause{}Ist kein Komma am Ende erwünscht, so genügt ein Check der Form \bjava{if(current.next != null)} für das Anfügen des Kommas.
    \end{solve}
\end{frame}

\def\Element#1{{\renewcommand{\arraystretch}{1.4}%
\begin{tabular}{|>{\centering}p{1em}|p{1em}|}
    \hline
        \strut#1 & \\
    \hline
\end{tabular}%
}}%
\def\EndElement{{\renewcommand{\arraystretch}{1.5}%
\begin{tabular}{|>{\centering\arraybackslash}p{1em}|}
    \hline
        \strut/\\
    \hline
\end{tabular}
}}%

\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{Eine Liste umdrehen}
    \begin{exercise}<2->[Eine Liste umdrehen \Time{6}]
        \pause{}Gegeben sei folgender Code:
{\footnotesize
\begin{plainjava}
public class Element {
    public int value;
    public Element next;
    public Element(int _v, Element _n) {
        value = _v; next = _n;
    }
}
\end{plainjava}
}\pause{} Schreiben Sie eine Methode \bjava{Element reverse(Element head)}, welche die übergebene Liste umkehrt und den neuen Kopf zurück gibt. Gehen Sie auch mit Randfällen wie einer leeren Liste um.
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[Eine Liste umdrehen]
        \pause{}\pause{}%
\begin{plainjava}
Element reverse(Element head) {
    Element reversedHead = null;
    Element current = head;
    while (current != null) {
        Element next = current.next;
        current.next = reversedHead;
        reversedHead = current;
        current = next;
    }
    return reversedHead;
}
\end{plainjava}
    \pause{}Doch was passiert hier?\pause{} Betrachten wir dies im Detail\ldots
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<2->[Eine Liste umdrehen\hfill(Fortsetzung)]
        \onslide<3->{Betrachten wir die Vorgehensweise für die Liste \(4 \to 5 \to 6\).}\smallskip\par
\hfill\onslide<4->{\begin{tikzpicture}[baseline,scale=.6,every node/.append style={transform shape}]
    \node[enode] (a) at (0,0) {\Element{4}};
    \node[enode] (b) at (2.25,0) {\Element{5}};
    \node[enode] (c) at (4.5,0) {\Element{6}};

    \foreach[remember=\i as \li (initially a)] \i in {b,c}{
        \draw[-Kite] ($(\li.east)+(-1em,0)$) -- (\i.west);
        \fill ($(\li.east)+(-1em,0)$) circle (2pt);
    }

    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]a.south west) to[edge node={node[below=5pt] {head}}] ([xshift=3.75pt,yshift=-4pt]a.south east);
    \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]a.north west) to[edge node={node[above=5pt] {current}}] ([xshift=3.75pt,yshift=4pt]a.north east);
\end{tikzpicture}}\hfill\begingroup\lstfs{7}%
\begin{minipage}{.4\linewidth}
\begin{plainjava}
Element reversedHead = null;
Element current = head;
while (current != null) {
    Element next = current.next;
    current.next = reversedHead;
    reversedHead = current;
    current = next;
}
\end{plainjava}
\end{minipage}\endgroup\hfill\par
    \begin{enumerate}
        \item<5-> Da \bjava{reversedHead = null}:\smallskip\par \begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
            \node[enode] (a) at (0,0) {\Element{4}};
            \node[enode] (b) at (2.25,0) {\Element{5}};
            \node[enode] (c) at (4.5,0) {\Element{6}};

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- (c.west);

            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]a.north west) to[edge node={node[above=5pt] {current}}] ([xshift=3.75pt,yshift=4pt]a.north east);
            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]b.north west) to[edge node={node[above=5pt] {next}}] ([xshift=3.75pt,yshift=4pt]b.north east);
        \end{tikzpicture}\qquad\begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
            \node[enode] (a) at (0,0) {\Element{4}};
            \node[enode] (b) at (2.25,0) {\Element{5}};
            \node[enode] (c) at (4.5,0) {\Element{6}};

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- (c.west);

            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]a.north west) to[edge node={node[above=5pt] {reversedHead}}] ([xshift=3.75pt,yshift=4pt]a.north east);
            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]b.north west) to[edge node={node[above=5pt] {current}}] ([xshift=3.75pt,yshift=4pt]b.north east);
        \end{tikzpicture}
    \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<2->[Eine Liste umdrehen\hfill(Fortsetzung)]
        Betrachten wir die Vorgehensweise für die Liste \(4 \to 5 \to 6\).\smallskip\par
\hfill\onslide<3->{\quad\begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
    \node[enode] (a) at (0,0) {\Element{4}};
    \node[enode] (b) at (2.25,0) {\Element{5}};
    \node[enode] (c) at (4.5,0) {\Element{6}};

    \draw[-Kite] ($(b.east)+(-1em,0)$) -- (c.west);

    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]a.south west) to[edge node={node[below=5pt] {reversedHead}}] ([xshift=3.75pt,yshift=-4pt]a.south east);
    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]b.south west) to[edge node={node[below=5pt] {current}}] ([xshift=3.75pt,yshift=-4pt]b.south east);
\end{tikzpicture}}\hfill\begingroup\lstfs{7}%
\begin{minipage}{.4\linewidth}
\begin{plainjava}
Element reversedHead = null;
Element current = head;
while (current != null) {
    Element next = current.next;
    current.next = reversedHead;
    reversedHead = current;
    current = next;
}
\end{plainjava}
\end{minipage}\endgroup\hfill\par
    \begin{enumerate}
        \setcounter{enumi}{1}
        \item<4-> Nun zeigt \bjava{current.next} auf das vorherige Element:\smallskip\par \begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
            \node[enode] (a) at (0,0) {\Element{4}};
            \node[enode] (b) at (2.25,0) {\Element{5}};
            \node[enode] (c) at (4.5,0) {\Element{6}};

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,1) -| (a.north);

            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]a.south west) to[edge node={node[below=5pt] {reversedHead}}] ([xshift=3.75pt,yshift=-4pt]a.south east);
            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]b.south west) to[edge node={node[below=5pt] {current}}] ([xshift=3.75pt,yshift=-4pt]b.south east);
            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]c.north west) to[edge node={node[above=5pt] {next}}] ([xshift=3.75pt,yshift=4pt]c.north east);

        \end{tikzpicture}\qquad\begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
            \node[enode] (a) at (0,0) {\Element{4}};
            \node[enode] (b) at (2.25,0) {\Element{5}};
            \node[enode] (c) at (4.5,0) {\Element{6}};

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,1) -| (a.north);

            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]b.south west) to[edge node={node[below=5pt] {reversedHead}}] ([xshift=3.75pt,yshift=-4pt]b.south east);
            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]c.south west) to[edge node={node[below=5pt] {current}}] ([xshift=3.75pt,yshift=-4pt]c.south east);
            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]c.north west) to[edge node={node[above=5pt] {next}}] ([xshift=3.75pt,yshift=4pt]c.north east);

        \end{tikzpicture}
    \end{enumerate}
    \end{solve}
\end{frame}


\begin{frame}[fragile,c]{Lösung}
    \addtocounter{solve}{-1}%
    \begin{solve}<2->[Eine Liste umdrehen\hfill(Fortsetzung)]
        Betrachten wir die Vorgehensweise für die Liste \(4 \to 5 \to 6\).\smallskip\par
\hfill\onslide<3->{\quad\begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
    \node[enode] (a) at (0,0) {\Element{4}};
    \node[enode] (b) at (2.25,0) {\Element{5}};
    \node[enode] (c) at (4.5,0) {\Element{6}};

    \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,1) -| (a.north);

    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]b.south west) to[edge node={node[below=5pt] {reversedHead}}] ([xshift=3.75pt,yshift=-4pt]b.south east);
    \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]c.south west) to[edge node={node[below=5pt] {current}}] ([xshift=3.75pt,yshift=-4pt]c.south east);
    \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]c.north west) to[edge node={node[above=5pt] {next}}] ([xshift=3.75pt,yshift=4pt]c.north east);
\end{tikzpicture}}\hfill\begingroup\lstfs{7}%
\begin{minipage}{.4\linewidth}
\begin{plainjava}
Element reversedHead = null;
Element current = head;
while (current != null) {
    Element next = current.next;
    current.next = reversedHead;
    reversedHead = current;
    current = next;
}
\end{plainjava}
\end{minipage}\endgroup\hfill\par
    \begin{enumerate}
        \setcounter{enumi}{2}
        \item<4-> \T{reversedHead} und \T{current} wandern durch die Liste:\smallskip\par
        \begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
            \node[enode] (a) at (0,0) {\Element{4}};
            \node[enode] (b) at (2.25,0) {\Element{5}};
            \node[enode] (c) at (4.5,0) {\Element{6}};
            \node[enode] (d) at (6.75,0) {\EndElement};

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,1) -| (a.north);
            \draw[-Kite] ($(c.east)+(-1em,0)$) -- ++(0,.85) -| (b.north);


            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]b.south west) to[edge node={node[below=5pt] {reversedHead}}] ([xshift=3.75pt,yshift=-4pt]b.south east);
            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]c.south west) to[edge node={node[below=5pt] {current}}] ([xshift=3.75pt,yshift=-4pt]c.south east);
            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]d.north west) to[edge node={node[above=5pt] {next}}] ([xshift=3.75pt,yshift=4pt]d.north east);
        \end{tikzpicture}\qquad
        \begin{tikzpicture}[scale=.6,every node/.append style={transform shape},baseline]
            \node[enode] (a) at (0,0) {\Element{4}};
            \node[enode] (b) at (2.25,0) {\Element{5}};
            \node[enode] (c) at (4.5,0) {\Element{6}};
            \node[enode] (d) at (6.75,0) {\EndElement};

            \draw[-Kite] ($(b.east)+(-1em,0)$) -- ++(0,1) -| (a.north);
            \draw[-Kite] ($(c.east)+(-1em,0)$) -- ++(0,.85) -| (b.north);

            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]c.south west) to[edge node={node[below=5pt] {reversedHead}}] ([xshift=3.75pt,yshift=-4pt]c.south east);
            \draw[decorate,decoration={brace,mirror}] ([xshift=-4pt,yshift=-4pt]d.south west) to[edge node={node[below=5pt] {current}}] ([xshift=3.75pt,yshift=-4pt]d.south east);
            \draw[decorate,decoration={brace}] ([xshift=-4pt,yshift=4pt]d.north west) to[edge node={node[above=5pt] {next}}] ([xshift=3.75pt,yshift=4pt]d.north east);
        \end{tikzpicture}
    \end{enumerate}
    \end{solve}
\end{frame}


\begin{frame}[c]{Übungsaufgabe}
    \Task{Theorie: Stack und Queue}
    \begin{exercise}<2->[Theorie zu Stapel und Warteschlange \Time{5}]
        \pause{}Bewerten (wahr/falsch) und Begründen Sie jeweils: \begin{enumerate}[<+(1)->]
            \item Eine Warteschlange lässt sich auch dann implementieren, wenn nur die Datenstruktur \emph{Stack} existiert.
            \item Stacks folgen dem FIFO-Prinzip.
            \item Der Java-(Objekt-)Heap bezeichnet sich nach der Datenstruktur Heap.
        \end{enumerate}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Theorie zu Stapel und Warteschlange]
        \pause{}\begin{enumerate}[<+(1)->]
            \item Queue durch Stack:\pause{} Dies ist wahr. Hierzu benötigt man zwei Stacks, \(A\) und \(B\).\pause{} Neue Elemente werden auf \(A\) abgelegt und von \(B\) genommen.\pause{} Ist \(B\) leer, so werden alle Elemente von \(A\) genommen und auf \(B\) abgelegt (und damit umgedreht).
            \item Stacks sind FIFO:\pause{} Dies ist falsch.\pause{} Stacks folgen dem LIFO (Last-In, First-Out) Prinzip (siehe: \hyperlink{mrk:Stack}{Stack}).
            \item Java-Heap ist Heap:\pause{} Dies ist falsch, der Heap auf dem (komplexe) Daten abgelegt werden,\pause{} hat nur den selben Namen\pause{} (siehe: \T{\href{https://stackoverflow.com/questions/756861/whats-the-relationship-between-a-heap-and-the-heap}{stackoverflow}}).
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[c]{Übungsaufgabe}
    \Task{Traversierung eines Baumes}
    \begin{exercise}<2->[Traversierung eines Baumes \Time{4}]
        \pause{}Gegeben sei der folgende Binärbaum. Gib sowohl die Besuchsreihenfolge des Breitendurchlaufs als auch des In- und Post-Order Durchlaufs an.\pause{}
        \begin{center}
            \scalebox{0.6}{\begin{forest}
                for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,execute at begin node={\strut},minimum width=1.2cm}
                [A[B[,phantom][C[D][,phantom]]][E[F[,phantom][,phantom]][G[H][I]]]]
            \end{forest}}
        \end{center}
        \pause{}Hinweis, die Pre-Order Traversierung wäre: \(A,B,C,D,E,F,G,H,I\).
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Traversierung eines Baumes]
        \begin{center}
            \scalebox{0.5}{\begin{forest}
                for tree={inner sep=4pt,ball,font=\sffamily,outer sep=1pt,execute at begin node={\strut},minimum width=1.2cm}
                [A[B[,phantom][C[D][,phantom]]][E[F[,phantom][,phantom]][G[H][I]]]]
            \end{forest}}
        \end{center}
        \begin{enumerate}[<+(1)->]
            \item Breitendurchlauf:\pause{} \(A,B,E,C,F,G,D,H,I\).
            \item In-Order:\pause{} \(B,D,C,A,F,E,H,G,I\).
            \item Post-Order:\pause{} \(D,C,B,F,H,I,G,E,A\).
        \end{enumerate}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{Traversierung eines Baumes - Java}
    \begin{exercise}<2->[Traversierung eines Baumes - Java \Time{4}]
        Es sei durch folgende Klasse ein Knoten eines Binärbaums notiert, der mit \bjava{Node root} beginnt.\pause{} Schreiben Sie eine Funktion \bjava{inorder(Node)}, die eine In-Order Traversierung vornimmt.\pause{} Der Knoten soll (jeweils) einfach durch \bjava{System.out.println} ausgegeben werden.\pause{}
\begin{plainjava}
public class Node {
    public int value;
    public Node left, right;
    public Node(int _v) {
        /* ... */
    }
}
\end{plainjava}
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[Traversierung eines Baumes - Java]
\pause{}\begin{plainjava}
void inorder(Node n)  {
    if (n == null) return;

    inorder(n.left);
    System.out.println(n.value);
    inorder(n.right);
}
\end{plainjava}
    \end{solve}
\end{frame}


\begin{frame}[c]{Übungsaufgabe}
    \Task{Breitensuche in Adjazenzmatrix - Pseudocode}
    \begin{exercise}<2->[Breitensuche - Pseudocode \Time{6}]
        \label{task:bfs-pseudo}Schreiben Sie Pseudocode, der den folgenden Vertrag durch eine Breitensuche erfüllt:
\RestyleAlgo{tworuled}\medskip\par\pause
\SetKwInput{KwIn}{In}%
\SetKwInput{KwOut}{Out}%
\SetAlgoVlined%
\begin{algorithm}[H]
\PreCode
\KwIn{Ajazenzmatrix \(a\) für \(n \in \mathbb{N}\) Knoten mit \(n > 0\).}
\KwIn{Startknoten \(s \in \{0, \ldots, n - 1\}\) und gesuchter Knoten \(g \in \{0, \ldots, n - 1\}\)}
\KwOut{\say{Ja}, wenn \(g\) von \(s\) aus in \(a\) erreichbar ist. Sonst \say{Nein}.}
\end{algorithm}
        Sie können Mengen, sowie Warteschlangen verwenden: \begin{itemize}
            \item \T{Queue.create()} erzeugt eine neue Warteschlange. \item \T{enqueue(<Wert>)} fügt einen Wert hinten an.
            \item \T{dequeue()} entfernt einen Wert vorne.
            \item \T{size()} liefert Ihnen die Größe der Warteschlange.
        \end{itemize}
    \end{exercise}
\end{frame}

\begin{frame}[c]{Lösung}
    \begin{solve}<2->[Breitensuche - Pseudocode]
\pause{}\footnotesize\RestyleAlgo{tworuled}\SetAlgoVlined%
\begin{algorithm}[H]
\PreCode\StartCode
\(queue \leftarrow \T{Queue.create()}\)\;
\(queue.\T{enqueue}(s)\)\Comment*[r]{Startknoten hinzufügen}
\(visited \leftarrow \{s\}\)\Comment*[r]{Menge markiert bereits beachtete}
\While(\Comment*[f]{Es gibt noch besuchbare Punkte}){\(queue.\T{size}() > 0\)}{
    \(current \leftarrow queue.\T{dequeue}()\)\Comment*[r]{Betrachte nächsten Knoten}
    \lIf(\Comment*[f]{Ist er das Ziel?}){\(current = g\)}{\KwRet\say{Ja}}
    \Comment{Durchsuche Adjazenzmatrix nach allen erreichbaren Knoten}
    \For{i = 0 \KwTo n - 1}{
        \If(\Comment*[f]{Es gibt eine Kante von \(current\) nach \(i\)}){\(a_{current, i} > 0\)} {
            \If(\Comment*[f]{Noch nicht besucht}){\(i \not\in visited\)}{
                \(queue.\T{enqueue}(i)\)\;
                \(visited \leftarrow visited \cup \{i\}\)\Comment*[r]{Füge zu besuchten hinzu.}
            }
        }
    }
}
\KwRet\say{Nein}\;
\end{algorithm}
    \end{solve}
\end{frame}

\begin{frame}[fragile,c]{Übungsaufgabe}
    \Task{Breitensuche in Adjazenzmatrix - Java}
    \begin{exercise}<2->[Breitensuche - Java \Time{6}]
        \pause{}Übersetzen Sie den Pseudocode (frei nach Aufgabe~\ref{task:bfs-pseudo}) in Java Code.
\RestyleAlgo{tworuled}\par\pause
\SetKwFor{While}{Solange}{tue:}{}%
\SetKwFor{For}{Für}{tue:}{}%
\SetKwIF{If}{ElseIf}{Else}{Wenn}{dann:}{sonst wenn}{sonst}{}%
\SetKw{KwTo}{bis}%
\SetKw{KwAnd}{\&}
\SetKw{KwRet}{Rückgabe:}%
\begin{minipage}{.5\linewidth}\scriptsize\RestyleAlgo{tworuled}\SetAlgoVlined%
\begin{algorithm}[H]
\PreCode\StartCode
\(queue \leftarrow\) new empty Queue\;
\(queue.\T{enqueue}(s)\)\;
\(visited \leftarrow \{s\}\)\;
\While{\(queue.\T{size}() > 0\)}{
    \(cur \leftarrow queue.\T{dequeue}()\)\;
    \lIf{\(cur = g\)}{\KwRet wahr}
    \For{i = 0 \KwTo n - 1}{
        \If{\(a_{cur, i} > 0\) \KwAnd \(i \not\in visited\)} {
            \(queue.\T{enqueue}(i)\)\;
            \(visited \leftarrow visited \cup \{i\}\)\;
        }
    }
}
\KwRet falsch\;
\end{algorithm}\end{minipage}\hfill\begin{minipage}{.465\linewidth}%
    \pause{}Gegeben seien die folgenden, korrekt implementierten Klassen:\lstfs{9}\pause
\begin{plainjava}
class Set {
  void add(int value);
  boolean contains(int value);
}
class Queue {
  void enqueue(int value);
  int dequeue();
  int size();
}
\end{plainjava}
\end{minipage}\par
Schreiben Sie eine Java-Methode \bjava{boolean bfs(int[][] a, int s, int g)}. Sie dürfen annehmen, dass \(a\) korrekt ist und \(s\) sowie \(g\) gültig sind.
    \end{exercise}
\end{frame}

\begin{frame}[fragile,c]{Lösung}
    \begin{solve}<2->[Breitensuche - Java]
\lstfs{9}\begin{plainjava}[morekeywords={[4]{enqueue,dequeue,contains,add,size}}]
!*\onslide<3->*!boolean bfs(int[][] a, int s, int g) {
!*\onslide<4->*!    Queue queue = new Queue();
!*\onslide<4->*!    queue.enqueue(s);
!*\onslide<5->*!    Set visited = new Set();
!*\onslide<6->*!    while(queue.size() > 0) {
!*\onslide<7->*!        int cur = queue.dequeue();
!*\onslide<8->*!        if(cur == g) return true;
!*\onslide<9->*!        for(int i = 0; i < a.length; i++) { // oder i <= a.length - 1
!*\onslide<10->*!            if(a[cur][i] > 0 && !visited.contains(i)) {
!*\onslide<11->*!                queue.enqueue(i);
!*\onslide<12->*!                visited.add(i);
!*\onslide<10->*!            }
!*\onslide<9->*!        }
!*\onslide<6->*!    }
!*\onslide<13->*!    return false;
!*\onslide<3->*!}
\end{plainjava}
    \end{solve}
\end{frame}
\fi